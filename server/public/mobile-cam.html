<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NDN Mobile Camera</title>
  <style>
    html, body { margin: 0; padding: 0; background: #0b1020; color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .container { max-width: 720px; margin: 0 auto; padding: 16px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; }
    .row { display: flex; gap: 8px; align-items: center; }
    .muted { color: #cbd5e1; opacity: 0.8; font-size: 12px; }
    video { width: 100%; height: auto; background: black; border-radius: 12px; }
    input, button { font-size: 16px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); color: white; }
    button { background: #4f46e5; border-color: #4f46e5; cursor: pointer; }
    button.secondary { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.24); }
    .error { color: #fecaca; font-weight: 600; }
  </style>
</head>
<body>
  <div id="fatal-error" style="color: #ff5555; margin: 12px auto; max-width: 720px; font-weight: bold;"></div>
  <div class="container">
    <h2>ðŸ“· NDN Mobile Camera</h2>
    <div class="card">
      <div class="row" style="margin-bottom:8px;">
        <label>Pair code</label>
        <input id="code" placeholder="ABCD" maxlength="8" />
        <button id="join">Join</button>
      </div>
      <div class="muted" style="margin-bottom:12px;">Tip: If camera doesnâ€™t start, allow camera permission and retry the Join button.</div>
      <video id="v" playsinline autoplay muted></video>
      <div class="row" style="margin-top:8px; gap:6px; align-items:center;">
        <label for="deviceSelect" class="muted">Camera:</label>
        <select id="deviceSelect" style="min-width:120px;"></select>
        <button id="swap" class="secondary">Switch camera</button>
        <button id="stop" class="secondary">Stop</button>
      </div>
      <div class="row" style="margin-top:6px;">
        <button id="enable" class="secondary">Enable Camera</button>
      </div>
      <div id="msg" class="muted" style="margin-top:8px;"></div>
      <div class="row" style="margin-top:8px; gap:8px; align-items:center;">
        <div id="wsStatus" class="muted">WS: disconnected</div>
        <button id="sendDiag" class="secondary">Send Diagnostics</button>
        <button id="dumpDiag" class="secondary">Show Diagnostics</button>
      </div>
      <pre id="diagOut" style="margin-top:8px; white-space:pre-wrap; max-height:200px; overflow:auto; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px;"> </pre>
    </div>
  </div>
  <script>
  // Show a visible test message in the error box to confirm latest code is running
  document.getElementById('fatal-error').textContent = 'Diagnostics loaded: ' + new Date().toLocaleString();
  const params = new URLSearchParams(location.search)
  const input = document.getElementById('code')
  const joinBtn = document.getElementById('join')
  const enableBtn = document.getElementById('enable')
  const swapBtn = document.getElementById('swap')
  const stopBtn = document.getElementById('stop')
  const deviceSelect = document.getElementById('deviceSelect')
  const v = document.getElementById('v')
  const msg = document.getElementById('msg')

    input.value = (params.get('code') || '').toUpperCase().slice(0, 8)

  let stream = null
  let pc = null
  let ws = null
  let lastFacing = 'environment'
  let deviceId = null
  let devicesList = []
  const wsStatus = document.getElementById('wsStatus')
  const sendDiagBtn = document.getElementById('sendDiag')
  const dumpDiagBtn = document.getElementById('dumpDiag')
  const diagOut = document.getElementById('diagOut')

    function wsUrl() {
      // Allow overriding the backend host via ?server= or ?ws= query param
      const serverParam = params.get('server') || params.get('ws')
      if (serverParam) {
        try {
          const url = new URL(serverParam)
          const proto = url.protocol === 'https:' ? 'wss' : 'ws'
          return `${proto}://${url.host}/ws`
        } catch (e) { console.warn('Invalid server param', e) }
      }
      // Prefer same-origin ws path
      const proto = location.protocol === 'https:' ? 'wss' : 'ws'
      // If this page is opened as a file or from a different host, default to Render backend
      const fallbackHost = 'ninedartnation.onrender.com'
      let host = location.host && location.host !== '' ? location.host : fallbackHost
      // If origin looks like Netlify or something else and the backend is known, prefer Render
      if (!location.host.includes('render') && location.hostname !== 'ninedartnation.onrender.com') {
        host = fallbackHost
      }
      let base = `${proto}://${host}/ws`
      return base
    }

    function sendDiagnostic(msg, details) {
      try {
        const payload = { type: 'cam-diagnostic', code: input.value || '', msg, details }
        // If ws open, send immediately
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(payload))
        else {
          // store to send on connect
          window.__ndn_pending_diag = window.__ndn_pending_diag || []
          window.__ndn_pending_diag.push(payload)
        }
      } catch (e) { console.warn('diag send fail', e) }
    }

    // REST signaling fallback - POST a signal to server
    async function postSignal(type, payload) {
      try {
        const code = (input.value || '').trim().toUpperCase()
        const url = new URL(`/cam/signal/${code}`, window.location.origin)
        await fetch(url.toString(), { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type, payload, source: 'phone' }) })
      } catch (e) { console.warn('postSignal failed', e); sendDiagnostic('postSignal-fail', { err: String(e) }) }
    }

    // Poll for signals via REST
    let pollInterval = null
    async function startPolling(code) {
      if (pollInterval) clearInterval(pollInterval)
      pollInterval = setInterval(async () => {
        try {
          const url = new URL(`/cam/signal/${code}`, window.location.origin)
          const res = await fetch(url.toString())
          const j = await res.json()
          if (j && Array.isArray(j.messages)) {
            for (const m of j.messages) {
              try { handleSignal(m) } catch (e) { console.warn('handleSignal err', e) }
            }
          }
        } catch (e) { console.warn('poll err', e) }
      }, 1500)
    }

    function stopPolling() { if (pollInterval) clearInterval(pollInterval); pollInterval = null }

    function handleSignal(m) {
      if (!m || !m.type) return
      if (m.type === 'cam-offer') {
        // same as ws cam-offer handling
        (async ()=>{
          console.log('REST received offer')
          pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
          stream.getTracks().forEach(t => pc.addTrack(t, stream))
          pc.onicecandidate = (e) => { if (e.candidate) postSignal('cam-ice', e.candidate) }
          await pc.setRemoteDescription(new RTCSessionDescription(m.payload))
          const answer = await pc.createAnswer()
          await pc.setLocalDescription(answer)
          await postSignal('cam-answer', answer)
          log('Streaming to desktop (REST)')
        })()
      } else if (m.type === 'cam-ice') {
        try { pc && pc.addIceCandidate(m.payload) } catch (e) { console.warn('addIce fail', e) }
      }
    }

    function flushPendingDiagnostics() {
      try {
        if (!window.__ndn_pending_diag || !window.__ndn_pending_diag.length) return
        const pending = window.__ndn_pending_diag.splice(0)
        pending.forEach(p => {
          try { ws.send(JSON.stringify(p)) } catch (e) { console.warn('flush send failed', e); window.__ndn_pending_diag.push(p) }
        })
      } catch (e) { console.warn('flush error', e) }
    }

    function log(t) { msg.textContent = t }
    function showFatalError(msg) {
      const el = document.getElementById('fatal-error');
      if (el) el.textContent = msg;
    }
    function clearFatalError() {
      const el = document.getElementById('fatal-error');
      if (el) el.textContent = '';
    }

    function detectFeatures() {
      const isAndroid = /Android/i.test(navigator.userAgent)
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent)
      const supportsPermissions = !!(navigator.permissions && navigator.permissions.query)
      return { isAndroid, isIOS, supportsPermissions }
    }

    // show guidance for Permissions API
    const features = detectFeatures()
    if (features.supportsPermissions) {
      navigator.permissions.query({ name: 'camera' }).then(st => {
        log('Camera permission state: ' + st.state)
      }).catch(() => {})
    }

    async function enumerateDevices() {
      try {
        clearFatalError();
        // Request a minimal stream to ensure labels are available in browsers like iOS Safari
        let miniStream = null
        try { miniStream = await navigator.mediaDevices.getUserMedia({ video: true }) } catch (e) {
          showFatalError('Permission prompt denied or not available: ' + (e && e.message ? e.message : String(e)));
          console.warn('Permission prompt denied or not available:', e)
        }
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        devicesList = videoDevices
        deviceSelect.innerHTML = '';
        videoDevices.forEach((d, i) => {
          const option = document.createElement('option');
          option.value = d.deviceId;
          // Use label if available else friendly name
          option.text = d.label || `Camera ${i+1}`;
          deviceSelect.appendChild(option);
        });
        if (videoDevices.length > 0) {
          deviceId = videoDevices[0].deviceId;
          deviceSelect.value = deviceId;
        }
        if (miniStream) { try { miniStream.getTracks().forEach(t=>t.stop()) } catch {} }
        log('Devices listed: ' + videoDevices.length)
        console.log('Devices:', videoDevices)
        return videoDevices
      } catch (err) {
        showFatalError('Device enumeration error: ' + (err && err.message ? err.message : String(err)));
        log('Device enumeration error')
        console.error('Device enumeration error:', err)
        return []
      }
    }

    async function startCam(facing) {
      if (stream) { try { stream.getTracks().forEach(t => t.stop()) } catch {} }
      try {
        clearFatalError();
        let constraints = { video: {} };
        if (deviceId) {
          constraints.video.deviceId = { exact: deviceId };
        } else {
          constraints.video.facingMode = facing || 'environment';
        }
        console.log('Requesting camera with constraints:', constraints);
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          showFatalError('getUserMedia with deviceId failed: ' + (err && err.message ? err.message : String(err)));
          console.warn('getUserMedia with deviceId failed, retrying with facingMode if possible', err)
          if (deviceId) {
            try {
              stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facing || 'environment' } })
            } catch (err2) {
              showFatalError('getUserMedia with facingMode failed: ' + (err2 && err2.message ? err2.message : String(err2)));
              throw err2
            }
          } else {
            throw err
          }
        }
        console.log('Camera stream obtained:', stream);
        v.srcObject = stream;
        await v.play().catch((e) => { showFatalError('Video play failed: ' + (e && e.message ? e.message : String(e))); console.error('Video play failed:', e); });
        log('Camera started');
      } catch (err) {
        showFatalError('Camera error: ' + (err && err.message ? err.message : String(err)));
        log('Camera error: ' + (err && err.message ? err.message : String(err)));
        console.error('Camera error:', err);
        if (err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')) {
          showFatalError('Permission denied. Please enable camera in Safari settings and retry.');
          log('Permission denied. Please enable camera in Safari settings and retry.')
        }
      }
    }
    // Update deviceId when user selects a camera
    deviceSelect.addEventListener('change', function(e) {
      deviceId = this.value;
      startCam();
    });

    // Enable button triggers permission prompt and populates the device list
    enableBtn.addEventListener('click', async (e) => { e.preventDefault();
      log('Requesting camera permission...')
      const list = await enumerateDevices();
      if (list.length > 0) {
        deviceId = list[0].deviceId
        startCam()
      } else {
        log('No camera devices found or permission denied')
      }
    })

    // Make swap button cycle through available devices if present
    swapBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      if (devicesList && devicesList.length > 1) {
        const idx = devicesList.findIndex(d => d.deviceId === deviceId)
        const next = devicesList[(idx + 1) % devicesList.length]
        deviceId = next.deviceId
        deviceSelect.value = deviceId
        log('Switched to: ' + (next.label || 'camera'))
        await startCam()
      } else {
        // Fallback to toggling facing
        lastFacing = (lastFacing === 'environment' ? 'user' : 'environment')
        await startCam(lastFacing)
      }
    })

    function ensureWS() {
      const u = wsUrl()
      try {
        clearFatalError();
        ws = new WebSocket(u)
      } catch (e) {
        showFatalError('WebSocket creation failed: ' + (e && e.message ? e.message : String(e)));
        log('WebSocket creation failed')
        sendDiagnostic('ws-create-failed', { err: String(e), url: u })
        return Promise.reject(e)
      }
      return new Promise((resolve) => {
        ws.onopen = () => {
          wsStatus.textContent = 'WS: open'
          log('WS connected')
          try { // send any queued diagnostics
            if (window.__ndn_pending_diag && window.__ndn_pending_diag.length) flushPendingDiagnostics()
          } catch (e) { console.warn('pending flush failed', e) }
          resolve(ws)
        }
  ws.onclose = () => { wsStatus.textContent = 'WS: closed'; log('Connection closed'); showFatalError('WebSocket connection closed.'); sendDiagnostic('ws-closed') }
  ws.onerror = (ev) => { wsStatus.textContent = 'WS: error'; log('WebSocket error'); showFatalError('WebSocket error.'); sendDiagnostic('ws-error', { ev: String(ev) }) }
      })
    }

    async function join() {
      const code = (input.value || '').trim().toUpperCase()
      if (!code) { log('Enter a code'); return }
      log('Connecting...')
      console.log('Joining with code:', code)
      try { await startCam(lastFacing) } catch (e) { sendDiagnostic('startCam-failed', { err: String(e) }) }
      try { await ensureWS() } catch (e) { log('WS connect failed'); sendDiagnostic('ensureWS-failed', { err: String(e) }); return }
      log('Joining session...')
      ws.send(JSON.stringify({ type: 'cam-join', code }))
      ws.onmessage = async (ev) => {
        const data = JSON.parse(ev.data)
        console.log('Received message:', data.type)
        if (data.type === 'cam-joined') {
          log('Paired. Negotiating...')
        } else if (data.type === 'cam-offer') {
          console.log('Received offer, creating answer')
          pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
          stream.getTracks().forEach(t => pc.addTrack(t, stream))
          pc.onicecandidate = (e) => { if (e.candidate) { console.log('Sending ICE'); ws.send(JSON.stringify({ type: 'cam-ice', code, payload: e.candidate })) } }
          await pc.setRemoteDescription(new RTCSessionDescription(data.payload))
          const answer = await pc.createAnswer()
          await pc.setLocalDescription(answer)
          console.log('Sending answer')
          ws.send(JSON.stringify({ type: 'cam-answer', code, payload: answer }))
          log('Streaming to desktop...')
        } else if (data.type === 'cam-ice') {
          console.log('Received ICE')
          try { await pc.addIceCandidate(data.payload) } catch {}
        } else if (data.type === 'cam-error') {
          log('Error: ' + (data.code || 'UNKNOWN'))
          sendDiagnostic('cam-error-received', data)
        }
      }
    }

  joinBtn.addEventListener('click', (e) => { e.preventDefault(); join() })
    stopBtn.addEventListener('click', (e) => { e.preventDefault(); try { if (pc) pc.close(); if (ws) ws.close(); if (stream) stream.getTracks().forEach(t=>t.stop()) } catch {}; log('Stopped.') })
  swapBtn.addEventListener('click', async (e) => { e.preventDefault(); lastFacing = (lastFacing === 'environment' ? 'user' : 'environment'); await startCam(lastFacing) })

  // Diagnostic buttons
  sendDiagBtn.addEventListener('click', (e) => { e.preventDefault(); try { if (ws && ws.readyState === WebSocket.OPEN) flushPendingDiagnostics(); log('Diagnostics sent') } catch (e) { console.warn(e); log('Send failed') } })
  dumpDiagBtn.addEventListener('click', (e) => { e.preventDefault(); try { diagOut.textContent = JSON.stringify(window.__ndn_pending_diag || [], null, 2) } catch (e) { diagOut.textContent = String(e) } })
  </script>
</body>
</html>
