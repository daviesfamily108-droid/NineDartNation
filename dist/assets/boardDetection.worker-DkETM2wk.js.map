{"version":3,"file":"boardDetection.worker-DkETM2wk.js","sources":["../src/utils/vision.ts","../src/utils/boardDetection.ts","../src/workers/boardDetection.worker.ts"],"sourcesContent":["// Vision and calibration utilities for dartboard mapping\r\n// Standard dartboard: 18 inches (457.2 mm) outer diameter\r\n// Board dimensions follow standard measurements (millimeters)\r\n// - Inner bull radius: 6.35 mm (12.7 mm diameter)\r\n// - Outer bull radius: 15.9 mm (31.8 mm diameter)\r\n// - Treble inner radius: 99 mm\r\n// - Treble outer radius: 107 mm\r\n// - Double inner radius: 162 mm\r\n// - Double outer radius: 170 mm (playing field outer edge = 340 mm diameter)\r\n\r\nexport type Point = { x: number; y: number }\r\nexport type Homography = [number, number, number, number, number, number, number, number, number] // row-major 3x3\r\n\r\nexport const BoardRadii = {\r\n\tbullInner: 6.35,\r\n\tbullOuter: 15.9,\r\n\ttrebleInner: 99,\r\n\ttrebleOuter: 107,\r\n\tdoubleInner: 162,\r\n\tdoubleOuter: 170,\r\n}\r\n\r\nexport const SectorOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5]\r\n\r\n// Basic 3x3 matrix operations\r\nfunction matMul3(a: Homography, b: Homography): Homography {\r\n\tconst r = new Array(9).fill(0)\r\n\tfor (let i = 0; i < 3; i++) {\r\n\t\tfor (let j = 0; j < 3; j++) {\r\n\t\t\tfor (let k = 0; k < 3; k++) {\r\n\t\t\t\tr[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn r as Homography\r\n}\r\n\r\nexport function applyHomography(H: Homography, p: Point): Point {\r\n\tconst x = p.x, y = p.y\r\n\tconst w = H[6] * x + H[7] * y + H[8]\r\n\tconst nx = (H[0] * x + H[1] * y + H[2]) / w\r\n\tconst ny = (H[3] * x + H[4] * y + H[5]) / w\r\n\treturn { x: nx, y: ny }\r\n}\r\n\r\n// Scale a homography by sx, sy on the destination/image side: H' = S * H\r\n// Where S = diag([sx, sy, 1])\r\nexport function scaleHomography(H: Homography, sx: number, sy: number): Homography {\r\n\treturn [\r\n\t\tsx * H[0], sx * H[1], sx * H[2],\r\n\t\tsy * H[3], sy * H[4], sy * H[5],\r\n\t\tH[6],     H[7],     H[8],\r\n\t] as Homography\r\n}\r\n\r\nexport function invertHomography(H: Homography): Homography {\r\n\t// Inverse of 3x3 matrix\r\n\tconst m = H\r\n\tconst a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5], g = m[6], h = m[7], i = m[8]\r\n\tconst A = e * i - f * h\r\n\tconst B = c * h - b * i\r\n\tconst C = b * f - c * e\r\n\tconst D = f * g - d * i\r\n\tconst E = a * i - c * g\r\n\tconst F = c * d - a * f\r\n\tconst G = d * h - e * g\r\n\tconst Hh = b * g - a * h\r\n\tconst I = a * e - b * d\r\n\tconst det = a * A + b * D + c * G\r\n\tif (Math.abs(det) < 1e-12) throw new Error('Singular homography')\r\n\tconst inv = [\r\n\t\tA / det, B / det, C / det,\r\n\t\tD / det, E / det, F / det,\r\n\t\tG / det, Hh / det, I / det,\r\n\t] as Homography\r\n\treturn inv\r\n}\r\n\r\n// Compute homography H that maps src (board space) -> dst (image space)\r\n// Using N correspondences via DLT (solved by Gaussian elimination) with least-squares fit\r\n// Supports overdetermined systems (N > 4) for improved accuracy\r\nexport function computeHomographyDLT(src: Point[], dst: Point[]): Homography {\r\n\tif (src.length < 4 || dst.length < 4) throw new Error('Need at least 4 correspondences')\r\n\tif (src.length !== dst.length) throw new Error('Correspondences must have equal length')\r\n\t// Build A * h = b where h = [h11 h12 h13 h21 h22 h23 h31 h32]^T and h33 = 1\r\n\tconst A: number[][] = []\r\n\tconst B: number[] = []\r\n\tfor (let k = 0; k < src.length; k++) {\r\n\t\tconst { x: X, y: Y } = src[k]\r\n\t\tconst { x: x, y: y } = dst[k]\r\n\t\t// x = (h11 X + h12 Y + h13) / (h31 X + h32 Y + 1)\r\n\t\t// y = (h21 X + h22 Y + h23) / (h31 X + h32 Y + 1)\r\n\t\t// => x*(h31 X + h32 Y + 1) = h11 X + h12 Y + h13\r\n\t\t// => y*(h31 X + h32 Y + 1) = h21 X + h22 Y + h23\r\n\t\tA.push([X, Y, 1, 0, 0, 0, -x * X, -x * Y])\r\n\t\tB.push(x)\r\n\t\tA.push([0, 0, 0, X, Y, 1, -y * X, -y * Y])\r\n\t\tB.push(y)\r\n\t}\r\n\tconst h = solveLeastSquares(A, B) // length 8\r\n\tconst H: Homography = [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1]\r\n\treturn H\r\n}\r\n\r\n// Solve A x = b in least squares sense using Gaussian elimination with partial pivoting\r\nfunction solveLeastSquares(A: number[][], b: number[]): number[] {\r\n\t// Normal equations: (A^T A) x = A^T b\r\n\tconst m = A.length, n = A[0].length\r\n\tconst AtA: number[][] = Array.from({ length: n }, () => new Array(n).fill(0))\r\n\tconst Atb: number[] = new Array(n).fill(0)\r\n\tfor (let r = 0; r < m; r++) {\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tAtb[i] += A[r][i] * b[r]\r\n\t\t\tfor (let j = 0; j < n; j++) {\r\n\t\t\t\tAtA[i][j] += A[r][i] * A[r][j]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn gaussianSolve(AtA, Atb)\r\n}\r\n\r\nfunction gaussianSolve(M: number[][], v: number[]): number[] {\r\n\tconst n = v.length\r\n\t// Augment matrix\r\n\tconst A = M.map((row, i) => row.concat([v[i]]))\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\t// Pivot\r\n\t\tlet maxRow = i\r\n\t\tfor (let r = i + 1; r < n; r++) {\r\n\t\t\tif (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r\r\n\t\t}\r\n\t\tif (Math.abs(A[maxRow][i]) < 1e-12) throw new Error('Singular matrix')\r\n\t\tif (maxRow !== i) {\r\n\t\t\tconst tmp = A[i]; A[i] = A[maxRow]; A[maxRow] = tmp\r\n\t\t}\r\n\t\t// Eliminate\r\n\t\tfor (let r = i + 1; r < n; r++) {\r\n\t\t\tconst f = A[r][i] / A[i][i]\r\n\t\t\tfor (let c = i; c <= n; c++) A[r][c] -= f * A[i][c]\r\n\t\t}\r\n\t}\r\n\t// Back substitution\r\n\tconst x = new Array(n).fill(0)\r\n\tfor (let i = n - 1; i >= 0; i--) {\r\n\t\tlet s = A[i][n]\r\n\t\tfor (let c = i + 1; c < n; c++) s -= A[i][c] * x[c]\r\n\t\tx[i] = s / A[i][i]\r\n\t}\r\n\treturn x\r\n}\r\n\r\n// Canonical calibration targets in board space (mm)\r\n// We now anchor the homography with four evenly spaced double-ring sectors:\r\n// D20 (top), D6 (right), D3 (bottom), and D11 (left).\r\nexport function canonicalRimTargets(): Point[] {\r\n\tconst doubleR = BoardRadii.doubleOuter\r\n\tconst targetSectors = [20, 6, 3, 11] as const\r\n\treturn targetSectors.map(sector => {\r\n\t\tconst idx = SectorOrder.indexOf(sector)\r\n\t\tconst angle = (idx / SectorOrder.length) * Math.PI * 2 - Math.PI / 2\r\n\t\tconst x = doubleR * Math.cos(angle)\r\n\t\tconst y = doubleR * Math.sin(angle)\r\n\t\treturn {\r\n\t\t\tx: Math.abs(x) < 1e-9 ? 0 : x,\r\n\t\t\ty: Math.abs(y) < 1e-9 ? 0 : y,\r\n\t\t}\r\n\t})\r\n}\r\n\r\n// Given a homography mapping board->image, produce polylines for overlay rings (in image px)\r\nexport function sampleRing(H: Homography, radius: number, steps = 256): Point[] {\r\n\tconst pts: Point[] = []\r\n\tfor (let k = 0; k < steps; k++) {\r\n\t\tconst theta = (k / steps) * Math.PI * 2\r\n\t\tconst p = applyHomography(H, { x: radius * Math.cos(theta), y: radius * Math.sin(theta) })\r\n\t\tpts.push(p)\r\n\t}\r\n\treturn pts\r\n}\r\n\r\nexport function rmsError(H: Homography, src: Point[], dst: Point[]): number {\r\n\tlet e2 = 0\r\n\tfor (let i = 0; i < src.length; i++) {\r\n\t\tconst p = applyHomography(H, src[i])\r\n\t\tconst dx = p.x - dst[i].x\r\n\t\tconst dy = p.y - dst[i].y\r\n\t\te2 += dx * dx + dy * dy\r\n\t}\r\n\treturn Math.sqrt(e2 / src.length)\r\n}\r\n\r\n// Map an image point to board coordinates using inverse homography (image->board)\r\nexport function imageToBoard(H_boardToImage: Homography, pImg: Point): Point {\r\n\tconst inv = invertHomography(H_boardToImage)\r\n\treturn applyHomography(inv as Homography, pImg)\r\n}\r\n\r\n// Compute score for a board coordinate (mm)\r\nexport function scoreAtBoardPoint(p: Point): { base: number; ring: 'MISS'|'SINGLE'|'DOUBLE'|'TRIPLE'|'BULL'|'INNER_BULL'; sector: number | null; mult: 0|1|2|3 } {\r\n\tconst r = Math.hypot(p.x, p.y)\r\n\tconst ang = Math.atan2(p.y, p.x) // 0 rad at +X, increasing CCW\r\n\t// Rotate so that sector 20 is at the top (negative Y). Top corresponds to -90 degrees (or 270)\r\n\tlet deg = ang * 180 / Math.PI\r\n\tdeg = (deg + 360 + 90) % 360 // shift so 0 deg is at top\r\n\tconst sector = SectorOrder[Math.floor(((360 - deg) % 360) / 18)] // clockwise ordering\r\n\r\n\tif (r <= BoardRadii.bullInner) return { base: 50, ring: 'INNER_BULL', sector: 25, mult: 2 }\r\n\tif (r <= BoardRadii.bullOuter) return { base: 25, ring: 'BULL', sector: 25, mult: 1 }\r\n\tif (r >= BoardRadii.doubleOuter) return { base: 0, ring: 'MISS', sector: null, mult: 0 }\r\n\tif (r >= BoardRadii.doubleInner) return { base: sector * 2, ring: 'DOUBLE', sector, mult: 2 }\r\n\tif (r >= BoardRadii.trebleOuter) return { base: sector, ring: 'SINGLE', sector, mult: 1 }\r\n\tif (r >= BoardRadii.trebleInner) return { base: sector * 3, ring: 'TRIPLE', sector, mult: 3 }\r\n\treturn { base: sector, ring: 'SINGLE', sector, mult: 1 }\r\n}\r\n\r\nexport function drawPolyline(ctx: CanvasRenderingContext2D, pts: Point[], color = '#10b981', width = 2) {\r\n\tif (!pts.length) return\r\n\tctx.save()\r\n\tctx.strokeStyle = color\r\n\tctx.lineWidth = width\r\n\tctx.beginPath()\r\n\tctx.moveTo(pts[0].x, pts[0].y)\r\n\tfor (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y)\r\n\tctx.closePath()\r\n\tctx.stroke()\r\n\tctx.restore()\r\n}\r\n\r\nexport function drawCross(ctx: CanvasRenderingContext2D, p: Point, color = '#f59e0b') {\r\n\tctx.save()\r\n\tctx.strokeStyle = color\r\n\tctx.lineWidth = 2\r\n\tctx.beginPath()\r\n\tctx.moveTo(p.x - 8, p.y)\r\n\tctx.lineTo(p.x + 8, p.y)\r\n\tctx.moveTo(p.x, p.y - 8)\r\n\tctx.lineTo(p.x, p.y + 8)\r\n\tctx.stroke()\r\n\tctx.restore()\r\n}\r\n\r\n// --- Point refinement using Sobel gradient ---\r\nfunction clamp(v: number, lo: number, hi: number) { return Math.max(lo, Math.min(hi, v)) }\r\n\r\nfunction sobelAtGray(img: ImageData, x: number, y: number): number {\r\n\tconst { width, data } = img\r\n\t// Sobel kernels\r\n\tconst gx = [[-1,0,1],[-2,0,2],[-1,0,1]]\r\n\tconst gy = [[-1,-2,-1],[0,0,0],[1,2,1]]\r\n\tlet sx = 0, sy = 0\r\n\tfor (let j = -1; j <= 1; j++) {\r\n\t\tfor (let i = -1; i <= 1; i++) {\r\n\t\t\tconst xi = clamp(x + i, 0, width - 1)\r\n\t\t\tconst yi = clamp(y + j, 0, img.height - 1)\r\n\t\t\tconst idx = (yi * width + xi) * 4\r\n\t\t\tconst r = data[idx], g = data[idx+1], b = data[idx+2]\r\n\t\t\tconst gray = 0.299*r + 0.587*g + 0.114*b\r\n\t\t\tsx += gray * gx[j+1][i+1]\r\n\t\t\tsy += gray * gy[j+1][i+1]\r\n\t\t}\r\n\t}\r\n\treturn Math.hypot(sx, sy)\r\n}\r\n\r\nexport function refinePointSobel(canvas: HTMLCanvasElement, p: Point, radius = 6): Point {\r\n\tconst ctx = canvas.getContext('2d')!\r\n\tconst img = ctx.getImageData(0, 0, canvas.width, canvas.height)\r\n\tconst cx = clamp(Math.round(p.x), 1, canvas.width - 2)\r\n\tconst cy = clamp(Math.round(p.y), 1, canvas.height - 2)\r\n\tlet best = { x: cx, y: cy, mag: -1 }\r\n\tfor (let y = cy - radius; y <= cy + radius; y++) {\r\n\t\tfor (let x = cx - radius; x <= cx + radius; x++) {\r\n\t\t\tif (x <= 0 || y <= 0 || x >= canvas.width-1 || y >= canvas.height-1) continue\r\n\t\t\tconst mag = sobelAtGray(img, x, y)\r\n\t\t\tif (mag > best.mag) best = { x, y, mag }\r\n\t\t}\r\n\t}\r\n\treturn { x: best.x, y: best.y }\r\n}\r\n\r\nexport function refinePointsSobel(canvas: HTMLCanvasElement, pts: Point[], radius = 6): Point[] {\r\n\treturn pts.map(p => refinePointSobel(canvas, p, radius))\r\n}\r\n\r\n","/**\r\n * Advanced Dartboard Auto-Calibration\r\n * \r\n * Detects dartboard features automatically without markers or manual clicking:\r\n * 1. Detects bull (inner & outer rings) using circle detection\r\n * 2. Detects treble and double rings using edge/circle detection\r\n * 3. Computes board center and orientation\r\n * 4. Generates calibration points from detected rings\r\n * 5. Computes homography without user interaction\r\n */\r\n\r\nimport { BoardRadii, computeHomographyDLT, rmsError, type Homography, type Point } from './vision'\r\n\r\nconst isFinitePoint = (p: Point | undefined): p is Point => !!p && Number.isFinite(p.x) && Number.isFinite(p.y)\r\nconst isFiniteHomography = (H: Homography | null | undefined): H is Homography => Array.isArray(H) && H.length === 9 && H.every(Number.isFinite)\r\n\r\nexport interface BoardDetectionResult {\r\n  success: boolean\r\n  cx: number              // Board center X in image\r\n  cy: number              // Board center Y in image\r\n  bullInner: number       // Detected inner bull radius (pixels)\r\n  bullOuter: number       // Detected outer bull radius (pixels)\r\n  trebleInner: number     // Detected treble inner radius (pixels)\r\n  trebleOuter: number     // Detected treble outer radius (pixels)\r\n  doubleInner: number     // Detected double inner radius (pixels)\r\n  doubleOuter: number     // Detected double outer radius (pixels)\r\n  confidence: number      // 0-100, quality of detection\r\n  homography: Homography | null\r\n  errorPx: number | null\r\n  calibrationPoints: Point[]\r\n  message?: string\r\n}\r\n\r\n/**\r\n * Detect dartboard by finding concentric rings\r\n * Simpler, more direct approach: look for strong circular edges at the right distances\r\n */\r\nfunction findDartboardRings(canvas: HTMLCanvasElement): { cx: number; cy: number; r: number; confidence: number } | null {\r\n  const ctx = canvas.getContext('2d')\r\n  if (!ctx) return null\r\n\r\n  const w = canvas.width\r\n  const h = canvas.height\r\n  const imageData = ctx.getImageData(0, 0, w, h)\r\n  const data = imageData.data\r\n\r\n  // Step 1: Find all strong edges using Canny-like detection\r\n  const edges: Array<{ x: number; y: number; mag: number }> = []\r\n\r\n  for (let y = 2; y < h - 2; y++) {\r\n    for (let x = 2; x < w - 2; x++) {\r\n      const idx = (y * w + x) * 4\r\n      \r\n      // Compute gradients\r\n      let gx = 0, gy = 0\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n          const pidx = ((y + dy) * w + (x + dx)) * 4\r\n          const gray = data[pidx] * 0.299 + data[pidx + 1] * 0.587 + data[pidx + 2] * 0.114\r\n          if (dx !== 0) gx += (dx > 0 ? 1 : -1) * gray\r\n          if (dy !== 0) gy += (dy > 0 ? 1 : -1) * gray\r\n        }\r\n      }\r\n      \r\n      const mag = Math.hypot(gx, gy)\r\n      if (mag > 20) {\r\n        edges.push({ x, y, mag })\r\n      }\r\n    }\r\n  }\r\n\r\n  if (edges.length === 0) return null\r\n\r\n  // Step 2: For each potential center, score how many rings we can explain\r\n  let bestCenter = null\r\n  let bestScore = 0\r\n\r\n  // Sample potential centers\r\n  for (let cy = h * 0.3; cy < h * 0.7; cy += 10) {\r\n    for (let cx = w * 0.3; cx < w * 0.7; cx += 10) {\r\n      // For this center, find rings at expected radii\r\n      let ringCount = 0\r\n      let ringStrength = 0\r\n\r\n      // Test for rings at known pixel radii (assuming double radius ~150px)\r\n      const testRadii = [15, 30, 150, 162, 180, 205]\r\n      \r\n      for (const testR of testRadii) {\r\n        let strength = 0\r\n        let pixelCount = 0\r\n\r\n        // Count edge pixels near this radius\r\n        for (const edge of edges) {\r\n          const dist = Math.hypot(edge.x - cx, edge.y - cy)\r\n          if (Math.abs(dist - testR) < 3) {\r\n            strength += edge.mag\r\n            pixelCount++\r\n          }\r\n        }\r\n\r\n        if (pixelCount > 10 && strength > 500) {\r\n          ringCount++\r\n          ringStrength += strength\r\n        }\r\n      }\r\n\r\n      // Want at least 4 strong rings\r\n      if (ringCount >= 4 && ringStrength > bestScore) {\r\n        bestScore = ringStrength\r\n        bestCenter = { cx, cy }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!bestCenter) return null\r\n\r\n  // Step 3: Refine the center position and find double radius\r\n  const refinedCx = bestCenter.cx\r\n  const refinedCy = bestCenter.cy\r\n\r\n  // Find the strongest ring near where we expect the double outer (165-190 pixels for typical image)\r\n  let doubleR = 170\r\n  let maxStrength = 0\r\n\r\n  for (let testR = 120; testR <= 250; testR += 5) {\r\n    let strength = 0\r\n    let pixelCount = 0\r\n\r\n    for (const edge of edges) {\r\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy)\r\n      if (Math.abs(dist - testR) < 2) {\r\n        strength += edge.mag\r\n        pixelCount++\r\n      }\r\n    }\r\n\r\n    if (pixelCount > 20 && strength > maxStrength) {\r\n      maxStrength = strength\r\n      doubleR = testR\r\n    }\r\n  }\r\n\r\n  // Calculate confidence based on how many proper rings we found\r\n  let confidence = 0\r\n  const scale = doubleR / BoardRadii.doubleOuter\r\n  \r\n  for (const knownR of [BoardRadii.bullInner, BoardRadii.bullOuter, BoardRadii.trebleInner, BoardRadii.trebleOuter, BoardRadii.doubleInner, BoardRadii.doubleOuter]) {\r\n    const expectedPixelR = knownR * scale\r\n    let found = false\r\n\r\n    for (const edge of edges) {\r\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy)\r\n      if (Math.abs(dist - expectedPixelR) < 3) {\r\n        found = true\r\n        confidence += 15\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  confidence = Math.min(100, confidence)\r\n\r\n  return {\r\n    cx: refinedCx,\r\n    cy: refinedCy,\r\n    r: doubleR,\r\n    confidence,\r\n  }\r\n}\r\n\r\n/**\r\n * Main board detection function\r\n * Uses direct ring detection approach\r\n */\r\nexport function detectBoard(canvas: HTMLCanvasElement): BoardDetectionResult {\r\n  try {\r\n    const w = canvas.width\r\n    const h = canvas.height\r\n    const centerX = w / 2\r\n    const centerY = h / 2\r\n\r\n    // Find dartboard rings\r\n    const detection = findDartboardRings(canvas)\r\n\r\n    if (!detection) {\r\n      return {\r\n        success: false,\r\n        cx: centerX,\r\n        cy: centerY,\r\n        bullInner: 0,\r\n        bullOuter: 0,\r\n        trebleInner: 0,\r\n        trebleOuter: 0,\r\n        doubleInner: 0,\r\n        doubleOuter: 0,\r\n        confidence: 0,\r\n        homography: null,\r\n        errorPx: null,\r\n        calibrationPoints: [],\r\n        message: 'No dartboard detected. Ensure board is clearly visible with good contrast between rings and background.',\r\n      }\r\n    }\r\n\r\n    // Scale all ring radii based on detected double radius\r\n    const scale = detection.r / BoardRadii.doubleOuter\r\n\r\n    const detected = {\r\n      cx: detection.cx,\r\n      cy: detection.cy,\r\n      bullInner: BoardRadii.bullInner * scale,\r\n      bullOuter: BoardRadii.bullOuter * scale,\r\n      trebleInner: BoardRadii.trebleInner * scale,\r\n      trebleOuter: BoardRadii.trebleOuter * scale,\r\n      doubleInner: BoardRadii.doubleInner * scale,\r\n      doubleOuter: detection.r,\r\n    }\r\n\r\n    // Generate 4 calibration points from detected rings (TOP, RIGHT, BOTTOM, LEFT of double)\r\n    const calibrationPoints: Point[] = [\r\n      { x: detected.cx, y: detected.cy - detected.doubleOuter },           // TOP\r\n      { x: detected.cx + detected.doubleOuter, y: detected.cy },           // RIGHT\r\n      { x: detected.cx, y: detected.cy + detected.doubleOuter },           // BOTTOM\r\n      { x: detected.cx - detected.doubleOuter, y: detected.cy },           // LEFT\r\n    ]\r\n\r\n    // Compute homography from these 4 points\r\n    const canonicalSrc = [\r\n      { x: 0, y: -BoardRadii.doubleOuter },\r\n      { x: BoardRadii.doubleOuter, y: 0 },\r\n      { x: 0, y: BoardRadii.doubleOuter },\r\n      { x: -BoardRadii.doubleOuter, y: 0 },\r\n    ]\r\n\r\n    let homography: Homography | null = null\r\n    let errorPx: number | null = null\r\n    let confidence = detection.confidence\r\n\r\n    try {\r\n      homography = computeHomographyDLT(canonicalSrc, calibrationPoints)\r\n      errorPx = rmsError(homography, canonicalSrc, calibrationPoints)\r\n      // Adjust confidence based on homography error\r\n      const errorConfidence = Math.max(10, Math.min(95, 100 - Math.max(0, errorPx - 1) * 10))\r\n      confidence = (confidence + errorConfidence) / 2\r\n    } catch (err) {\r\n      confidence = Math.max(40, confidence)\r\n    }\r\n\r\n    const pointsValid = calibrationPoints.every(isFinitePoint)\r\n    const homographyValid = isFiniteHomography(homography)\r\n    const success = !!homographyValid && pointsValid && confidence > 50\r\n\r\n    return {\r\n      success,\r\n      cx: detected.cx,\r\n      cy: detected.cy,\r\n      bullInner: detected.bullInner,\r\n      bullOuter: detected.bullOuter,\r\n      trebleInner: detected.trebleInner,\r\n      trebleOuter: detected.trebleOuter,\r\n      doubleInner: detected.doubleInner,\r\n      doubleOuter: detected.doubleOuter,\r\n      confidence,\r\n      homography: homographyValid ? homography : null,\r\n      errorPx: homographyValid ? errorPx : null,\r\n      calibrationPoints: pointsValid ? calibrationPoints : [],\r\n      message: !pointsValid || !homographyValid\r\n        ? '❌ Detection produced unstable calibration data. Adjust camera framing or calibrate manually.'\r\n        : confidence > 80\r\n          ? '✅ High confidence detection'\r\n          : confidence > 50\r\n            ? '⚠️ Detection found but could be better'\r\n            : '❌ Low confidence - try better lighting',\r\n    }\r\n  } catch (err) {\r\n    return {\r\n      success: false,\r\n      cx: canvas.width / 2,\r\n      cy: canvas.height / 2,\r\n      bullInner: 0,\r\n      bullOuter: 0,\r\n      trebleInner: 0,\r\n      trebleOuter: 0,\r\n      doubleInner: 0,\r\n      doubleOuter: 0,\r\n      confidence: 0,\r\n      homography: null,\r\n      errorPx: null,\r\n      calibrationPoints: [],\r\n      message: err instanceof Error ? err.message : 'Board detection failed',\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Refine detection by looking for concentric rings\r\n * This helps match detected circles to specific board rings\r\n */\r\nexport function refineRingDetection(detected: BoardDetectionResult): BoardDetectionResult {\r\n  // If detection already has good confidence, return as-is\r\n  if (detected.confidence > 70) return detected\r\n\r\n  // Otherwise try to improve by checking ring ratios\r\n  // If rings don't match expected ratios, we can flag for manual refinement\r\n  const expectedRatios = {\r\n    bullInner_to_bullOuter: BoardRadii.bullInner / BoardRadii.bullOuter,\r\n    bullOuter_to_trebleInner: BoardRadii.bullOuter / BoardRadii.trebleInner,\r\n    trebleOuter_to_doubleInner: BoardRadii.trebleOuter / BoardRadii.doubleInner,\r\n    doubleInner_to_doubleOuter: BoardRadii.doubleInner / BoardRadii.doubleOuter,\r\n  }\r\n\r\n  const actualRatios = {\r\n    bullInner_to_bullOuter: detected.bullInner / detected.bullOuter,\r\n    bullOuter_to_trebleInner: detected.bullOuter / detected.trebleInner,\r\n    trebleOuter_to_doubleInner: detected.trebleOuter / detected.doubleInner,\r\n    doubleInner_to_doubleOuter: detected.doubleInner / detected.doubleOuter,\r\n  }\r\n\r\n  // Check ratio errors\r\n  let ratioError = 0\r\n  let ratioCount = 0\r\n  for (const [key, expected] of Object.entries(expectedRatios)) {\r\n    const actual = actualRatios[key as keyof typeof actualRatios]\r\n    const error = Math.abs(actual - expected) / expected\r\n    ratioError += error\r\n    ratioCount++\r\n  }\r\n  const avgRatioError = ratioError / ratioCount\r\n\r\n  // Adjust confidence based on ratio error\r\n  const adjustedConfidence = Math.max(10, detected.confidence - avgRatioError * 100)\r\n\r\n  return {\r\n    ...detected,\r\n    confidence: adjustedConfidence,\r\n    message: adjustedConfidence > 70 ? '✅ High confidence detection' : adjustedConfidence > 50 ? '⚠️ Rings detected but ratios off - may need refinement' : '❌ Low confidence - try repositioning camera',\r\n  }\r\n}\r\n","import { detectBoard, refineRingDetection } from '../utils/boardDetection'\r\n\r\n// Worker receives an ImageBitmap and runs the detection on an OffscreenCanvas.\r\nself.onmessage = async (ev: MessageEvent) => {\r\n  try {\r\n    const { type, bitmap } = ev.data || {}\r\n    if (type !== 'detect' || !bitmap) return\r\n    // Create offscreen canvas of same size as bitmap\r\n    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height)\r\n    const ctx = canvas.getContext('2d')\r\n    if (!ctx) {\r\n      postMessage({ error: 'OffscreenCanvas context unavailable' })\r\n      return\r\n    }\r\n    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height)\r\n    // Run detection\r\n    let detection = detectBoard(canvas as any as HTMLCanvasElement)\r\n    detection = refineRingDetection(detection as any)\r\n    // Transfer results back (serializable fields only)\r\n    postMessage({ type: 'result', detection })\r\n  } catch (err) {\r\n    postMessage({ error: (err && err.message) || 'Worker error' })\r\n  }\r\n}\r\n\r\nexport {}\r\n"],"names":["BoardRadii","applyHomography","H","p","x","y","w","nx","ny","computeHomographyDLT","src","dst","A","B","k","X","Y","h","solveLeastSquares","b","m","n","AtA","Atb","r","i","j","gaussianSolve","M","v","row","maxRow","tmp","f","c","s","rmsError","e2","dx","dy","isFinitePoint","isFiniteHomography","findDartboardRings","canvas","ctx","data","edges","gx","gy","pidx","gray","mag","bestCenter","bestScore","cy","cx","ringCount","ringStrength","testRadii","testR","strength","pixelCount","edge","dist","refinedCx","refinedCy","doubleR","maxStrength","confidence","scale","knownR","expectedPixelR","detectBoard","centerX","centerY","detection","detected","calibrationPoints","canonicalSrc","homography","errorPx","errorConfidence","pointsValid","homographyValid","err","refineRingDetection","expectedRatios","actualRatios","ratioError","ratioCount","key","expected","actual","error","avgRatioError","adjustedConfidence","ev","type","bitmap"],"mappings":"yBAaO,MAAMA,EAAa,CACzB,UAAW,KACX,UAAW,KACX,YAAa,GACb,YAAa,IACb,YAAa,IACb,YAAa,GACd,EAiBO,SAASC,EAAgBC,EAAeC,EAAiB,CAC/D,MAAMC,EAAID,EAAE,EAAGE,EAAIF,EAAE,EACfG,EAAIJ,EAAE,CAAC,EAAIE,EAAIF,EAAE,CAAC,EAAIG,EAAIH,EAAE,CAAC,EAC7BK,GAAML,EAAE,CAAC,EAAIE,EAAIF,EAAE,CAAC,EAAIG,EAAIH,EAAE,CAAC,GAAKI,EACpCE,GAAMN,EAAE,CAAC,EAAIE,EAAIF,EAAE,CAAC,EAAIG,EAAIH,EAAE,CAAC,GAAKI,EAC1C,MAAO,CAAE,EAAGC,EAAI,EAAGC,CAAA,CACpB,CAsCO,SAASC,EAAqBC,EAAcC,EAA0B,CAC5E,GAAID,EAAI,OAAS,GAAKC,EAAI,OAAS,EAAG,MAAM,IAAI,MAAM,iCAAiC,EACvF,GAAID,EAAI,SAAWC,EAAI,OAAQ,MAAM,IAAI,MAAM,wCAAwC,EAEvF,MAAMC,EAAgB,CAAA,EAChBC,EAAc,CAAA,EACpB,QAASC,EAAI,EAAGA,EAAIJ,EAAI,OAAQI,IAAK,CACpC,KAAM,CAAE,EAAGC,EAAG,EAAGC,CAAA,EAAMN,EAAII,CAAC,EACtB,CAAE,EAAAV,EAAM,EAAAC,GAASM,EAAIG,CAAC,EAK5BF,EAAE,KAAK,CAACG,EAAGC,EAAG,EAAG,EAAG,EAAG,EAAG,CAACZ,EAAIW,EAAG,CAACX,EAAIY,CAAC,CAAC,EACzCH,EAAE,KAAKT,CAAC,EACRQ,EAAE,KAAK,CAAC,EAAG,EAAG,EAAGG,EAAGC,EAAG,EAAG,CAACX,EAAIU,EAAG,CAACV,EAAIW,CAAC,CAAC,EACzCH,EAAE,KAAKR,CAAC,CACT,CACA,MAAMY,EAAIC,EAAkBN,EAAGC,CAAC,EAEhC,MADsB,CAACI,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAG,CAAC,CAEzE,CAGA,SAASC,EAAkBN,EAAeO,EAAuB,CAEhE,MAAMC,EAAIR,EAAE,OAAQS,EAAIT,EAAE,CAAC,EAAE,OACvBU,EAAkB,MAAM,KAAK,CAAE,OAAQD,CAAA,EAAK,IAAM,IAAI,MAAMA,CAAC,EAAE,KAAK,CAAC,CAAC,EACtEE,EAAgB,IAAI,MAAMF,CAAC,EAAE,KAAK,CAAC,EACzC,QAASG,EAAI,EAAGA,EAAIJ,EAAGI,IACtB,QAASC,EAAI,EAAGA,EAAIJ,EAAGI,IAAK,CAC3BF,EAAIE,CAAC,GAAKb,EAAEY,CAAC,EAAEC,CAAC,EAAIN,EAAEK,CAAC,EACvB,QAASE,EAAI,EAAGA,EAAIL,EAAGK,IACtBJ,EAAIG,CAAC,EAAEC,CAAC,GAAKd,EAAEY,CAAC,EAAEC,CAAC,EAAIb,EAAEY,CAAC,EAAEE,CAAC,CAE/B,CAED,OAAOC,EAAcL,EAAKC,CAAG,CAC9B,CAEA,SAASI,EAAcC,EAAeC,EAAuB,CAC5D,MAAMR,EAAIQ,EAAE,OAENjB,EAAIgB,EAAE,IAAI,CAACE,EAAKL,IAAMK,EAAI,OAAO,CAACD,EAAEJ,CAAC,CAAC,CAAC,CAAC,EAC9C,QAASA,EAAI,EAAGA,EAAIJ,EAAGI,IAAK,CAE3B,IAAIM,EAASN,EACb,QAASD,EAAIC,EAAI,EAAGD,EAAIH,EAAGG,IACtB,KAAK,IAAIZ,EAAEY,CAAC,EAAEC,CAAC,CAAC,EAAI,KAAK,IAAIb,EAAEmB,CAAM,EAAEN,CAAC,CAAC,IAAGM,EAASP,GAE1D,GAAI,KAAK,IAAIZ,EAAEmB,CAAM,EAAEN,CAAC,CAAC,EAAI,MAAO,MAAM,IAAI,MAAM,iBAAiB,EACrE,GAAIM,IAAWN,EAAG,CACjB,MAAMO,EAAMpB,EAAEa,CAAC,EAAGb,EAAEa,CAAC,EAAIb,EAAEmB,CAAM,EAAGnB,EAAEmB,CAAM,EAAIC,CACjD,CAEA,QAASR,EAAIC,EAAI,EAAGD,EAAIH,EAAGG,IAAK,CAC/B,MAAMS,EAAIrB,EAAEY,CAAC,EAAEC,CAAC,EAAIb,EAAEa,CAAC,EAAEA,CAAC,EAC1B,QAASS,EAAIT,EAAGS,GAAKb,EAAGa,IAAKtB,EAAEY,CAAC,EAAEU,CAAC,GAAKD,EAAIrB,EAAEa,CAAC,EAAES,CAAC,CACnD,CACD,CAEA,MAAM9B,EAAI,IAAI,MAAMiB,CAAC,EAAE,KAAK,CAAC,EAC7B,QAASI,EAAIJ,EAAI,EAAGI,GAAK,EAAGA,IAAK,CAChC,IAAIU,EAAIvB,EAAEa,CAAC,EAAEJ,CAAC,EACd,QAASa,EAAIT,EAAI,EAAGS,EAAIb,EAAGa,IAAKC,GAAKvB,EAAEa,CAAC,EAAES,CAAC,EAAI9B,EAAE8B,CAAC,EAClD9B,EAAEqB,CAAC,EAAIU,EAAIvB,EAAEa,CAAC,EAAEA,CAAC,CAClB,CACA,OAAOrB,CACR,CA+BO,SAASgC,EAASlC,EAAeQ,EAAcC,EAAsB,CAC3E,IAAI0B,EAAK,EACT,QAASZ,EAAI,EAAGA,EAAIf,EAAI,OAAQe,IAAK,CACpC,MAAMtB,EAAIF,EAAgBC,EAAGQ,EAAIe,CAAC,CAAC,EAC7Ba,EAAKnC,EAAE,EAAIQ,EAAIc,CAAC,EAAE,EAClBc,EAAKpC,EAAE,EAAIQ,EAAIc,CAAC,EAAE,EACxBY,GAAMC,EAAKA,EAAKC,EAAKA,CACtB,CACA,OAAO,KAAK,KAAKF,EAAK3B,EAAI,MAAM,CACjC,CChLA,MAAM8B,EAAiBrC,GAAqC,CAAC,CAACA,GAAK,OAAO,SAASA,EAAE,CAAC,GAAK,OAAO,SAASA,EAAE,CAAC,EACxGsC,EAAsBvC,GAAsD,MAAM,QAAQA,CAAC,GAAKA,EAAE,SAAW,GAAKA,EAAE,MAAM,OAAO,QAAQ,EAuB/I,SAASwC,EAAmBC,EAA6F,CACvH,MAAMC,EAAMD,EAAO,WAAW,IAAI,EAClC,GAAI,CAACC,EAAK,OAAO,KAEjB,MAAMtC,EAAIqC,EAAO,MACX1B,EAAI0B,EAAO,OAEXE,EADYD,EAAI,aAAa,EAAG,EAAGtC,EAAGW,CAAC,EACtB,KAGjB6B,EAAsD,CAAA,EAE5D,QAASzC,EAAI,EAAGA,EAAIY,EAAI,EAAGZ,IACzB,QAASD,EAAI,EAAGA,EAAIE,EAAI,EAAGF,IAAK,CAI9B,IAAI2C,EAAK,EAAGC,EAAK,EACjB,QAAST,EAAK,GAAIA,GAAM,EAAGA,IACzB,QAASD,EAAK,GAAIA,GAAM,EAAGA,IAAM,CAC/B,MAAMW,IAAS5C,EAAIkC,GAAMjC,GAAKF,EAAIkC,IAAO,EACnCY,EAAOL,EAAKI,CAAI,EAAI,KAAQJ,EAAKI,EAAO,CAAC,EAAI,KAAQJ,EAAKI,EAAO,CAAC,EAAI,KACxEX,IAAO,IAAGS,IAAOT,EAAK,EAAI,EAAI,IAAMY,GACpCX,IAAO,IAAGS,IAAOT,EAAK,EAAI,EAAI,IAAMW,EAC1C,CAGF,MAAMC,EAAM,KAAK,MAAMJ,EAAIC,CAAE,EACzBG,EAAM,IACRL,EAAM,KAAK,CAAE,EAAA1C,EAAG,EAAAC,EAAG,IAAA8C,EAAK,CAE5B,CAGF,GAAIL,EAAM,SAAW,EAAG,OAAO,KAG/B,IAAIM,EAAa,KACbC,EAAY,EAGhB,QAASC,EAAKrC,EAAI,GAAKqC,EAAKrC,EAAI,GAAKqC,GAAM,GACzC,QAASC,EAAKjD,EAAI,GAAKiD,EAAKjD,EAAI,GAAKiD,GAAM,GAAI,CAE7C,IAAIC,EAAY,EACZC,EAAe,EAGnB,MAAMC,EAAY,CAAC,GAAI,GAAI,IAAK,IAAK,IAAK,GAAG,EAE7C,UAAWC,KAASD,EAAW,CAC7B,IAAIE,EAAW,EACXC,EAAa,EAGjB,UAAWC,KAAQhB,EAAO,CACxB,MAAMiB,EAAO,KAAK,MAAMD,EAAK,EAAIP,EAAIO,EAAK,EAAIR,CAAE,EAC5C,KAAK,IAAIS,EAAOJ,CAAK,EAAI,IAC3BC,GAAYE,EAAK,IACjBD,IAEJ,CAEIA,EAAa,IAAMD,EAAW,MAChCJ,IACAC,GAAgBG,EAEpB,CAGIJ,GAAa,GAAKC,EAAeJ,IACnCA,EAAYI,EACZL,EAAa,CAAE,GAAAG,EAAI,GAAAD,CAAA,EAEvB,CAGF,GAAI,CAACF,EAAY,OAAO,KAGxB,MAAMY,EAAYZ,EAAW,GACvBa,EAAYb,EAAW,GAG7B,IAAIc,EAAU,IACVC,EAAc,EAElB,QAASR,EAAQ,IAAKA,GAAS,IAAKA,GAAS,EAAG,CAC9C,IAAIC,EAAW,EACXC,EAAa,EAEjB,UAAWC,KAAQhB,EAAO,CACxB,MAAMiB,EAAO,KAAK,MAAMD,EAAK,EAAIE,EAAWF,EAAK,EAAIG,CAAS,EAC1D,KAAK,IAAIF,EAAOJ,CAAK,EAAI,IAC3BC,GAAYE,EAAK,IACjBD,IAEJ,CAEIA,EAAa,IAAMD,EAAWO,IAChCA,EAAcP,EACdM,EAAUP,EAEd,CAGA,IAAIS,EAAa,EACjB,MAAMC,EAAQH,EAAUlE,EAAW,YAEnC,UAAWsE,IAAU,CAACtE,EAAW,UAAWA,EAAW,UAAWA,EAAW,YAAaA,EAAW,YAAaA,EAAW,YAAaA,EAAW,WAAW,EAAG,CACjK,MAAMuE,EAAiBD,EAASD,EAGhC,UAAWP,KAAQhB,EAAO,CACxB,MAAMiB,EAAO,KAAK,MAAMD,EAAK,EAAIE,EAAWF,EAAK,EAAIG,CAAS,EAC9D,GAAI,KAAK,IAAIF,EAAOQ,CAAc,EAAI,EAAG,CAEvCH,GAAc,GACd,KACF,CACF,CACF,CAEA,OAAAA,EAAa,KAAK,IAAI,IAAKA,CAAU,EAE9B,CACL,GAAIJ,EACJ,GAAIC,EACJ,EAAGC,EACH,WAAAE,CAAA,CAEJ,CAMO,SAASI,EAAY7B,EAAiD,CAC3E,GAAI,CACF,MAAMrC,EAAIqC,EAAO,MACX1B,EAAI0B,EAAO,OACX8B,EAAUnE,EAAI,EACdoE,EAAUzD,EAAI,EAGd0D,EAAYjC,EAAmBC,CAAM,EAE3C,GAAI,CAACgC,EACH,MAAO,CACL,QAAS,GACT,GAAIF,EACJ,GAAIC,EACJ,UAAW,EACX,UAAW,EACX,YAAa,EACb,YAAa,EACb,YAAa,EACb,YAAa,EACb,WAAY,EACZ,WAAY,KACZ,QAAS,KACT,kBAAmB,CAAA,EACnB,QAAS,yGAAA,EAKb,MAAML,EAAQM,EAAU,EAAI3E,EAAW,YAEjC4E,EAAW,CACf,GAAID,EAAU,GACd,GAAIA,EAAU,GACd,UAAW3E,EAAW,UAAYqE,EAClC,UAAWrE,EAAW,UAAYqE,EAClC,YAAarE,EAAW,YAAcqE,EACtC,YAAarE,EAAW,YAAcqE,EACtC,YAAarE,EAAW,YAAcqE,EACtC,YAAaM,EAAU,CAAA,EAInBE,EAA6B,CACjC,CAAE,EAAGD,EAAS,GAAI,EAAGA,EAAS,GAAKA,EAAS,WAAA,EAC5C,CAAE,EAAGA,EAAS,GAAKA,EAAS,YAAa,EAAGA,EAAS,EAAA,EACrD,CAAE,EAAGA,EAAS,GAAI,EAAGA,EAAS,GAAKA,EAAS,WAAA,EAC5C,CAAE,EAAGA,EAAS,GAAKA,EAAS,YAAa,EAAGA,EAAS,EAAA,CAAG,EAIpDE,EAAe,CACnB,CAAE,EAAG,EAAG,EAAG,CAAC9E,EAAW,WAAA,EACvB,CAAE,EAAGA,EAAW,YAAa,EAAG,CAAA,EAChC,CAAE,EAAG,EAAG,EAAGA,EAAW,WAAA,EACtB,CAAE,EAAG,CAACA,EAAW,YAAa,EAAG,CAAA,CAAE,EAGrC,IAAI+E,EAAgC,KAChCC,EAAyB,KACzBZ,EAAaO,EAAU,WAE3B,GAAI,CACFI,EAAatE,EAAqBqE,EAAcD,CAAiB,EACjEG,EAAU5C,EAAS2C,EAAYD,EAAcD,CAAiB,EAE9D,MAAMI,EAAkB,KAAK,IAAI,GAAI,KAAK,IAAI,GAAI,IAAM,KAAK,IAAI,EAAGD,EAAU,CAAC,EAAI,EAAE,CAAC,EACtFZ,GAAcA,EAAaa,GAAmB,CAChD,MAAc,CACZb,EAAa,KAAK,IAAI,GAAIA,CAAU,CACtC,CAEA,MAAMc,EAAcL,EAAkB,MAAMrC,CAAa,EACnD2C,EAAkB1C,EAAmBsC,CAAU,EAGrD,MAAO,CACL,QAHc,CAAC,CAACI,GAAmBD,GAAed,EAAa,GAI/D,GAAIQ,EAAS,GACb,GAAIA,EAAS,GACb,UAAWA,EAAS,UACpB,UAAWA,EAAS,UACpB,YAAaA,EAAS,YACtB,YAAaA,EAAS,YACtB,YAAaA,EAAS,YACtB,YAAaA,EAAS,YACtB,WAAAR,EACA,WAAYe,EAAkBJ,EAAa,KAC3C,QAASI,EAAkBH,EAAU,KACrC,kBAAmBE,EAAcL,EAAoB,CAAA,EACrD,QAAS,CAACK,GAAe,CAACC,EACtB,+FACAf,EAAa,GACX,8BACAA,EAAa,GACX,yCACA,wCAAA,CAEZ,OAASgB,EAAK,CACZ,MAAO,CACL,QAAS,GACT,GAAIzC,EAAO,MAAQ,EACnB,GAAIA,EAAO,OAAS,EACpB,UAAW,EACX,UAAW,EACX,YAAa,EACb,YAAa,EACb,YAAa,EACb,YAAa,EACb,WAAY,EACZ,WAAY,KACZ,QAAS,KACT,kBAAmB,CAAA,EACnB,QAASyC,aAAe,MAAQA,EAAI,QAAU,wBAAA,CAElD,CACF,CAMO,SAASC,EAAoBT,EAAsD,CAExF,GAAIA,EAAS,WAAa,GAAI,OAAOA,EAIrC,MAAMU,EAAiB,CACrB,uBAAwBtF,EAAW,UAAYA,EAAW,UAC1D,yBAA0BA,EAAW,UAAYA,EAAW,YAC5D,2BAA4BA,EAAW,YAAcA,EAAW,YAChE,2BAA4BA,EAAW,YAAcA,EAAW,WAAA,EAG5DuF,EAAe,CACnB,uBAAwBX,EAAS,UAAYA,EAAS,UACtD,yBAA0BA,EAAS,UAAYA,EAAS,YACxD,2BAA4BA,EAAS,YAAcA,EAAS,YAC5D,2BAA4BA,EAAS,YAAcA,EAAS,WAAA,EAI9D,IAAIY,EAAa,EACbC,EAAa,EACjB,SAAW,CAACC,EAAKC,CAAQ,IAAK,OAAO,QAAQL,CAAc,EAAG,CAC5D,MAAMM,EAASL,EAAaG,CAAgC,EACtDG,EAAQ,KAAK,IAAID,EAASD,CAAQ,EAAIA,EAC5CH,GAAcK,EACdJ,GACF,CACA,MAAMK,EAAgBN,EAAaC,EAG7BM,EAAqB,KAAK,IAAI,GAAInB,EAAS,WAAakB,EAAgB,GAAG,EAEjF,MAAO,CACL,GAAGlB,EACH,WAAYmB,EACZ,QAASA,EAAqB,GAAK,8BAAgCA,EAAqB,GAAK,yDAA2D,6CAAA,CAE5J,CC7UA,KAAK,UAAY,MAAOC,GAAqB,CAC3C,GAAI,CACF,KAAM,CAAE,KAAAC,EAAM,OAAAC,CAAA,EAAWF,EAAG,MAAQ,CAAA,EACpC,GAAIC,IAAS,UAAY,CAACC,EAAQ,OAElC,MAAMvD,EAAS,IAAI,gBAAgBuD,EAAO,MAAOA,EAAO,MAAM,EACxDtD,EAAMD,EAAO,WAAW,IAAI,EAClC,GAAI,CAACC,EAAK,CACR,YAAY,CAAE,MAAO,sCAAuC,EAC5D,MACF,CACAA,EAAI,UAAUsD,EAAQ,EAAG,EAAGvD,EAAO,MAAOA,EAAO,MAAM,EAEvD,IAAIgC,EAAYH,EAAY7B,CAAkC,EAC9DgC,EAAYU,EAAoBV,CAAgB,EAEhD,YAAY,CAAE,KAAM,SAAU,UAAAA,CAAA,CAAW,CAC3C,OAASS,EAAK,CACZ,YAAY,CAAE,MAAQA,GAAOA,EAAI,SAAY,eAAgB,CAC/D,CACF"}