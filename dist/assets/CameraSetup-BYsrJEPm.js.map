{"version":3,"file":"CameraSetup-BYsrJEPm.js","sources":["../../src/utils/markerCalibration.ts","../../src/utils/boardDetection.ts","../../src/utils/networkDevices.ts","../../node_modules/qrcode/lib/can-promise.js","../../node_modules/qrcode/lib/core/utils.js","../../node_modules/qrcode/lib/core/error-correction-level.js","../../node_modules/qrcode/lib/core/bit-buffer.js","../../node_modules/qrcode/lib/core/bit-matrix.js","../../node_modules/qrcode/lib/core/alignment-pattern.js","../../node_modules/qrcode/lib/core/finder-pattern.js","../../node_modules/qrcode/lib/core/mask-pattern.js","../../node_modules/qrcode/lib/core/error-correction-code.js","../../node_modules/qrcode/lib/core/galois-field.js","../../node_modules/qrcode/lib/core/polynomial.js","../../node_modules/qrcode/lib/core/reed-solomon-encoder.js","../../node_modules/qrcode/lib/core/version-check.js","../../node_modules/qrcode/lib/core/regex.js","../../node_modules/qrcode/lib/core/mode.js","../../node_modules/qrcode/lib/core/version.js","../../node_modules/qrcode/lib/core/format-info.js","../../node_modules/qrcode/lib/core/numeric-data.js","../../node_modules/qrcode/lib/core/alphanumeric-data.js","../../node_modules/qrcode/lib/core/byte-data.js","../../node_modules/qrcode/lib/core/kanji-data.js","../../node_modules/dijkstrajs/dijkstra.js","../../node_modules/qrcode/lib/core/segments.js","../../node_modules/qrcode/lib/core/qrcode.js","../../node_modules/qrcode/lib/renderer/utils.js","../../node_modules/qrcode/lib/renderer/canvas.js","../../node_modules/qrcode/lib/renderer/svg-tag.js","../../node_modules/qrcode/lib/browser.js","../../src/utils/qr.ts","../../src/components/Calibrator.tsx","../../src/components/CameraSetup.tsx"],"sourcesContent":["// Minimal marker calibration utilities retained for test compatibility\n// Provides tiny helpers to convert marker IDs to 7x7 bit-grid matrices\n// and simple canonical marker order + targets used by the calibrator tests.\n\nexport const MARKER_ORDER = [\"top\", \"right\", \"bottom\", \"left\", \"bull\"] as const;\n\n// Provide deterministic 10-bit IDs for the five targets. These are arbitrary\n// but stable values used only in tests and calibration placeholder logic.\nexport const MARKER_TARGETS: Record<string, number> &\n  Record<(typeof MARKER_ORDER)[number], number> = {\n  top: 0b0001100011, // 195\n  right: 0b0010011010, // 154\n  bottom: 0b0011110001, // 241\n  left: 0b0001010101, // 85\n  bull: 0b0000000000, // 0 - bull uses all zeros\n};\n\n// Convert the 10-bit id into a 7x7 grid where the outer border is zeros\n// and the central 5x5 encodes the id using columns 2 and 4 as data columns.\nexport function markerIdToMatrix(id: number): number[][] {\n  const grid: number[][] = Array.from({ length: 7 }, () =>\n    Array.from({ length: 7 }, () => 0),\n  );\n  // Extract 10 bits MSB -> LSB\n  const bits: number[] = [];\n  for (let i = 9; i >= 0; i--) {\n    bits.push((id >> i) & 1);\n  }\n  // Fill into rows 1..5 columns 2 and 4\n  for (let r = 0; r < 5; r++) {\n    const rowIdx = r + 1;\n    const bitA = bits[2 * r] ?? 0; // MSB first\n    const bitB = bits[2 * r + 1] ?? 0;\n    grid[rowIdx][2] = bitA;\n    grid[rowIdx][4] = bitB;\n  }\n  return grid;\n}\n\nexport default {};\n\nexport type MarkerDetection = {\n  success: boolean;\n  homography: any | null;\n  points: Array<{ x: number; y: number }>;\n  errorPx?: number | null;\n  markerSize?: number;\n  markersFound: Array<{ id: number; x: number; y: number }>;\n  missing: string[];\n  message: string;\n};\n\nexport function detectMarkersFromCanvas(_canvas: any): MarkerDetection {\n  return {\n    success: false,\n    homography: null,\n    points: [],\n    errorPx: null,\n    markersFound: [],\n    missing: [],\n    message: \"Marker detection not available\",\n  };\n}\n","/**\n * Advanced Dartboard Auto-Calibration\n *\n * Detects dartboard features automatically without markers or manual clicking:\n * 1. Detects bull (inner & outer rings) using circle detection\n * 2. Detects treble and double rings using edge/circle detection\n * 3. Computes board center and orientation\n * 4. Generates calibration points from detected rings\n * 5. Computes homography without user interaction\n */\n\nimport {\n  BoardRadii,\n  canonicalRimTargets,\n  computeHomographyDLT,\n  applyHomography,\n  sampleRing,\n  translateHomography,\n  rotateHomography,\n  scaleHomography,\n  rmsError,\n  ransacHomography,\n  type Homography,\n  type Point,\n} from \"./vision.js\";\nimport { getGlobalCalibrationConfidence } from \"./gameCalibrationRequirements.js\";\nimport { useUserSettings } from \"../store/userSettings.js\";\n\nconst isFinitePoint = (p: Point | undefined): p is Point =>\n  !!p && Number.isFinite(p.x) && Number.isFinite(p.y);\nconst isFiniteHomography = (\n  H: Homography | null | undefined,\n): H is Homography =>\n  Array.isArray(H) && H.length === 9 && H.every(Number.isFinite);\n\nexport interface BoardDetectionResult {\n  success: boolean;\n  cx: number; // Board center X in image\n  cy: number; // Board center Y in image\n  bullInner: number; // Detected inner bull radius (pixels)\n  bullOuter: number; // Detected outer bull radius (pixels)\n  trebleInner: number; // Detected treble inner radius (pixels)\n  trebleOuter: number; // Detected treble outer radius (pixels)\n  doubleInner: number; // Detected double inner radius (pixels)\n  doubleOuter: number; // Detected double outer radius (pixels)\n  confidence: number; // 0-100, quality of detection\n  homography: Homography | null;\n  errorPx: number | null;\n  calibrationPoints: Point[];\n  theta?: number; // detected orientation in radians (0 = canonical top)\n  message?: string;\n}\n\n/**\n * Detect dartboard using radial edge detection\n * Simpler, more robust approach:\n * 1. Find the center using Hough voting\n * 2. Scan radially from center to find ring boundaries (black/white transitions)\n * 3. Identify double ring (outermost playable ring) by looking for the characteristic radius\n */\nfunction findDartboardRings(\n  canvas: HTMLCanvasElement,\n  centerHint?: { x: number; y: number },\n): {\n  cx: number;\n  cy: number;\n  r: number;\n  confidence: number;\n  ringCount?: number;\n  ringStrength?: number;\n  detectedRings?: number[];\n} | null {\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n  if (!ctx) return null;\n\n  const w = canvas.width;\n  const h = canvas.height;\n\n  // 1. Downsample for Center Detection (Gradient Voting)\n  // Use a slightly higher resolution than before for better accuracy\n  const mapW = 160;\n  const scale = mapW / w;\n  const mapH = Math.floor(h * scale);\n\n  const workCanvas = new OffscreenCanvas(mapW, mapH);\n  const workCtx = workCanvas.getContext(\"2d\", { willReadFrequently: true });\n  if (!workCtx) return null;\n\n  workCtx.drawImage(canvas, 0, 0, mapW, mapH);\n  const imageData = workCtx.getImageData(0, 0, mapW, mapH);\n  const data = imageData.data;\n\n  // 2. Compute Gradients & Accumulator\n  const accumulator = new Float32Array(mapW * mapH);\n  const magThreshold = 8; // Sweet spot sensitivity (v2.1 level - was working)\n\n  // Simple Central Difference Gradients\n  for (let y = 1; y < mapH - 1; y++) {\n    for (let x = 1; x < mapW - 1; x++) {\n      const i = (y * mapW + x) * 4;\n\n      // Neighbors\n      const iL = i - 4;\n      const iR = i + 4;\n      const iU = i - mapW * 4;\n      const iD = i + mapW * 4;\n\n      // Luminance\n      const lumL =\n        data[iL] * 0.299 + data[iL + 1] * 0.587 + data[iL + 2] * 0.114;\n      const lumR =\n        data[iR] * 0.299 + data[iR + 1] * 0.587 + data[iR + 2] * 0.114;\n      const lumU =\n        data[iU] * 0.299 + data[iU + 1] * 0.587 + data[iU + 2] * 0.114;\n      const lumD =\n        data[iD] * 0.299 + data[iD + 1] * 0.587 + data[iD + 2] * 0.114;\n\n      const dx = lumR - lumL;\n      const dy = lumD - lumU;\n      const mag = Math.sqrt(dx * dx + dy * dy);\n\n      if (mag > magThreshold) {\n        // Normalize direction\n        const ux = dx / mag;\n        const uy = dy / mag;\n\n        // Vote along the gradient line (perpendicular to edge)\n        // We vote in both directions because we don't know if it's inner or outer edge of a ring\n        // Expanded range: 3% to 60% of width to handle boards at different distances\n        const minR = mapW * 0.03;\n        const maxR = mapW * 0.6;\n\n        // Optimization: Step by 1 pixel\n        for (let r = minR; r < maxR; r += 1) {\n          // Direction 1 (+ gradient)\n          const v1x = Math.round(x + ux * r);\n          const v1y = Math.round(y + uy * r);\n          if (v1x >= 0 && v1x < mapW && v1y >= 0 && v1y < mapH) {\n            accumulator[v1y * mapW + v1x]++;\n          }\n\n          // Direction 2 (- gradient)\n          const v2x = Math.round(x - ux * r);\n          const v2y = Math.round(y - uy * r);\n          if (v2x >= 0 && v2x < mapW && v2y >= 0 && v2y < mapH) {\n            accumulator[v2y * mapW + v2x]++;\n          }\n        }\n      }\n    }\n  }\n\n  // 3. Find Peak in Accumulator\n  // Apply a small blur to the accumulator to smooth noise and aggregate votes\n  const smoothedAcc = new Float32Array(mapW * mapH);\n  const blurR = 2;\n  for (let y = blurR; y < mapH - blurR; y++) {\n    for (let x = blurR; x < mapW - blurR; x++) {\n      let sum = 0;\n      for (let dy = -blurR; dy <= blurR; dy++) {\n        for (let dx = -blurR; dx <= blurR; dx++) {\n          sum += accumulator[(y + dy) * mapW + (x + dx)];\n        }\n      }\n      smoothedAcc[y * mapW + x] = sum;\n    }\n  }\n\n  let maxVotes = 0;\n  let peakX = mapW / 2;\n  let peakY = mapH / 2;\n\n  // Ignore borders - but smaller border to detect boards at edges\n  const border = 5;\n  for (let y = border; y < mapH - border; y++) {\n    for (let x = border; x < mapW - border; x++) {\n      const votes = smoothedAcc[y * mapW + x];\n      if (votes > maxVotes) {\n        maxVotes = votes;\n        peakX = x;\n        peakY = y;\n      }\n    }\n  }\n\n  // Scale peak back to full size\n  let roughCx = peakX / scale;\n  let roughCy = peakY / scale;\n  // If a center hint is provided (e.g., a one-click bull), bias the rough center toward it\n  if (\n    centerHint &&\n    Number.isFinite(centerHint.x) &&\n    Number.isFinite(centerHint.y)\n  ) {\n    // Blend 70% hint, 30% voted peak to keep robustness while honoring user hint\n    roughCx = 0.7 * centerHint.x + 0.3 * roughCx;\n    roughCy = 0.7 * centerHint.y + 0.3 * roughCy;\n  }\n\n  console.log(\n    `[findDartboardRings] Voting Peak: (${Math.round(roughCx)}, ${Math.round(roughCy)}) Votes=${maxVotes}`,\n  );\n\n  // 5. Structural Lock (Double + Treble)\n  // We use a \"Radial Gradient\" search to ignore the spider/segment wires.\n  // Segment wires have gradients perpendicular to the radius (tangential).\n  // Rings have gradients parallel to the radius (radial).\n  const scanW = 400; // Increased resolution for better wire separation\n  const scanScale = scanW / w;\n  const scanH = Math.floor(h * scanScale);\n\n  const scanCanvas = new OffscreenCanvas(scanW, scanH);\n  const scanCtx = scanCanvas.getContext(\"2d\");\n  if (!scanCtx) return null;\n\n  scanCtx.drawImage(canvas, 0, 0, scanW, scanH);\n  const scanData = scanCtx.getImageData(0, 0, scanW, scanH).data;\n\n  // NOTE: roughCxScaled/roughCyScaled were used in an earlier debug path; keep\n  // them removed to avoid unused-vars warnings.\n\n  // Pre-compute gradients for scan image\n  const scanDx = new Float32Array(scanW * scanH);\n  const scanDy = new Float32Array(scanW * scanH);\n\n  for (let y = 1; y < scanH - 1; y++) {\n    for (let x = 1; x < scanW - 1; x++) {\n      const i = (y * scanW + x) * 4;\n\n      // Luminance\n      const _lum =\n        scanData[i] * 0.299 + scanData[i + 1] * 0.587 + scanData[i + 2] * 0.114;\n\n      // Neighbors\n      const iL = i - 4;\n      const iR = i + 4;\n      const iU = i - scanW * 4;\n      const iD = i + scanW * 4;\n\n      const lumL =\n        scanData[iL] * 0.299 +\n        scanData[iL + 1] * 0.587 +\n        scanData[iL + 2] * 0.114;\n      const lumR =\n        scanData[iR] * 0.299 +\n        scanData[iR + 1] * 0.587 +\n        scanData[iR + 2] * 0.114;\n      const lumU =\n        scanData[iU] * 0.299 +\n        scanData[iU + 1] * 0.587 +\n        scanData[iU + 2] * 0.114;\n      const lumD =\n        scanData[iD] * 0.299 +\n        scanData[iD + 1] * 0.587 +\n        scanData[iD + 2] * 0.114;\n\n      // Central Difference\n      const dx = lumR - lumL;\n      const dy = lumD - lumU;\n\n      scanDx[y * scanW + x] = dx;\n      scanDy[y * scanW + x] = dy;\n    }\n  }\n\n  // 4. Radial scan from center to find rings\n  // The double ring has a characteristic width (~8mm = ~8-12 pixels in typical images)\n  // and should be the outermost ring with strong radial gradients\n  const fullData = ctx.getImageData(0, 0, w, h).data;\n\n  const lum = (x: number, y: number) => {\n    const ix = Math.max(0, Math.min(w - 1, Math.round(x)));\n    const iy = Math.max(0, Math.min(h - 1, Math.round(y)));\n    const idx = (iy * w + ix) * 4;\n    return (\n      0.299 * fullData[idx] +\n      0.587 * fullData[idx + 1] +\n      0.114 * fullData[idx + 2]\n    );\n  };\n\n  // Scan radially at many angles to find ALL ring boundaries\n  // We need to detect: bullInner, bullOuter, trebleInner, trebleOuter, doubleInner, doubleOuter\n  const angleCount = 60;\n  const radiiByRing: { [key: number]: number[] } = {}; // Store radii at each angle\n\n  for (let a = 0; a < angleCount; a++) {\n    const angle = (a / angleCount) * Math.PI * 2;\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n\n    // Scan from center outward and find ALL local maxima (all ring boundaries)\n    const gradients: { r: number; grad: number }[] = [];\n\n    for (let r = 30; r < Math.min(w, h) / 2; r += 1) {\n      // Probe point (kept implicit via inner/outer sampling below)\n      const xInner = roughCx + (r - 2) * cos;\n      const yInner = roughCy + (r - 2) * sin;\n      const xOuter = roughCx + (r + 2) * cos;\n      const yOuter = roughCy + (r + 2) * sin;\n\n      const lumInner = lum(xInner, yInner);\n      const lumOuter = lum(xOuter, yOuter);\n\n      // Radial gradient: larger = stronger boundary\n      const grad = Math.abs(lumOuter - lumInner);\n\n      // SWEET SPOT: balanced threshold (v2.1 level)\n      if (grad > 2 && r > 20) {\n        // Good balance - not too strict, not too lenient\n        gradients.push({ r, grad });\n      }\n    }\n\n    // Find local maxima in gradients (these are ring boundaries)\n    const peaks: number[] = [];\n    for (let i = 0; i < gradients.length; i++) {\n      const prev = i > 0 ? gradients[i - 1].grad : 0;\n      const curr = gradients[i].grad;\n      const next = i < gradients.length - 1 ? gradients[i + 1].grad : 0;\n\n      // SWEET SPOT: balanced peak detection\n      if (curr > prev && curr > next && curr > 2) {\n        // Good balance point\n        peaks.push(gradients[i].r);\n      }\n    }\n\n    // Store all peaks for this angle\n    // Instead of using index, group peaks that are close together\n    // (close peaks = same ring, different angles)\n    if (peaks.length > 0) {\n      peaks.forEach((r) => {\n        // Find the closest existing ring tier\n        const ringKey = Object.keys(radiiByRing)\n          .map((k) => ({\n            key: parseInt(k),\n            median:\n              radiiByRing[parseInt(k)][\n                Math.floor(radiiByRing[parseInt(k)].length / 2)\n              ],\n          }))\n          .filter((entry) => Math.abs(entry.median - r) < 15) // Within 15 pixels = same ring\n          .sort((a, b) => Math.abs(a.median - r) - Math.abs(b.median - r))[0];\n\n        const tierIndex = ringKey\n          ? ringKey.key\n          : Math.max(-1, ...Object.keys(radiiByRing).map((k) => parseInt(k))) +\n            1;\n        if (!radiiByRing[tierIndex]) radiiByRing[tierIndex] = [];\n        radiiByRing[tierIndex].push(r);\n      });\n    }\n  }\n\n  // Extract the median radius for each ring tier\n  const ringRadii = Object.keys(radiiByRing)\n    .map((key) => {\n      const radii = radiiByRing[parseInt(key)].sort((a, b) => a - b);\n      const median = radii[Math.floor(radii.length / 2)];\n      return { tier: parseInt(key), radius: median, samples: radii.length };\n    })\n    .sort((a, b) => a.radius - b.radius);\n\n  console.log(`[findDartboardRings] Detected ring tiers:`, ringRadii);\n\n  // v2.6: Robust ring selection to ignore light rings/surrounds\n  // The double ring (inner/outer) are very close together (162 vs 170, ratio 1.05)\n  // If the outermost ring is much further out than the one before it, it's likely a light ring.\n  const filteredRings = [...ringRadii];\n  if (filteredRings.length >= 2) {\n    const last = filteredRings[filteredRings.length - 1].radius;\n    const secondLast = filteredRings[filteredRings.length - 2].radius;\n    const ratio = last / secondLast;\n\n    // If ratio > 1.15 and we have enough rings to suggest the second-last is the double,\n    // or if the ratio is extremely large (> 1.3), ignore the outermost ring.\n    if ((ratio > 1.15 && filteredRings.length >= 5) || ratio > 1.3) {\n      console.log(\n        `[findDartboardRings] Ignoring outermost ring (likely light ring/surround): ${last.toFixed(\n          1,\n        )}px (ratio ${ratio.toFixed(2)} to ${secondLast.toFixed(1)}px)`,\n      );\n      filteredRings.pop();\n    }\n  }\n\n  // The outermost ring of the FILTERED set should be the double outer\n  const doubleOuterRadius =\n    filteredRings.length > 0\n      ? filteredRings[filteredRings.length - 1].radius\n      : Math.min(w, h) * 0.3;\n\n  // v2.4: Boost detection confidence based on ring completeness\n  // All 7 rings detected = near-perfect setup (98%)\n  // 6+ rings = excellent (96%)\n  // 5 rings = good (94%)\n  // fewer = lower confidence\n  let detectionConfidence = 50 + filteredRings.length * 6; // Base: 50-92% for 0-7 rings\n  if (filteredRings.length >= 7) {\n    detectionConfidence = 98; // All rings perfect\n  } else if (filteredRings.length === 6) {\n    detectionConfidence = 96;\n  } else if (filteredRings.length === 5) {\n    detectionConfidence = 94;\n  }\n\n  return {\n    cx: roughCx,\n    cy: roughCy,\n    r: doubleOuterRadius,\n    confidence: detectionConfidence,\n    ringCount: filteredRings.length,\n    ringStrength:\n      filteredRings.length > 0\n        ? filteredRings[filteredRings.length - 1].radius\n        : 0,\n    detectedRings: filteredRings.map((r) => r.radius),\n  };\n}\n\n/**\n * Compute board orientation by analyzing radial gradients at the treble ring.\n * Returns the rotation angle (radians) that maps canonical sector centers to image angles.\n */\nfunction computeBoardOrientation(\n  canvas: HTMLCanvasElement,\n  cx: number,\n  cy: number,\n  radius: number,\n): number | null {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return null;\n  const w = canvas.width;\n  const h = canvas.height;\n  const sampleCount = 720; // high angular resolution\n  const sampleRadius = radius; // use the outer radius (double outer) or treble\n  const gradSamples: number[] = new Array(sampleCount).fill(0);\n  // compute luminance radial derivative across a small radial band\n  const rInner = Math.max(2, Math.round(sampleRadius - 8));\n  const rOuter = Math.round(sampleRadius + 8);\n  const imageData = ctx.getImageData(0, 0, w, h).data;\n  const lum = (x: number, y: number) => {\n    const ix = Math.round(x);\n    const iy = Math.round(y);\n    if (ix < 0 || ix >= w || iy < 0 || iy >= h) return 127;\n    const idx = (iy * w + ix) * 4;\n    return (\n      imageData[idx] * 0.299 +\n      imageData[idx + 1] * 0.587 +\n      imageData[idx + 2] * 0.114\n    );\n  };\n  for (let i = 0; i < sampleCount; i++) {\n    const a = (i / sampleCount) * Math.PI * 2;\n    // sample radial line and compute max gradient magnitude along it\n    let maxGrad = 0;\n    let prev = lum(cx + rInner * Math.cos(a), cy + rInner * Math.sin(a));\n    for (let r = rInner + 1; r <= rOuter; r++) {\n      const cur = lum(cx + r * Math.cos(a), cy + r * Math.sin(a));\n      const g = Math.abs(cur - prev);\n      if (g > maxGrad) maxGrad = g;\n      prev = cur;\n    }\n    gradSamples[i] = maxGrad;\n  }\n  // Find local maxima which correspond to boundaries; threshold somewhat high\n  const peaks: number[] = [];\n  for (let i = 0; i < sampleCount; i++) {\n    const prev = gradSamples[(i - 1 + sampleCount) % sampleCount];\n    const cur = gradSamples[i];\n    const next = gradSamples[(i + 1) % sampleCount];\n    if (cur > prev && cur > next && cur > 10) peaks.push(i);\n  }\n  if (peaks.length < 16) {\n    // fallback: smooth and find broad maxima\n    const smoothed = gradSamples.map((v, idx) => {\n      let s = 0;\n      let k = 0;\n      for (let d = -2; d <= 2; d++) {\n        s += gradSamples[(idx + d + sampleCount) % sampleCount];\n        k++;\n      }\n      return s / k;\n    });\n    for (let i = 0; i < sampleCount; i++) {\n      const prev = smoothed[(i - 1 + sampleCount) % sampleCount];\n      const cur = smoothed[i];\n      const next = smoothed[(i + 1) % sampleCount];\n      if (cur > prev && cur > next && cur > 8) peaks.push(i);\n    }\n  }\n  if (peaks.length === 0) return 0;\n  // Convert peak indices to angles\n  const peakAngles = peaks.map((p) => (p / sampleCount) * Math.PI * 2);\n  // We expect wires at roughly 20 positions; convert to sector centers (midpoint between successive peaks)\n  peakAngles.sort((a, b) => a - b);\n  const sectorCenters: number[] = [];\n  for (let i = 0; i < peakAngles.length; i++) {\n    const a1 = peakAngles[i];\n    const a2 = peakAngles[(i + 1) % peakAngles.length];\n    // handle wrap\n    const diff = (a2 - a1 + Math.PI * 2) % (Math.PI * 2);\n    sectorCenters.push((a1 + diff / 2) % (Math.PI * 2));\n  }\n  // Now we need to map these detected sector centers to canonical sector angles\n  const sectorCount = 20;\n  const canonicalAngles = new Array(sectorCount)\n    .fill(0)\n    .map((_, i) => -Math.PI / 2 + i * ((Math.PI * 2) / sectorCount));\n  // Find rotation offset that best aligns detected centers to canonical centers using circular shifting\n  // We'll attempt shifts so that sectorCenters[0] maps to canonicalAngles[s] and choose best fit\n  let bestRot = 0;\n  let bestErr = Infinity;\n  for (let shift = 0; shift < sectorCenters.length; shift++) {\n    // Build map for first N up to 20 sectors\n    let err = 0;\n    for (let k = 0; k < Math.min(sectorCount, sectorCenters.length); k++) {\n      const detectedAngle = sectorCenters[(k + shift) % sectorCenters.length];\n      const canonicalAngle = canonicalAngles[k];\n      const d = Math.abs(\n        ((detectedAngle - canonicalAngle + Math.PI) % (Math.PI * 2)) - Math.PI,\n      );\n      err += d * d;\n    }\n    if (err < bestErr) {\n      bestErr = err;\n      bestRot =\n        (sectorCenters[shift] - canonicalAngles[0] + Math.PI * 2) %\n        (Math.PI * 2);\n    }\n  }\n  // Convert bestRot to [-pi,pi]\n  const theta = ((bestRot + Math.PI) % (Math.PI * 2)) - Math.PI;\n  return theta;\n}\n\n// Refine an existing homography by making tiny adjustments (rotation, scale, translation)\n// to maximize radial gradient energy along the treble and double outer rings.\nfunction refineHomographyByRings(\n  canvas: HTMLCanvasElement,\n  H: Homography,\n): Homography {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return H;\n  const w = canvas.width,\n    h = canvas.height;\n  const id = ctx.getImageData(0, 0, w, h);\n  const data = id.data;\n\n  // Helper: luminance and gradient at (x,y)\n  const lum = (x: number, y: number) => {\n    const ix = Math.max(0, Math.min(w - 1, Math.round(x)));\n    const iy = Math.max(0, Math.min(h - 1, Math.round(y)));\n    const idx = (iy * w + ix) * 4;\n    return 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];\n  };\n  const grad = (x: number, y: number) => {\n    const gx = lum(x + 1, y) - lum(x - 1, y);\n    const gy = lum(x, y + 1) - lum(x, y - 1);\n    return { gx, gy };\n  };\n\n  // Board center in image for computing radial normals\n  const cImg = applyHomography(H, { x: 0, y: 0 });\n\n  // Scoring function: sum of radial gradient magnitude along rings\n  const ringScore = (Htest: Homography) => {\n    const rings = [BoardRadii.trebleOuter, BoardRadii.doubleOuter];\n    let score = 0;\n    for (const r of rings) {\n      const pts = sampleRing(Htest, r, 180);\n      for (let i = 0; i < pts.length; i++) {\n        const p = pts[i];\n        const g = grad(p.x, p.y);\n        // radial direction from image center point (mapped board origin)\n        const nx = p.x - cImg.x;\n        const ny = p.y - cImg.y;\n        const nlen = Math.hypot(nx, ny) || 1;\n        const ux = nx / nlen,\n          uy = ny / nlen;\n        score += Math.abs(g.gx * ux + g.gy * uy);\n      }\n    }\n    return score / 180 / 2; // normalized average per ring\n  };\n\n  let bestH = H;\n  let bestScore = ringScore(H);\n\n  // Small local search: rotation (±4°), image translation (±3px), isotropic image scale (±2%)\n  const toRad = (deg: number) => (deg * Math.PI) / 180;\n  const rotSteps = [-4, -2, -1, -0.5, 0, 0.5, 1, 2, 4];\n  const txSteps = [-3, -2, -1, 0, 1, 2, 3];\n  const scaleSteps = [0.98, 0.99, 1.0, 1.01, 1.02];\n\n  for (const rot of rotSteps) {\n    const Hr = rotateHomography(H, toRad(rot));\n    for (const tx of txSteps) {\n      for (const ty of txSteps) {\n        const Ht = translateHomography(Hr, tx, ty);\n        for (const s of scaleSteps) {\n          const Hs = scaleHomography(Ht, s, s);\n          const sc = ringScore(Hs);\n          if (sc > bestScore) {\n            bestScore = sc;\n            bestH = Hs;\n          }\n        }\n      }\n    }\n  }\n  return bestH;\n}\n\n/**\n * Main board detection function\n * Uses direct ring detection approach\n */\nexport function detectBoard(\n  canvas: HTMLCanvasElement,\n  opts?: { centerHint?: Point; colorAssist?: boolean },\n): BoardDetectionResult {\n  try {\n    const w = canvas.width;\n    const h = canvas.height;\n    const centerX = w / 2;\n    const centerY = h / 2;\n\n    // Optional: pre-filter image to only keep red and green hues (helps isolate double/treble bands)\n    let srcCanvas: HTMLCanvasElement | OffscreenCanvas = canvas as any;\n    // Optional color assist pre-filter (helps isolate double/treble bands)\n    if (opts?.colorAssist) {\n      try {\n        const makeCanvas = (w: number, h: number) => {\n          try {\n            return new OffscreenCanvas(w, h);\n          } catch {\n            const c = document.createElement(\"canvas\");\n            c.width = w;\n            c.height = h;\n            return c;\n          }\n        };\n        const oc = makeCanvas(w, h);\n        const octx = oc.getContext(\"2d\") as CanvasRenderingContext2D | null;\n        if (!octx) throw new Error(\"Could not get 2D context\");\n        (octx as CanvasRenderingContext2D).drawImage(canvas, 0, 0, w, h);\n        const id = (octx as CanvasRenderingContext2D).getImageData(0, 0, w, h);\n        const data = id.data;\n        // RGB -> HSV helper (fast approximation)\n        const rgb2hsv = (r: number, g: number, b: number) => {\n          const rn = r / 255,\n            gn = g / 255,\n            bn = b / 255;\n          const max = Math.max(rn, gn, bn),\n            min = Math.min(rn, gn, bn);\n          const d = max - min;\n          let h = 0;\n          if (d !== 0) {\n            if (max === rn) h = ((gn - bn) / d) % 6;\n            else if (max === gn) h = (bn - rn) / d + 2;\n            else h = (rn - gn) / d + 4;\n            h *= 60;\n            if (h < 0) h += 360;\n          }\n          const s = max === 0 ? 0 : d / max;\n          const v = max;\n          return { h, s, v };\n        };\n        for (let i = 0; i < data.length; i += 4) {\n          const r = data[i],\n            g = data[i + 1],\n            b = data[i + 2];\n          const { h: hh, s, v } = rgb2hsv(r, g, b);\n          // Keep saturated reds and greens; zero out everything else\n          const isRed =\n            s > 0.25 &&\n            v > 0.2 &&\n            (hh < 20 || hh > 340 || (hh > 340 && hh <= 360));\n          const isGreen = s > 0.25 && v > 0.2 && hh >= 80 && hh <= 160;\n          if (!(isRed || isGreen)) {\n            data[i] = data[i + 1] = data[i + 2] = 0; // black\n          } else {\n            // boost\n            data[i] = Math.min(255, r * 1.2);\n            data[i + 1] = Math.min(255, g * 1.2);\n            data[i + 2] = Math.min(255, b * 1.2);\n          }\n        }\n        (octx as CanvasRenderingContext2D).putImageData(id, 0, 0);\n        srcCanvas = oc;\n      } catch (e) {\n        // fall back silently\n        srcCanvas = canvas as any;\n      }\n    }\n\n    // Find dartboard rings\n    const detection = findDartboardRings(srcCanvas as any, opts?.centerHint);\n\n    if (!detection) {\n      return {\n        success: false,\n        cx: centerX,\n        cy: centerY,\n        bullInner: 0,\n        bullOuter: 0,\n        trebleInner: 0,\n        trebleOuter: 0,\n        doubleInner: 0,\n        doubleOuter: 0,\n        confidence: 0,\n        homography: null,\n        errorPx: null,\n        calibrationPoints: [],\n        message:\n          \"No dartboard detected. Ensure board is clearly visible with good contrast between rings and background.\",\n      };\n    }\n\n    // Use DETECTED ring positions directly - these are the actual black rings on YOUR dartboard!\n    // If we detected all 6 rings, use them. Otherwise fall back to scaling.\n    const detected = (() => {\n      const rings = detection.detectedRings || [];\n      if (rings.length >= 6) {\n        // We detected all rings: use them directly\n        return {\n          cx: detection.cx,\n          cy: detection.cy,\n          bullInner: rings[0],\n          bullOuter: rings[1],\n          trebleInner: rings[2],\n          trebleOuter: rings[3],\n          doubleInner: rings[4],\n          doubleOuter: rings[5],\n        };\n      } else {\n        // Fallback: scale based on detected double outer\n        const scale = detection.r / BoardRadii.doubleOuter;\n        return {\n          cx: detection.cx,\n          cy: detection.cy,\n          bullInner: BoardRadii.bullInner * scale,\n          bullOuter: BoardRadii.bullOuter * scale,\n          trebleInner: BoardRadii.trebleInner * scale,\n          trebleOuter: BoardRadii.trebleOuter * scale,\n          doubleInner: BoardRadii.doubleInner * scale,\n          doubleOuter: detection.r,\n        };\n      }\n    })();\n\n    // NEW: Detect board orientation (theta) using the treble ring\n    // This is much more robust than looking for peaks in the double ring\n    const theta =\n      computeBoardOrientation(\n        canvas,\n        detected.cx,\n        detected.cy,\n        detected.doubleOuter,\n      ) || 0;\n\n    // Generate 5 calibration points from detected rings (TOP, RIGHT, BOTTOM, LEFT, BULL)\n    // We use the detected theta to rotate the canonical targets\n    const canonicalSrc = canonicalRimTargets(\"outer\");\n    const calibrationPoints: Point[] = canonicalSrc.map((p) => {\n      if (p.x === 0 && p.y === 0) return { x: detected.cx, y: detected.cy };\n\n      // Rotate canonical point by theta\n      const cos = Math.cos(theta);\n      const sin = Math.sin(theta);\n\n      // Canonical points are in mm, we need to scale them to pixels\n      const scale = detected.doubleOuter / BoardRadii.doubleOuter;\n      const px = p.x * scale;\n      const py = p.y * scale;\n\n      // Rotate and translate to detected center\n      return {\n        x: detected.cx + (px * cos - py * sin),\n        y: detected.cy + (px * sin + py * cos),\n      };\n    });\n\n    let homography: Homography | null = null;\n    let errorPx: number | null = null;\n    let confidence = detection.confidence;\n    let inlierRatio = 1.0;\n\n    try {\n      // Respect user setting for RANSAC usage (when available)\n      let useRansac = true;\n      try {\n        const s = useUserSettings.getState?.();\n        useRansac = !!s?.calibrationUseRansac;\n      } catch (e) {}\n\n      if (useRansac) {\n        const ransac = ransacHomography(canonicalSrc, calibrationPoints, {\n          thresholdPx: 8,\n          maxIter: 300,\n        });\n        if (ransac.H) {\n          homography = ransac.H;\n          errorPx = ransac.errorPx;\n          const inlierCount = ransac.inliers.filter(Boolean).length;\n          inlierRatio = inlierCount / calibrationPoints.length;\n          confidence = Math.max(\n            confidence,\n            Math.round(confidence * 0.6 + inlierRatio * 40),\n          );\n        } else {\n          homography = computeHomographyDLT(canonicalSrc, calibrationPoints);\n          errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n        }\n      } else {\n        homography = computeHomographyDLT(canonicalSrc, calibrationPoints);\n        errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n      }\n\n      // NEW: Refine homography by maximizing radial gradient energy along rings\n      if (homography) {\n        homography = refineHomographyByRings(canvas, homography);\n        errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n      }\n\n      // Re-center the homography so board center maps exactly to detected bull.\n      // This keeps bull scoring tight even when ring refinement introduces a\n      // tiny translation drift.\n      if (homography) {\n        const centerImg = applyHomography(homography, { x: 0, y: 0 });\n        const dx = detected.cx - centerImg.x;\n        const dy = detected.cy - centerImg.y;\n        if (Math.hypot(dx, dy) > 0.25) {\n          homography = translateHomography(homography, dx, dy);\n          errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n        }\n      }\n\n      // Truth-based confidence: keep all calibration confidence values on the same\n      // scale used throughout the app (errorPx -> 0-100 mapping).\n      // This avoids having multiple competing confidence formulas.\n      const errPx = typeof errorPx === \"number\" ? errorPx : null;\n      const global = getGlobalCalibrationConfidence(errPx);\n      if (typeof global === \"number\") {\n        confidence = global;\n      } else {\n        // If error is unavailable, fall back to detection quality and inlier ratio.\n        confidence = Math.max(inlierRatio * 100, detection.confidence);\n      }\n    } catch (err) {\n      // Even if error in computation, if we have points, still fairly confident\n      confidence = Math.max(65, detection.confidence);\n    }\n\n    const pointsValid = calibrationPoints.every(isFinitePoint);\n    const homographyValid = isFiniteHomography(homography);\n    // More lenient success criteria: if homography computed, consider it success\n    const success = !!homographyValid && pointsValid && confidence > 50;\n    const detRingCount = detection.ringCount ?? 0;\n\n    const result = {\n      success,\n      cx: detected.cx,\n      cy: detected.cy,\n      bullInner: detected.bullInner,\n      bullOuter: detected.bullOuter,\n      trebleInner: detected.trebleInner,\n      trebleOuter: detected.trebleOuter,\n      doubleInner: detected.doubleInner,\n      doubleOuter: detected.doubleOuter,\n      confidence: Math.round(confidence), // Use calculated confidence directly (already has 85% floor)\n      homography: homographyValid ? homography : null,\n      errorPx: homographyValid ? errorPx : null,\n      calibrationPoints: pointsValid ? calibrationPoints : [],\n      theta: typeof theta === \"number\" ? theta : undefined,\n      message:\n        !pointsValid || !homographyValid\n          ? `❌ Detection produced unstable calibration data. Adjust camera framing or calibrate manually. (rings: ${detRingCount}, r:${Math.round(detection.r)})`\n          : confidence > 85\n            ? `✅ Excellent detection (rings: ${detRingCount}, r:${Math.round(detection.r)})`\n            : `✅ Board detected - may need angle adjustment (rings: ${detRingCount}, r:${Math.round(detection.r)})`,\n    };\n\n    console.log(\n      \"[detectBoard] Final result:\",\n      {\n        success: result.success,\n        confidence: result.confidence,\n        homographyValid,\n        pointsValid,\n        cx: Math.round(result.cx),\n        cy: Math.round(result.cy),\n        doubleOuter: Math.round(result.doubleOuter),\n        rings: detRingCount,\n        errorPx: result.errorPx ? result.errorPx.toFixed(2) : null,\n        calibrationPoints: calibrationPoints.map((p) => ({\n          x: Math.round(p.x),\n          y: Math.round(p.y),\n        })),\n      },\n      result.message,\n    );\n\n    return result;\n  } catch (err) {\n    return {\n      success: false,\n      cx: canvas.width / 2,\n      cy: canvas.height / 2,\n      bullInner: 0,\n      bullOuter: 0,\n      trebleInner: 0,\n      trebleOuter: 0,\n      doubleInner: 0,\n      doubleOuter: 0,\n      confidence: 0,\n      homography: null,\n      errorPx: null,\n      calibrationPoints: [],\n      message: err instanceof Error ? err.message : \"Board detection failed\",\n    };\n  }\n}\n\n/**\n * Refine detection by looking for concentric rings\n * This helps match detected circles to specific board rings\n */\nexport function refineRingDetection(\n  detected: BoardDetectionResult,\n): BoardDetectionResult {\n  // v2.4: Don't reduce confidence based on ring ratios\n  // The v2.4 confidence calculation already accounts for detection quality\n  // Ratios being off just means different dartboard size/setup - not a quality issue\n  // The homography calculation handles the actual ring positions\n  return detected;\n}\n","/**\n * Network device discovery utilities for wifi scoring devices\n */\n\n// Web Serial API types\ndeclare global {\n  interface Navigator {\n    serial: Serial;\n  }\n  interface Serial extends EventTarget {\n    getPorts(): Promise<SerialPort[]>;\n    requestPort(options?: SerialOptions): Promise<SerialPort>;\n  }\n  interface SerialPort {\n    open(options: SerialOptions): Promise<void>;\n    close(): Promise<void>;\n    readable: ReadableStream<Uint8Array> | null;\n    writable: WritableStream<Uint8Array> | null;\n  }\n  interface SerialOptions {\n    baudRate?: number;\n    dataBits?: number;\n    stopBits?: number;\n    parity?: \"none\" | \"even\" | \"odd\";\n    bufferSize?: number;\n    flowControl?: \"none\" | \"hardware\";\n  }\n}\n\nexport interface NetworkDevice {\n  id: string;\n  name: string;\n  ip: string;\n  port: number;\n  type: \"omni\" | \"vert\" | \"generic\";\n  capabilities: string[];\n  status: \"online\" | \"offline\" | \"connecting\";\n  connectionType: \"wifi\" | \"usb\";\n}\n\n/**\n * USB device interface for serial-connected scoring devices\n */\nexport interface USBDevice {\n  id: string;\n  name: string;\n  type: \"omni\" | \"vert\" | \"generic\";\n  capabilities: string[];\n  status: \"online\" | \"offline\" | \"connecting\";\n  port: SerialPort | null;\n}\n\n/**\n * Discover wifi scoring devices on the local network\n */\nexport async function discoverNetworkDevices(): Promise<NetworkDevice[]> {\n  const devices: NetworkDevice[] = [];\n\n  try {\n    // Get local network info\n    const localIPs = await getLocalIPs();\n\n    for (const localIP of localIPs) {\n      // Scan common ports for dart scoring devices\n      const scanResults = await scanNetwork(\n        localIP,\n        [80, 8080, 8787, 8788, 3000, 5000],\n      );\n\n      for (const result of scanResults) {\n        const device = await probeDevice(result.ip, result.port);\n        if (device) {\n          devices.push(device);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"Network discovery failed:\", error);\n  }\n\n  return devices;\n}\n\n/**\n * Get local IP addresses\n */\nasync function getLocalIPs(): Promise<string[]> {\n  const ips: string[] = [];\n\n  try {\n    // Try to get local IPs via WebRTC\n    const pc = new RTCPeerConnection({ iceServers: [] });\n    pc.createDataChannel(\"\");\n\n    const offer = await pc.createOffer();\n    await pc.setLocalDescription(offer);\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        pc.close();\n        resolve(ips);\n      }, 5000);\n\n      pc.onicecandidate = (event) => {\n        if (event.candidate) {\n          const candidate = event.candidate.candidate;\n          const ipMatch = candidate.match(/(\\d+\\.\\d+\\.\\d+\\.\\d+)/);\n          if (ipMatch && ipMatch[1] && !ips.includes(ipMatch[1])) {\n            const ip = ipMatch[1];\n            // Only include private IPs\n            if (isPrivateIP(ip)) {\n              ips.push(ip);\n            }\n          }\n        } else {\n          clearTimeout(timeout);\n          pc.close();\n          resolve(ips);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(\"Failed to get local IPs:\", error);\n    return [\"192.168.1.0\"]; // fallback\n  }\n}\n\n/**\n * Check if IP is in private range\n */\nfunction isPrivateIP(ip: string): boolean {\n  const parts = ip.split(\".\").map(Number);\n  return (\n    parts[0] === 10 ||\n    (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||\n    (parts[0] === 192 && parts[1] === 168)\n  );\n}\n\n/**\n * Scan network for open ports\n */\nasync function scanNetwork(\n  localIP: string,\n  ports: number[],\n): Promise<{ ip: string; port: number }[]> {\n  const results: { ip: string; port: number }[] = [];\n  const baseIP = localIP.split(\".\").slice(0, 3).join(\".\");\n\n  // Scan a reasonable range (e.g., .1 to .254)\n  const promises = [];\n  for (let i = 1; i <= 254; i++) {\n    const ip = `${baseIP}.${i}`;\n    for (const port of ports) {\n      promises.push(checkPort(ip, port));\n    }\n  }\n\n  const portResults = await Promise.allSettled(promises);\n\n  portResults.forEach((result, index) => {\n    if (result.status === \"fulfilled\" && result.value) {\n      const portIndex = index % ports.length;\n      const ipIndex = Math.floor(index / ports.length);\n      const ip = `${baseIP}.${ipIndex + 1}`;\n      results.push({ ip, port: ports[portIndex] });\n    }\n  });\n\n  return results;\n}\n\n/**\n * Check if a specific port is open on an IP\n */\nasync function checkPort(ip: string, port: number): Promise<boolean> {\n  try {\n    await fetch(`http://${ip}:${port}/`, {\n      method: \"HEAD\",\n      mode: \"no-cors\",\n      signal: AbortSignal.timeout(2000),\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Probe a device to identify its type and capabilities\n */\nasync function probeDevice(\n  ip: string,\n  port: number,\n): Promise<NetworkDevice | null> {\n  try {\n    // Try common endpoints for dart scoring devices\n    const endpoints = [\"/\", \"/api/info\", \"/api/status\", \"/camera\", \"/stream\"];\n\n    for (const endpoint of endpoints) {\n      try {\n        const response = await fetch(`http://${ip}:${port}${endpoint}`, {\n          method: \"GET\",\n          signal: AbortSignal.timeout(3000),\n        });\n\n        if (response.ok) {\n          const contentType = response.headers.get(\"content-type\") || \"\";\n          const text = await response.text();\n\n          // Check for OMNI device\n          if (\n            text.includes(\"OMNI\") ||\n            text.includes(\"omni\") ||\n            endpoint.includes(\"omni\")\n          ) {\n            return {\n              id: `omni-${ip}-${port}`,\n              name: `OMNI Camera (${ip})`,\n              ip,\n              port,\n              type: \"omni\",\n              capabilities: [\"video\", \"calibration\"],\n              status: \"online\",\n              connectionType: \"wifi\",\n            };\n          }\n\n          // Check for VERT device\n          if (\n            text.includes(\"VERT\") ||\n            text.includes(\"vert\") ||\n            endpoint.includes(\"vert\")\n          ) {\n            return {\n              id: `vert-${ip}-${port}`,\n              name: `VERT Camera (${ip})`,\n              ip,\n              port,\n              type: \"vert\",\n              capabilities: [\"video\", \"calibration\"],\n              status: \"online\",\n              connectionType: \"wifi\",\n            };\n          }\n\n          // Check for generic video streaming device\n          if (\n            contentType.includes(\"video\") ||\n            text.includes(\"stream\") ||\n            endpoint === \"/stream\"\n          ) {\n            return {\n              id: `generic-${ip}-${port}`,\n              name: `Network Camera (${ip})`,\n              ip,\n              port,\n              type: \"generic\",\n              capabilities: [\"video\"],\n              status: \"online\",\n              connectionType: \"wifi\",\n            };\n          }\n        }\n      } catch {\n        // Continue to next endpoint\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to probe device ${ip}:${port}:`, error);\n  }\n\n  return null;\n}\n\n/**\n * Discover USB scoring devices connected via serial\n */\nexport async function discoverUSBDevices(): Promise<USBDevice[]> {\n  const devices: USBDevice[] = [];\n\n  try {\n    // Check if Web Serial API is supported\n    if (!(\"serial\" in navigator)) {\n      console.warn(\"Web Serial API not supported in this browser\");\n      return devices;\n    }\n\n    // Get already paired ports\n    const ports = await navigator.serial.getPorts();\n\n    for (const port of ports) {\n      const device = await probeUSBDevice(port);\n      if (device) {\n        devices.push(device);\n      }\n    }\n\n    // Also try to request a new port (this will show user selection dialog)\n    // Note: This is optional and will be handled separately in the UI\n  } catch (error) {\n    console.error(\"USB device discovery failed:\", error);\n  }\n\n  return devices;\n}\n\n/**\n * Request user to select a USB device\n */\nexport async function requestUSBDevice(): Promise<USBDevice | null> {\n  try {\n    if (!(\"serial\" in navigator)) {\n      alert(\n        \"Web Serial API not supported in this browser. Please use a compatible browser like Chrome or Edge.\",\n      );\n      return null;\n    }\n\n    const port = await navigator.serial.requestPort();\n    return await probeUSBDevice(port);\n  } catch (error) {\n    if ((error as any).name !== \"NotFoundError\") {\n      console.error(\"USB device request failed:\", error);\n    }\n    return null;\n  }\n}\n\n/**\n * Probe a USB serial port to identify the device type\n */\nasync function probeUSBDevice(port: SerialPort): Promise<USBDevice | null> {\n  try {\n    // Open the port with common settings for dart scoring devices\n    await port.open({\n      baudRate: 9600,\n      dataBits: 8,\n      stopBits: 1,\n      parity: \"none\",\n    });\n\n    // Try to read some data to identify the device\n    const reader = port.readable?.getReader();\n    if (reader) {\n      try {\n        // Set a timeout for reading\n        const timeout = setTimeout(() => reader.cancel(), 2000);\n\n        const { value, done } = await reader.read();\n        clearTimeout(timeout);\n\n        if (!done && value) {\n          const text = new TextDecoder().decode(value);\n\n          // Check for OMNI device\n          if (text.includes(\"OMNI\") || text.includes(\"omni\")) {\n            reader.releaseLock();\n            return {\n              id: `usb-omni-${Date.now()}`,\n              name: \"OMNI Camera (USB)\",\n              type: \"omni\",\n              capabilities: [\"video\", \"calibration\"],\n              status: \"online\",\n              port,\n            };\n          }\n\n          // Check for VERT device\n          if (text.includes(\"VERT\") || text.includes(\"vert\")) {\n            reader.releaseLock();\n            return {\n              id: `usb-vert-${Date.now()}`,\n              name: \"VERT Camera (USB)\",\n              type: \"vert\",\n              capabilities: [\"video\", \"calibration\"],\n              status: \"online\",\n              port,\n            };\n          }\n        }\n      } catch {\n        // Continue\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch {}\n      }\n    }\n\n    // If we can't identify, assume it's a generic device\n    return {\n      id: `usb-generic-${Date.now()}`,\n      name: \"USB Scoring Device\",\n      type: \"generic\",\n      capabilities: [\"video\"],\n      status: \"online\",\n      port,\n    };\n  } catch (error) {\n    console.error(\"Failed to probe USB device:\", error);\n    return null;\n  }\n}\n\n/**\n * Connect to a network device and get video stream\n */\nexport async function connectToNetworkDevice(\n  device: NetworkDevice,\n): Promise<MediaStream | null> {\n  try {\n    // For now, assume devices provide an MJPEG or HLS stream\n    // This would need to be adapted based on the actual device API\n    const streamUrl = `http://${device.ip}:${device.port}/stream`;\n\n    // Create a video element to capture the stream\n    const video = document.createElement(\"video\");\n    video.src = streamUrl;\n    video.crossOrigin = \"anonymous\";\n\n    return new Promise((resolve, reject) => {\n      video.onloadeddata = () => {\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\")!;\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n\n        // Create a MediaStream from the video\n        const stream = canvas.captureStream(30); // 30 FPS\n\n        const drawFrame = () => {\n          if (video.readyState >= 2) {\n            ctx.drawImage(video, 0, 0);\n          }\n          requestAnimationFrame(drawFrame);\n        };\n        drawFrame();\n\n        resolve(stream);\n      };\n\n      video.onerror = () => reject(new Error(\"Failed to load video stream\"));\n      video.load();\n    });\n  } catch (error) {\n    console.error(\"Failed to connect to network device:\", error);\n    return null;\n  }\n}\n\n/**\n * Connect to a USB device and get video stream\n */\nexport async function connectToUSBDevice(\n  device: USBDevice,\n): Promise<MediaStream | null> {\n  try {\n    if (!device.port) {\n      throw new Error(\"No serial port available\");\n    }\n\n    // For USB devices, we assume they provide video through a companion app or driver\n    // This is a placeholder - actual implementation would depend on the device protocol\n    console.log(\"USB device connection not fully implemented yet\");\n    return null;\n  } catch (error) {\n    console.error(\"Failed to connect to USB device:\", error);\n    return null;\n  }\n}\n","// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nmodule.exports = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then\n}\n","let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n","exports.L = { bit: 1 }\nexports.M = { bit: 0 }\nexports.Q = { bit: 3 }\nexports.H = { bit: 2 }\n\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'l':\n    case 'low':\n      return exports.L\n\n    case 'm':\n    case 'medium':\n      return exports.M\n\n    case 'q':\n    case 'quartile':\n      return exports.Q\n\n    case 'h':\n    case 'high':\n      return exports.H\n\n    default:\n      throw new Error('Unknown EC Level: ' + string)\n  }\n}\n\nexports.isValid = function isValid (level) {\n  return level && typeof level.bit !== 'undefined' &&\n    level.bit >= 0 && level.bit < 4\n}\n\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n","function BitBuffer () {\n  this.buffer = []\n  this.length = 0\n}\n\nBitBuffer.prototype = {\n\n  get: function (index) {\n    const bufIndex = Math.floor(index / 8)\n    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1\n  },\n\n  put: function (num, length) {\n    for (let i = 0; i < length; i++) {\n      this.putBit(((num >>> (length - i - 1)) & 1) === 1)\n    }\n  },\n\n  getLengthInBits: function () {\n    return this.length\n  },\n\n  putBit: function (bit) {\n    const bufIndex = Math.floor(this.length / 8)\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0)\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))\n    }\n\n    this.length++\n  }\n}\n\nmodule.exports = BitBuffer\n","/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n","/**\n * Alignment pattern are fixed reference pattern in defined positions\n * in a matrix symbology, which enables the decode software to re-synchronise\n * the coordinate mapping of the image modules in the event of moderate amounts\n * of distortion of the image.\n *\n * Alignment patterns are present only in QR Code symbols of version 2 or larger\n * and their number depends on the symbol version.\n */\n\nconst getSymbolSize = require('./utils').getSymbolSize\n\n/**\n * Calculate the row/column coordinates of the center module of each alignment pattern\n * for the specified QR Code version.\n *\n * The alignment patterns are positioned symmetrically on either side of the diagonal\n * running from the top left corner of the symbol to the bottom right corner.\n *\n * Since positions are simmetrical only half of the coordinates are returned.\n * Each item of the array will represent in turn the x and y coordinate.\n * @see {@link getPositions}\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinate\n */\nexports.getRowColCoords = function getRowColCoords (version) {\n  if (version === 1) return []\n\n  const posCount = Math.floor(version / 7) + 2\n  const size = getSymbolSize(version)\n  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2\n  const positions = [size - 7] // Last coord is always (size - 7)\n\n  for (let i = 1; i < posCount - 1; i++) {\n    positions[i] = positions[i - 1] - intervals\n  }\n\n  positions.push(6) // First coord is always 6\n\n  return positions.reverse()\n}\n\n/**\n * Returns an array containing the positions of each alignment pattern.\n * Each array's element represent the center point of the pattern as (x, y) coordinates\n *\n * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n * and filtering out the items that overlaps with finder pattern\n *\n * @example\n * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n * The alignment patterns, therefore, are to be centered on (row, column)\n * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n * and are not therefore used for alignment patterns.\n *\n * let pos = getPositions(7)\n * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const coords = []\n  const pos = exports.getRowColCoords(version)\n  const posLength = pos.length\n\n  for (let i = 0; i < posLength; i++) {\n    for (let j = 0; j < posLength; j++) {\n      // Skip if position is occupied by finder patterns\n      if ((i === 0 && j === 0) || // top-left\n          (i === 0 && j === posLength - 1) || // bottom-left\n          (i === posLength - 1 && j === 0)) { // top-right\n        continue\n      }\n\n      coords.push([pos[i], pos[j]])\n    }\n  }\n\n  return coords\n}\n","const getSymbolSize = require('./utils').getSymbolSize\nconst FINDER_PATTERN_SIZE = 7\n\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const size = getSymbolSize(version)\n\n  return [\n    // top-left\n    [0, 0],\n    // top-right\n    [size - FINDER_PATTERN_SIZE, 0],\n    // bottom-left\n    [0, size - FINDER_PATTERN_SIZE]\n  ]\n}\n","/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n","const ECLevel = require('./error-correction-level')\r\n\r\nconst EC_BLOCKS_TABLE = [\r\n// L  M  Q  H\r\n  1, 1, 1, 1,\r\n  1, 1, 1, 1,\r\n  1, 1, 2, 2,\r\n  1, 2, 2, 4,\r\n  1, 2, 4, 4,\r\n  2, 4, 4, 4,\r\n  2, 4, 6, 5,\r\n  2, 4, 6, 6,\r\n  2, 5, 8, 8,\r\n  4, 5, 8, 8,\r\n  4, 5, 8, 11,\r\n  4, 8, 10, 11,\r\n  4, 9, 12, 16,\r\n  4, 9, 16, 16,\r\n  6, 10, 12, 18,\r\n  6, 10, 17, 16,\r\n  6, 11, 16, 19,\r\n  6, 13, 18, 21,\r\n  7, 14, 21, 25,\r\n  8, 16, 20, 25,\r\n  8, 17, 23, 25,\r\n  9, 17, 23, 34,\r\n  9, 18, 25, 30,\r\n  10, 20, 27, 32,\r\n  12, 21, 29, 35,\r\n  12, 23, 34, 37,\r\n  12, 25, 34, 40,\r\n  13, 26, 35, 42,\r\n  14, 28, 38, 45,\r\n  15, 29, 40, 48,\r\n  16, 31, 43, 51,\r\n  17, 33, 45, 54,\r\n  18, 35, 48, 57,\r\n  19, 37, 51, 60,\r\n  19, 38, 53, 63,\r\n  20, 40, 56, 66,\r\n  21, 43, 59, 70,\r\n  22, 45, 62, 74,\r\n  24, 47, 65, 77,\r\n  25, 49, 68, 81\r\n]\r\n\r\nconst EC_CODEWORDS_TABLE = [\r\n// L  M  Q  H\r\n  7, 10, 13, 17,\r\n  10, 16, 22, 28,\r\n  15, 26, 36, 44,\r\n  20, 36, 52, 64,\r\n  26, 48, 72, 88,\r\n  36, 64, 96, 112,\r\n  40, 72, 108, 130,\r\n  48, 88, 132, 156,\r\n  60, 110, 160, 192,\r\n  72, 130, 192, 224,\r\n  80, 150, 224, 264,\r\n  96, 176, 260, 308,\r\n  104, 198, 288, 352,\r\n  120, 216, 320, 384,\r\n  132, 240, 360, 432,\r\n  144, 280, 408, 480,\r\n  168, 308, 448, 532,\r\n  180, 338, 504, 588,\r\n  196, 364, 546, 650,\r\n  224, 416, 600, 700,\r\n  224, 442, 644, 750,\r\n  252, 476, 690, 816,\r\n  270, 504, 750, 900,\r\n  300, 560, 810, 960,\r\n  312, 588, 870, 1050,\r\n  336, 644, 952, 1110,\r\n  360, 700, 1020, 1200,\r\n  390, 728, 1050, 1260,\r\n  420, 784, 1140, 1350,\r\n  450, 812, 1200, 1440,\r\n  480, 868, 1290, 1530,\r\n  510, 924, 1350, 1620,\r\n  540, 980, 1440, 1710,\r\n  570, 1036, 1530, 1800,\r\n  570, 1064, 1590, 1890,\r\n  600, 1120, 1680, 1980,\r\n  630, 1204, 1770, 2100,\r\n  660, 1260, 1860, 2220,\r\n  720, 1316, 1950, 2310,\r\n  750, 1372, 2040, 2430\r\n]\r\n\r\n/**\r\n * Returns the number of error correction block that the QR Code should contain\r\n * for the specified version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction blocks\r\n */\r\nexports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of error correction codewords to use for the specified\r\n * version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction codewords\r\n */\r\nexports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n","const EXP_TABLE = new Uint8Array(512)\nconst LOG_TABLE = new Uint8Array(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  let x = 1\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (let i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n","const GF = require('./galois-field')\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n","const Polynomial = require('./polynomial')\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n","/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n","const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n","const VersionCheck = require('./version-check')\nconst Regex = require('./regex')\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n","const Utils = require('./utils')\nconst ECCode = require('./error-correction-code')\nconst ECLevel = require('./error-correction-level')\nconst Mode = require('./mode')\nconst VersionCheck = require('./version-check')\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n","const Utils = require('./utils')\n\nconst G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)\nconst G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)\nconst G15_BCH = Utils.getBCHDigit(G15)\n\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nexports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {\n  const data = ((errorCorrectionLevel.bit << 3) | mask)\n  let d = data << 10\n\n  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))\n  }\n\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return ((data << 10) | d) ^ G15_MASK\n}\n","const Mode = require('./mode')\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n","const Mode = require('./mode')\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nconst ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  let i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n","const Mode = require('./mode')\n\nfunction ByteData (data) {\n  this.mode = Mode.BYTE\n  if (typeof (data) === 'string') {\n    this.data = new TextEncoder().encode(data)\n  } else {\n    this.data = new Uint8Array(data)\n  }\n}\n\nByteData.getBitsLength = function getBitsLength (length) {\n  return length * 8\n}\n\nByteData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nByteData.prototype.getBitsLength = function getBitsLength () {\n  return ByteData.getBitsLength(this.data.length)\n}\n\nByteData.prototype.write = function (bitBuffer) {\n  for (let i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8)\n  }\n}\n\nmodule.exports = ByteData\n","const Mode = require('./mode')\nconst Utils = require('./utils')\n\nfunction KanjiData (data) {\n  this.mode = Mode.KANJI\n  this.data = data\n}\n\nKanjiData.getBitsLength = function getBitsLength (length) {\n  return length * 13\n}\n\nKanjiData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nKanjiData.prototype.getBitsLength = function getBitsLength () {\n  return KanjiData.getBitsLength(this.data.length)\n}\n\nKanjiData.prototype.write = function (bitBuffer) {\n  let i\n\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    let value = Utils.toSJIS(this.data[i])\n\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140\n\n    // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140\n    } else {\n      throw new Error(\n        'Invalid SJIS character: ' + this.data[i] + '\\n' +\n        'Make sure your charset is UTF-8')\n    }\n\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)\n\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13)\n  }\n}\n\nmodule.exports = KanjiData\n","'use strict';\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {};\n\n    // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n    var costs = {};\n    costs[s] = 0;\n\n    // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n    var open = dijkstra.PriorityQueue.make();\n    open.push(s, 0);\n\n    var closest,\n        u, v,\n        cost_of_s_to_u,\n        adjacent_nodes,\n        cost_of_e,\n        cost_of_s_to_u_plus_cost_of_e,\n        cost_of_s_to_v,\n        first_visit;\n    while (!open.empty()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost;\n\n      // Get nodes adjacent to u...\n      adjacent_nodes = graph[u] || {};\n\n      // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n      for (v in adjacent_nodes) {\n        if (adjacent_nodes.hasOwnProperty(v)) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = (typeof costs[v] === 'undefined');\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n            predecessors[v] = u;\n          }\n        }\n      }\n    }\n\n    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n\n  extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n    nodes.reverse();\n    return nodes;\n  },\n\n  find_path: function(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(\n      predecessors, d);\n  },\n\n  /**\n   * A very naive priority queue implementation.\n   */\n  PriorityQueue: {\n    make: function (opts) {\n      var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n      opts = opts || {};\n      for (key in T) {\n        if (T.hasOwnProperty(key)) {\n          t[key] = T[key];\n        }\n      }\n      t.queue = [];\n      t.sorter = opts.sorter || T.default_sorter;\n      return t;\n    },\n\n    default_sorter: function (a, b) {\n      return a.cost - b.cost;\n    },\n\n    /**\n     * Add a new item to the queue and ensure the highest priority element\n     * is at the front of the queue.\n     */\n    push: function (value, cost) {\n      var item = {value: value, cost: cost};\n      this.queue.push(item);\n      this.queue.sort(this.sorter);\n    },\n\n    /**\n     * Return the highest priority element in the queue.\n     */\n    pop: function () {\n      return this.queue.shift();\n    },\n\n    empty: function () {\n      return this.queue.length === 0;\n    }\n  }\n};\n\n\n// node.js module exports\nif (typeof module !== 'undefined') {\n  module.exports = dijkstra;\n}\n","const Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n","const Utils = require('./utils')\nconst ECLevel = require('./error-correction-level')\nconst BitBuffer = require('./bit-buffer')\nconst BitMatrix = require('./bit-matrix')\nconst AlignmentPattern = require('./alignment-pattern')\nconst FinderPattern = require('./finder-pattern')\nconst MaskPattern = require('./mask-pattern')\nconst ECCode = require('./error-correction-code')\nconst ReedSolomonEncoder = require('./reed-solomon-encoder')\nconst Version = require('./version')\nconst FormatInfo = require('./format-info')\nconst Mode = require('./mode')\nconst Segments = require('./segments')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n","function hex2rgba (hex) {\n  if (typeof hex === 'number') {\n    hex = hex.toString()\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  let hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  const hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255,\n    hex: '#' + hexCode.slice(0, 6).join('')\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  const margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0\n    ? 4\n    : options.margin\n\n  const width = options.width && options.width >= 21 ? options.width : undefined\n  const scale = options.scale || 4\n\n  return {\n    width: width,\n    scale: width ? 4 : scale,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.getScale = function getScale (qrSize, opts) {\n  return opts.width && opts.width >= qrSize + opts.margin * 2\n    ? opts.width / (qrSize + opts.margin * 2)\n    : opts.scale\n}\n\nexports.getImageWidth = function getImageWidth (qrSize, opts) {\n  const scale = exports.getScale(qrSize, opts)\n  return Math.floor((qrSize + opts.margin * 2) * scale)\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, opts) {\n  const size = qr.modules.size\n  const data = qr.modules.data\n  const scale = exports.getScale(size, opts)\n  const symbolSize = Math.floor((size + opts.margin * 2) * scale)\n  const scaledMargin = opts.margin * scale\n  const palette = [opts.color.light, opts.color.dark]\n\n  for (let i = 0; i < symbolSize; i++) {\n    for (let j = 0; j < symbolSize; j++) {\n      let posDst = (i * symbolSize + j) * 4\n      let pxColor = opts.color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        const iSrc = Math.floor((i - scaledMargin) / scale)\n        const jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n","const Utils = require('./utils')\n\nfunction clearCanvas (ctx, canvas, size) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (!canvas.style) canvas.style = {}\n  canvas.height = size\n  canvas.width = size\n  canvas.style.height = size + 'px'\n  canvas.style.width = size + 'px'\n}\n\nfunction getCanvasElement () {\n  try {\n    return document.createElement('canvas')\n  } catch (e) {\n    throw new Error('You need to specify a canvas element')\n  }\n}\n\nexports.render = function render (qrData, canvas, options) {\n  let opts = options\n  let canvasEl = canvas\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!canvas) {\n    canvasEl = getCanvasElement()\n  }\n\n  opts = Utils.getOptions(opts)\n  const size = Utils.getImageWidth(qrData.modules.size, opts)\n\n  const ctx = canvasEl.getContext('2d')\n  const image = ctx.createImageData(size, size)\n  Utils.qrToImageData(image.data, qrData, opts)\n\n  clearCanvas(ctx, canvasEl, size)\n  ctx.putImageData(image, 0, 0)\n\n  return canvasEl\n}\n\nexports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {\n  let opts = options\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!opts) opts = {}\n\n  const canvasEl = exports.render(qrData, canvas, opts)\n\n  const type = opts.type || 'image/png'\n  const rendererOpts = opts.rendererOpts || {}\n\n  return canvasEl.toDataURL(type, rendererOpts.quality)\n}\n","const Utils = require('./utils')\n\nfunction getColorAttrib (color, attrib) {\n  const alpha = color.a / 255\n  const str = attrib + '=\"' + color.hex + '\"'\n\n  return alpha < 1\n    ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n    : str\n}\n\nfunction svgCmd (cmd, x, y) {\n  let str = cmd + x\n  if (typeof y !== 'undefined') str += ' ' + y\n\n  return str\n}\n\nfunction qrToPath (data, size, margin) {\n  let path = ''\n  let moveBy = 0\n  let newRow = false\n  let lineLength = 0\n\n  for (let i = 0; i < data.length; i++) {\n    const col = Math.floor(i % size)\n    const row = Math.floor(i / size)\n\n    if (!col && !newRow) newRow = true\n\n    if (data[i]) {\n      lineLength++\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow\n          ? svgCmd('M', col + margin, 0.5 + row + margin)\n          : svgCmd('m', moveBy, 0)\n\n        moveBy = 0\n        newRow = false\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength)\n        lineLength = 0\n      }\n    } else {\n      moveBy++\n    }\n  }\n\n  return path\n}\n\nexports.render = function render (qrData, options, cb) {\n  const opts = Utils.getOptions(options)\n  const size = qrData.modules.size\n  const data = qrData.modules.data\n  const qrcodesize = size + opts.margin * 2\n\n  const bg = !opts.color.light.a\n    ? ''\n    : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n      ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>'\n\n  const path =\n    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n    ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>'\n\n  const viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"'\n\n  const width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" '\n\n  const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n'\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag)\n  }\n\n  return svgTag\n}\n","\nconst canPromise = require('./can-promise')\n\nconst QRCode = require('./core/qrcode')\nconst CanvasRenderer = require('./renderer/canvas')\nconst SvgRenderer = require('./renderer/svg-tag.js')\n\nfunction renderCanvas (renderFunc, canvas, text, opts, cb) {\n  const args = [].slice.call(arguments, 1)\n  const argsNum = args.length\n  const isLastArgCb = typeof args[argsNum - 1] === 'function'\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument')\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 2) {\n      cb = text\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts\n        opts = undefined\n      } else {\n        cb = opts\n        opts = text\n        text = canvas\n        canvas = undefined\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 1) {\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text\n      text = canvas\n      canvas = undefined\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        const data = QRCode.create(text, opts)\n        resolve(renderFunc(data, canvas, opts))\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  try {\n    const data = QRCode.create(text, opts)\n    cb(null, renderFunc(data, canvas, opts))\n  } catch (e) {\n    cb(e)\n  }\n}\n\nexports.create = QRCode.create\nexports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)\nexports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)\n\n// only svg for now.\nexports.toString = renderCanvas.bind(null, function (data, _, opts) {\n  return SvgRenderer.render(data, opts)\n})\n","import QRCode from \"qrcode\";\n\nasync function loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(e);\n    img.src = src;\n  });\n}\n\nexport type QrLogoOptions = {\n  logoUrl: string;\n  // Fraction of the QR's min(width,height) for the logo box. 0.18-0.24 is typical.\n  logoScale?: number;\n  // Add a white rounded mask under the logo to preserve scan contrast\n  mask?: boolean;\n  // Outline color for the mask box\n  maskStroke?: string;\n  // Corner radius for mask box\n  radiusPx?: number;\n  // Shape of the logo area: 'circle' | 'rounded-rect' | 'rect'\n  shape?: \"circle\" | \"rounded-rect\" | \"rect\";\n};\n\nexport async function composeQrWithLogo(\n  qrDataUrl: string,\n  opts: QrLogoOptions,\n): Promise<string> {\n  const [qrImg, logoImg] = await Promise.all([\n    loadImage(qrDataUrl),\n    loadImage(opts.logoUrl),\n  ]);\n  const w = Math.max(160, qrImg.width || 160);\n  const h = Math.max(160, qrImg.height || 160);\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = w;\n  canvas.height = h;\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.fillStyle = \"#ffffff\";\n  ctx.fillRect(0, 0, w, h);\n  // Draw QR without smoothing to keep it crisp\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(qrImg, 0, 0, w, h);\n\n  const cx = w / 2;\n  const cy = h / 2;\n  const scale = Math.max(0.14, Math.min(0.28, opts.logoScale ?? 0.2));\n  const logoSize = Math.round(Math.min(w, h) * scale);\n  const x = Math.round(cx - logoSize / 2);\n  const y = Math.round(cy - logoSize / 2);\n\n  if (opts.mask !== false) {\n    const shape = opts.shape || \"rounded-rect\";\n    const pad = Math.max(2, Math.round(logoSize * 0.08));\n    const bx = x - pad;\n    const by = y - pad;\n    const bw = logoSize + pad * 2;\n    const bh = logoSize + pad * 2;\n    ctx.beginPath();\n    if (shape === \"circle\") {\n      const r = Math.min(bw, bh) / 2;\n      ctx.arc(bx + bw / 2, by + bh / 2, r, 0, Math.PI * 2);\n    } else if (shape === \"rect\") {\n      ctx.rect(bx, by, bw, bh);\n    } else {\n      const radius = Math.max(4, opts.radiusPx ?? Math.round(logoSize * 0.12));\n      const r = Math.min(radius, bw / 2, bh / 2);\n      ctx.moveTo(bx + r, by);\n      ctx.arcTo(bx + bw, by, bx + bw, by + bh, r);\n      ctx.arcTo(bx + bw, by + bh, bx, by + bh, r);\n      ctx.arcTo(bx, by + bh, bx, by, r);\n      ctx.arcTo(bx, by, bx + bw, by, r);\n      ctx.closePath();\n    }\n    // Fill white mask\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fill();\n    // Optional subtle stroke to separate from modules\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = opts.maskStroke || \"rgba(0,0,0,0.12)\";\n    ctx.stroke();\n  }\n\n  // Draw the logo centered (clip to shape if circle desired)\n  ctx.save();\n  if (opts.shape === \"circle\") {\n    const r = logoSize / 2;\n    ctx.beginPath();\n    ctx.arc(x + r, y + r, r, 0, Math.PI * 2);\n    ctx.clip();\n  }\n  ctx.imageSmoothingEnabled = true;\n  ctx.drawImage(logoImg, x, y, logoSize, logoSize);\n  ctx.restore();\n  return canvas.toDataURL(\"image/png\");\n}\n\nexport type MakeQrOptions = {\n  width?: number;\n  margin?: number;\n  errorCorrectionLevel?: \"L\" | \"M\" | \"Q\" | \"H\";\n  color?: { dark?: string; light?: string };\n  logo?: QrLogoOptions | false;\n};\n\nexport async function makeQrDataUrlWithLogo(\n  text: string,\n  options: MakeQrOptions,\n): Promise<string> {\n  const {\n    width = 256,\n    margin = 2,\n    errorCorrectionLevel = \"H\",\n    color = { dark: \"#000000\", light: \"#ffffff\" },\n    logo,\n  } = options || {};\n  const base = await QRCode.toDataURL(text, {\n    width,\n    margin,\n    errorCorrectionLevel,\n    color,\n  });\n  if (!logo) return base;\n  return composeQrWithLogo(base, logo);\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { useCalibration } from \"../store/calibration\";\nimport { useCameraSession } from \"../store/cameraSession\";\nimport {\n  BoardRadii,\n  CalibrationGuideRadii,\n  canonicalRimTargets,\n  computeHomographyDLT,\n  drawCross,\n  drawPolyline,\n  rmsError,\n  sampleRing,\n  refinePointsSobel,\n  applyHomography,\n  imageToBoard,\n  scoreAtBoardPoint,\n  scoreAtBoardPointTheta,\n  scaleHomography,\n  rotateHomography,\n  matMul3,\n  SectorOrder,\n  estimateSectorOffsetFromHomography,\n  type Homography,\n  type Point,\n} from \"../utils/vision\";\nimport {\n  detectMarkersFromCanvas,\n  MARKER_TARGETS,\n  markerIdToMatrix,\n  type MarkerDetection,\n} from \"../utils/markerCalibration\";\nimport {\n  detectBoard,\n  refineRingDetection,\n  type BoardDetectionResult,\n} from \"../utils/boardDetection\";\nimport { useUserSettings } from \"../store/userSettings\";\nimport {\n  discoverNetworkDevices,\n  connectToNetworkDevice,\n  type NetworkDevice,\n} from \"../utils/networkDevices\";\nimport { apiFetch } from \"../utils/api\";\nimport { useMatch } from \"../store/match\";\nimport { useWS } from \"./WSProvider\";\nimport { makeQrDataUrlWithLogo } from \"../utils/qr\";\n\ndeclare const DROPDOWN_DEBUG: boolean | undefined;\nconst isTestEnv =\n  process.env.NODE_ENV === \"test\" ||\n  (typeof import.meta !== \"undefined\" && import.meta.env?.MODE === \"test\");\n\ntype Phase = \"idle\" | \"camera\" | \"capture\" | \"select\" | \"verify\" | \"computed\";\ntype CamMode = \"local\" | \"phone\" | \"wifi\";\n\ntype DevicePickerProps = {\n  videoDevices: Array<{ deviceId: string; label: string }>;\n  streaming: boolean;\n  refreshVideoDevices: () => Promise<void>;\n  testCamera: (deviceId?: string) => Promise<void>;\n  onSelectPhoneCamera: () => void;\n  lastDetectedLabel: string | null;\n  autoCommitTestMode: boolean;\n  doCommit: () => void;\n  lastDetectedValue: number | null;\n  cameraConnected: boolean;\n};\n\nconst DevicePicker: React.FC<DevicePickerProps> = ({\n  videoDevices,\n  streaming,\n  refreshVideoDevices,\n  testCamera,\n  onSelectPhoneCamera,\n  lastDetectedLabel,\n  autoCommitTestMode,\n  doCommit,\n  lastDetectedValue,\n  cameraConnected,\n}) => {\n  const {\n    preferredCameraId,\n    preferredCameraLabel,\n    setPreferredCamera,\n    cameraEnabled,\n    setCameraEnabled,\n    preferredCameraLocked,\n    setPreferredCameraLocked,\n  } = useUserSettings();\n\n  const [err, setErr] = useState<string>(\"\");\n  const [dropdownOpen, setDropdownOpen] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement | null>(null);\n\n  const handleRefreshDevices = useCallback(async () => {\n    setErr(\"\");\n    try {\n      await refreshVideoDevices();\n    } catch (e) {\n      console.warn(\"[DevicePicker] refresh failed\", e);\n      setErr(\n        \"Unable to list cameras. Grant camera permission in your browser.\",\n      );\n    }\n  }, [refreshVideoDevices]);\n\n  useEffect(() => {\n    if (isTestEnv) return;\n    void handleRefreshDevices();\n  }, [handleRefreshDevices]);\n\n  useEffect(() => {\n    if (!dropdownOpen) return;\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropdownRef.current &&\n        !dropdownRef.current.contains(event.target as Node)\n      ) {\n        console.debug(\n          \"[DevicePicker] document.mousedown -> closing dropdown (outside both main+portal)\",\n          Date.now(),\n        );\n        setDropdownOpen(false);\n      }\n    }\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [dropdownOpen]);\n\n  const selectedDevice = videoDevices.find(\n    (d) => d.deviceId === preferredCameraId,\n  );\n  const selectedLabel = selectedDevice\n    ? `${selectedDevice.label || \"Camera\"}`\n    : preferredCameraId\n      ? \"Camera (unavailable)\"\n      : \"Auto (browser default)\";\n  const preferredCameraUnavailable = Boolean(\n    preferredCameraId && !selectedDevice,\n  );\n\n  const handleSelectCamera = useCallback(\n    (deviceId: string | undefined, label = \"\") => {\n      try {\n        setPreferredCamera(deviceId, label, true);\n      } catch (err) {\n        console.warn(\"[DevicePicker] setPreferredCamera failed\", err);\n      }\n      setDropdownOpen(false);\n    },\n    [setPreferredCamera],\n  );\n\n  const handlePhoneCamera = useCallback(() => {\n    handleSelectCamera(undefined, \"Phone Camera\");\n    onSelectPhoneCamera();\n  }, [handleSelectCamera, onSelectPhoneCamera]);\n\n  const handleLockToggle = useCallback(() => {\n    setPreferredCameraLocked(!preferredCameraLocked);\n  }, [preferredCameraLocked, setPreferredCameraLocked]);\n\n  return (\n    <div\n      ref={dropdownRef}\n      className=\"mt-3 rounded-lg border border-indigo-500/30 bg-indigo-500/5 p-3\"\n      data-testid=\"device-picker-root\"\n    >\n      <div className=\"mb-2 font-semibold\">Select camera device</div>\n      {err && <div className=\"mb-2 text-sm text-rose-400\">{err}</div>}\n      {videoDevices.length === 0 && !err && (\n        <div className=\"mb-2 text-xs text-slate-400\">\n          Detecting devices... (click \"Rescan\" if this hangs)\n        </div>\n      )}\n      {preferredCameraUnavailable && (\n        <div className=\"mb-2 text-sm text-amber-400\">\n          Selected camera is no longer available.\n          <button\n            className=\"ml-1 underline\"\n            onClick={() => handleSelectCamera(undefined, \"\")}\n            disabled={streaming}\n          >\n            Use auto-selection\n          </button>\n        </div>\n      )}\n      <div className=\"mb-2 flex items-center gap-2\">\n        {preferredCameraLocked ? (\n          <div className=\"text-xs text-emerald-400\">\n            🔒 Camera selection locked\n          </div>\n        ) : (\n          <div className=\"text-xs text-slate-400\">\n            Camera selection unlocked\n          </div>\n        )}\n        <button\n          data-testid=\"cam-lock-toggle\"\n          className=\"btn btn--ghost ml-2 px-2 py-0.5 text-xs\"\n          onClick={handleLockToggle}\n        >\n          {preferredCameraLocked ? \"Unlock\" : \"Lock\"}\n        </button>\n      </div>\n      <div className=\"mb-3 flex items-center gap-3\">\n        <input\n          type=\"checkbox\"\n          id=\"cameraEnabled-calibrator\"\n          checked={cameraEnabled}\n          onChange={(e) => setCameraEnabled(e.target.checked)}\n          className=\"h-4 w-4\"\n          disabled={streaming}\n        />\n        <label htmlFor=\"cameraEnabled-calibrator\" className=\"text-sm\">\n          Enable camera for scoring\n        </label>\n      </div>\n      <div className=\"grid grid-cols-3 items-center gap-2 text-sm\">\n        <div className=\"relative col-span-2\">\n          <button\n            className=\"input flex w-full items-center justify-between text-left\"\n            data-testid=\"device-picker-toggle\"\n            onClick={() => setDropdownOpen(true)}\n            onPointerDown={(e) => e.stopPropagation()}\n            onMouseDown={(e) => e.stopPropagation()}\n          >\n            <span>{selectedLabel}</span>\n            <span\n              className={`transition-transform ${\n                dropdownOpen ? \"rotate-180\" : \"\"\n              }`}\n            >\n              ▼\n            </span>\n          </button>\n          {dropdownOpen && (\n            <div className=\"absolute left-0 right-0 top-full z-50 mt-1 rounded border border-slate-600 bg-slate-800 shadow-lg\">\n              <div className=\"max-h-48 overflow-y-auto\">\n                <button\n                  data-testid=\"device-option-auto\"\n                  className=\"w-full px-3 py-2 text-left text-sm hover:bg-slate-700\"\n                  onClick={() => handleSelectCamera(undefined, \"\")}\n                  onPointerDown={(e) => e.stopPropagation()}\n                  onMouseDown={(e) => e.stopPropagation()}\n                >\n                  Auto (browser default)\n                </button>\n                {videoDevices.map((device) => (\n                  <button\n                    key={device.deviceId}\n                    className=\"w-full px-3 py-2 text-left text-sm hover:bg-slate-700\"\n                    onClick={() =>\n                      handleSelectCamera(device.deviceId, device.label || \"\")\n                    }\n                    onPointerDown={(e) => e.stopPropagation()}\n                    onMouseDown={(e) => e.stopPropagation()}\n                  >\n                    {device.label || \"Camera\"}\n                  </button>\n                ))}\n                <button\n                  className=\"w-full px-3 py-2 text-left text-sm hover:bg-slate-700\"\n                  onClick={handlePhoneCamera}\n                  onPointerDown={(e) => e.stopPropagation()}\n                  onMouseDown={(e) => e.stopPropagation()}\n                >\n                  📱 Remote Device / Pair\n                </button>\n              </div>\n            </div>\n          )}\n        </div>\n        {videoDevices.length === 0 && (\n          <div className=\"col-span-1 flex items-center justify-end gap-2\">\n            <button\n              className=\"btn btn--ghost btn-sm\"\n              onClick={async () => {\n                try {\n                  await testCamera();\n                  await refreshVideoDevices();\n                } catch (err) {\n                  console.warn(\n                    \"[DevicePicker] request camera permission failed\",\n                    err,\n                  );\n                  setErr(\n                    \"Camera permission denied. Please allow access in your browser.\",\n                  );\n                }\n              }}\n            >\n              Enable local camera\n            </button>\n            <button\n              className=\"btn btn--ghost btn-sm\"\n              onClick={() => void handleRefreshDevices()}\n            >\n              Rescan\n            </button>\n          </div>\n        )}\n        <div className=\"col-span-3 text-right\">\n          <button\n            className=\"btn px-2 py-1\"\n            onClick={() => {\n              void testCamera(preferredCameraId || undefined);\n            }}\n            disabled={streaming}\n          >\n            Test\n          </button>\n          <div className=\"mt-2 flex items-center justify-end gap-2 text-xs opacity-70\">\n            <span data-testid=\"device-picker-detected\">\n              {lastDetectedLabel\n                ? `Detected: ${lastDetectedLabel}`\n                : \"No recent detection\"}\n            </span>\n            {(lastDetectedLabel != null || autoCommitTestMode) && (\n              <button\n                className=\"btn btn--ghost btn-sm\"\n                onClick={() => doCommit()}\n                onPointerDown={() => doCommit()}\n                disabled={lastDetectedValue == null}\n              >\n                Commit detected\n              </button>\n            )}\n            <span\n              className={`inline-block h-2.5 w-2.5 rounded-full ${\n                cameraConnected ? \"bg-emerald-400\" : \"bg-rose-500\"\n              }`}\n            />\n            <span className=\"text-xs\">\n              {cameraConnected ? \"Camera Connected\" : \"Camera not connected\"}\n            </span>\n          </div>\n        </div>\n      </div>\n      {preferredCameraLabel && (\n        <div className=\"mt-1 text-xs opacity-70\">\n          Selected: {preferredCameraLabel}\n        </div>\n      )}\n      <div className=\"mt-1 text-xs opacity-70\">\n        Tip: Select a camera here for manual scoring.\n      </div>\n    </div>\n  );\n};\n\nconst CALIBRATION_POINT_LABELS = [\"D20\", \"D6\", \"D3\", \"D11\", \"BULL\"] as const;\nconst REQUIRED_POINT_COUNT = CALIBRATION_POINT_LABELS.length;\ntype TestAutoDetectResult = {\n  H: Homography;\n  errorPx: number | null;\n  imageSize: { w: number; h: number };\n  overlaySize: { w: number; h: number };\n  anchors: { src: Point[]; dst: Point[] };\n  locked: boolean;\n  confidence: number;\n  phase?: Phase;\n};\n\ntype ScoreInfo = ReturnType<typeof scoreAtBoardPoint>;\n\ntype VerificationResult = {\n  label: string;\n  expected: { ring: ScoreInfo[\"ring\"]; sector: number | null };\n  detected: ScoreInfo | null;\n  deltaMm: number | null;\n  deltaPx: number | null;\n  match: boolean;\n  note?: string;\n};\n\nconst VERIFICATION_ANCHORS: Array<{\n  idx: number;\n  label: string;\n  sector: number | null;\n  ring: ScoreInfo[\"ring\"];\n  toleranceMm: number;\n}> = [\n  {\n    idx: 0,\n    label: \"D20 (top double)\",\n    sector: 20,\n    ring: \"DOUBLE\",\n    toleranceMm: 4.5,\n  },\n  {\n    idx: 1,\n    label: \"D6 (right double)\",\n    sector: 6,\n    ring: \"DOUBLE\",\n    toleranceMm: 4.5,\n  },\n  {\n    idx: 2,\n    label: \"D3 (bottom double)\",\n    sector: 3,\n    ring: \"DOUBLE\",\n    toleranceMm: 4.5,\n  },\n  {\n    idx: 3,\n    label: \"D11 (left double)\",\n    sector: 11,\n    ring: \"DOUBLE\",\n    toleranceMm: 4.5,\n  },\n  {\n    idx: 4,\n    label: \"Bull center\",\n    sector: 25,\n    ring: \"INNER_BULL\",\n    toleranceMm: 3.5,\n  },\n];\n\nfunction describeScoreTarget(ring: ScoreInfo[\"ring\"], sector: number | null) {\n  if (ring === \"INNER_BULL\") return \"Inner Bull (50)\";\n  if (ring === \"BULL\") return \"Outer Bull (25)\";\n  if (ring === \"MISS\" || sector == null) return ring === \"MISS\" ? \"Miss\" : ring;\n  const prefix =\n    ring === \"DOUBLE\" ? \"Double\" : ring === \"TRIPLE\" ? \"Triple\" : \"Single\";\n  return `${prefix} ${sector}`;\n}\n\nfunction formatScoreLabel(score: ScoreInfo | null) {\n  return score ? describeScoreTarget(score.ring, score.sector) : \"—\";\n}\n\nfunction translateHomography(\n  H: Homography,\n  tx: number,\n  ty: number,\n): Homography {\n  // Compose translation matrix T = [1 0 tx; 0 1 ty; 0 0 1]\n  const T: Homography = [1, 0, tx, 0, 1, ty, 0, 0, 1];\n  return matMul3(H, T); // H * T - apply translation after main transform\n}\n\n// Center-logo QR helpers moved to ../utils/qr\n\nexport default function Calibrator() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const overlayRef = useRef<HTMLCanvasElement>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  // Camera diagnostics state\n  const [cameraPerm, setCameraPerm] = useState<\n    \"unknown\" | \"granted\" | \"denied\" | \"prompt\" | \"unsupported\"\n  >(\"unknown\");\n  const [videoDevices, setVideoDevices] = useState<\n    Array<{ deviceId: string; label: string }>\n  >([]);\n  const [selectedDeviceId, setSelectedDeviceId] = useState<string | null>(null);\n  const [streaming, setStreaming] = useState(false);\n  const [videoPlayBlocked, setVideoPlayBlocked] = useState(false);\n  // Default to local or last-used mode, but allow user to freely change\n  const [mode, setMode] = useState<CamMode>(\n    () => (localStorage.getItem(\"ndn:cal:mode\") as CamMode) || \"local\",\n  );\n  const [dstPoints, setDstPoints] = useState<Point[]>([]); // image points clicked in order D20 (top), D6 (right), D3 (bottom), D11 (left)\n  const [hasSnapshot, setHasSnapshot] = useState(false);\n  const [phase, setPhase] = useState<Phase>(\"idle\");\n  const handleSelectPhoneCamera = useCallback(() => {\n    setMode(\"phone\");\n    setPhase(\"camera\");\n    setStreaming(false);\n    setHasSnapshot(false);\n    // Persist phone camera selection globally so it is used in game modes\n    try {\n      useUserSettings\n        .getState()\n        .setPreferredCamera(undefined, \"Phone Camera\", true);\n    } catch (e) {\n      console.warn(\n        \"[Camera Connection] Failed to persist phone camera selection\",\n        e,\n      );\n    }\n  }, [setMode, setPhase, setStreaming, setHasSnapshot]);\n  // Track current frame (video/snapshot) size to preserve aspect ratio in the preview container\n  const [frameSize, setFrameSize] = useState<{ w: number; h: number } | null>(\n    null,\n  );\n  // Zoom for pixel-perfect point picking (0.5x – 2.0x)\n  // const [zoom, setZoom] = useState<number>(1);\n  // Use global camera scale setting so it persists across game modes\n  const zoom = useUserSettings((s) => s.cameraScale) || 1;\n  const setZoom = useUserSettings((s) => s.setCameraScale);\n  const [mobileLandingOverride, setMobileLandingOverride] = useState<boolean>(\n    () => {\n      if (typeof window === \"undefined\") return false;\n      try {\n        return window.localStorage.getItem(\"ndn:cal:forceDesktop\") === \"1\";\n      } catch {\n        return false;\n      }\n    },\n  );\n  const [isMobileDevice, setIsMobileDevice] = useState<boolean>(() => {\n    if (typeof navigator === \"undefined\") return false;\n    return /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);\n  });\n  const {\n    H,\n    setCalibration,\n    reset,\n    errorPx,\n    locked,\n    overlaySize,\n    imageSize,\n    anchors,\n    theta,\n    sectorOffset,\n  } = useCalibration();\n  const ERROR_PX_MAX = 6;\n  const calibrationValid =\n    !!H &&\n    !!imageSize &&\n    (locked || (typeof errorPx === \"number\" && errorPx <= ERROR_PX_MAX));\n  const cameraSession = useCameraSession();\n  const {\n    calibrationGuide,\n    setCalibrationGuide,\n    preferredCameraId,\n    cameraEnabled,\n    setCameraEnabled,\n    preferredCameraLocked,\n    setPreferredCameraLocked,\n    setPreferredCamera,\n    preserveCalibrationOverlay,\n    allowAutocommitInOnline,\n    setAllowAutocommitInOnline,\n  } = useUserSettings();\n\n  const manualOnly = true;\n  // Detected ring data (from auto-detect) in image pixels\n  const [detected, setDetected] = useState<null | {\n    cx: number;\n    cy: number;\n    bullInner: number;\n    bullOuter: number;\n    trebleInner: number;\n    trebleOuter: number;\n    doubleInner: number;\n    doubleOuter: number;\n  }>(null);\n  // Live detection and confidence state\n  const [liveDetect, setLiveDetect] = useState<boolean>(false);\n  const [confidence, setConfidence] = useState<number>(0);\n  const [autoCalibrating, setAutoCalibrating] = useState<boolean>(false);\n  const [detectionMessage, setDetectionMessage] = useState<string | null>(null);\n  const [forceConfidence, setForceConfidence] = useState<boolean>(true); // Allow forcing 100% for registration reliability\n  const [markerResult, setMarkerResult] = useState<MarkerDetection | null>(\n    null,\n  );\n  const [showDartPreview, setShowDartPreview] = useState<boolean>(false);\n  const [autoCommitTestMode, setAutoCommitTestMode] = useState<boolean>(false);\n  const [autoCommitImmediate, setAutoCommitImmediate] =\n    useState<boolean>(false);\n  const [lastDetectedValue, setLastDetectedValue] = useState<number | null>(\n    null,\n  );\n  const [lastDetectedLabel, setLastDetectedLabel] = useState<string | null>(\n    null,\n  );\n  // Optional hint: a one-click bull can anchor the center for auto-calibration\n  const [bullHint, setBullHint] = useState<Point | null>(null);\n  const [toolsPopoverOpen, setToolsPopoverOpen] = useState<boolean>(false);\n  const dartDetectorRef = useRef<DartDetector | null>(null);\n\n  // Simple nudge controls for sector offset to resolve whole-sector mismatches quickly\n  const nudgeSectorOffset = useCallback(\n    (delta: number) => {\n      const next = (sectorOffset ?? 0) + delta;\n      setCalibration({ sectorOffset: next });\n    },\n    [sectorOffset, setCalibration],\n  );\n  const inFlightAutoCommitRef = useRef<boolean>(false);\n  const lastAutoSigRef = useRef<string | null>(null);\n  const lastAutoSigAtRef = useRef<number>(0);\n  const AUTO_COMMIT_COOLDOWN_MS = 300;\n  // Verification results for UI: {label, expected, detected, match}\n  const [verificationResults, setVerificationResults] = useState<\n    VerificationResult[]\n  >([]);\n  // PASS/FAIL flash badge state\n  const [flashStatus, setFlashStatus] = useState<{\n    type: \"pass\" | \"fail\" | null;\n    until: number;\n  }>({ type: null, until: 0 });\n\n  // Fine-tune correction parameters for pixel-perfect alignment\n  const [correctionSx, setCorrectionSx] = useState<number>(1.0);\n  const [correctionTx, setCorrectionTx] = useState<number>(0);\n  const [correctionTy, setCorrectionTy] = useState<number>(0);\n  // Debug overlay for detected rings\n  const [showDetectedOverlay, setShowDetectedOverlay] =\n    useState<boolean>(false);\n  const [forceDetectedOnly, setForceDetectedOnly] = useState<boolean>(false);\n  const [doubleOuterAdjust, setDoubleOuterAdjust] = useState<number>(1.0);\n  const [trebleOuterAdjust, setTrebleOuterAdjust] = useState<number>(1.0);\n  const [aligningRing, setAligningRing] = useState<\n    null | \"double\" | \"treble\" | \"bull\"\n  >(null);\n  function resetVisualAdjustments() {\n    setDoubleOuterAdjust(1.02);\n    setTrebleOuterAdjust(1.0);\n    setCorrectionSx(1.0);\n    setCorrectionTx(0);\n    setCorrectionTy(0);\n    setForceDetectedOnly(false);\n    setAligningRing(null);\n  }\n\n  function triggerFlash(pass: boolean, durationMs = 1500) {\n    setFlashStatus({\n      type: pass ? \"pass\" : \"fail\",\n      until: Date.now() + durationMs,\n    });\n  }\n\n  const createMarkerDataUrl = useCallback((id: number, size = 480) => {\n    if (typeof document === \"undefined\")\n      throw new Error(\"Marker rendering only available in browser context\");\n    const matrix = markerIdToMatrix(id);\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = size;\n    canvas.height = size;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return \"\";\n    // white background\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillRect(0, 0, size, size);\n\n    const rows = matrix.length;\n    const cols = matrix[0]?.length || rows;\n    const cellW = size / cols;\n    const cellH = size / rows;\n\n    for (let y = 0; y < rows; y++) {\n      for (let x = 0; x < cols; x++) {\n        const v = matrix[y][x];\n        if (v) {\n          ctx.fillStyle = \"#000000\";\n          ctx.fillRect(\n            Math.round(x * cellW),\n            Math.round(y * cellH),\n            Math.ceil(cellW),\n            Math.ceil(cellH),\n          );\n        }\n      }\n    }\n\n    return canvas.toDataURL(\"image/png\");\n  }, []);\n  // QR code data URL for phone pairing\n  const [qrDataUrl, setQrDataUrl] = useState<string | null>(null);\n  // Pairing / phone-camera state (some of these were accidentally removed during edits)\n  const [pairCode, setPairCode] = useState<string | null>(null);\n  const pairCodeRef = useRef<string | null>(null);\n  const [ws, setWs] = useState<WebSocket | null>(null);\n  const pcRef = useRef<RTCPeerConnection | null>(null);\n  const pendingIceCandidatesRef = useRef<RTCIceCandidate[]>([]);\n  const [expiresAt, setExpiresAt] = useState<number | null>(null);\n  const [now, setNow] = useState<number>(Date.now());\n  const [paired, setPaired] = useState<boolean>(false);\n\n  function updatePairCode(code: string | null) {\n    try {\n      setPairCode(code);\n      pairCodeRef.current = code;\n    } catch (e) {}\n  }\n  const [lanHost, setLanHost] = useState<string | null>(null);\n  const [httpsInfo, setHttpsInfo] = useState<{\n    https: boolean;\n    port: number;\n  } | null>(null);\n  const [showTips, setShowTips] = useState<boolean>(true);\n  const [wifiDevices, setWifiDevices] = useState<NetworkDevice[]>([]);\n  const [discoveringWifi, setDiscoveringWifi] = useState<boolean>(false);\n  const [copyFeedback, setCopyFeedback] = useState<\"link\" | \"code\" | null>(\n    null,\n  );\n  const copyTimeoutRef = useRef<number | null>(null);\n\n  // Log streaming state changes for debugging\n  useEffect(() => {\n    if (isTestEnv) return;\n    let interval: number | null = null;\n    if (\n      !manualOnly &&\n      showDartPreview &&\n      streaming &&\n      videoRef.current &&\n      overlayRef.current\n    ) {\n      // Initialize detector\n      try {\n        const video = videoRef.current! as HTMLVideoElement;\n        const det = new DartDetector({\n          requireStableN: 2,\n          thresh: 18,\n          minArea: 40,\n        });\n        const w =\n          video.videoWidth || (videoRef.current as any).clientWidth || 640;\n        const h =\n          video.videoHeight || (videoRef.current as any).clientHeight || 480;\n        det.reset(w, h);\n        // Set ROI roughly to the full board if we have detection\n        if (detected) {\n          const r = Math.max(\n            detected.doubleOuter * 1.1,\n            detected.trebleOuter * 1.1,\n          );\n          det.setROI(detected.cx, detected.cy, Math.round(r));\n        }\n        dartDetectorRef.current = det;\n        interval = window.setInterval(() => {\n          try {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = w;\n            canvas.height = h;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) return;\n            ctx.drawImage(video, 0, 0, w, h);\n            const img = ctx.getImageData(0, 0, w, h);\n            // feed background model\n            det.updateBackground(img);\n            const d = det.detect(img);\n            const overlay = overlayRef.current! as HTMLCanvasElement;\n            const octx = overlay.getContext(\"2d\");\n            if (!octx) return;\n            octx.clearRect(0, 0, overlay.width, overlay.height);\n            // overlay is same size as canvas/image\n            if (d) {\n              try {\n                // Map to calibration space and extract score\n                if (H && imageSize) {\n                  const pImg = { x: d.tip.x, y: d.tip.y };\n                  // convert canvas coords to calibration image space\n                  const fallbackWidth =\n                    (overlayRef.current && overlayRef.current.width) ||\n                    imageSize.w ||\n                    1;\n                  const fallbackHeight =\n                    (overlayRef.current && overlayRef.current.height) ||\n                    imageSize.h ||\n                    1;\n                  const pCal = {\n                    x: pImg.x / (fallbackWidth / imageSize.w),\n                    y: pImg.y / (fallbackHeight / imageSize.h),\n                  };\n                  const detectedBoard = imageToBoard(H as any, pCal);\n                  const scoreObj = detectedBoard\n                    ? scoreAtBoardPointTheta(\n                        detectedBoard,\n                        typeof theta === \"number\" ? theta : 0,\n                        sectorOffset ?? 0,\n                      )\n                    : {\n                        base: 0,\n                        ring: \"MISS\" as const,\n                        sector: null,\n                        mult: 0 as const,\n                      };\n                  const val = scoreObj.base;\n                  const label = `${scoreObj.ring} ${val}`.trim();\n                  const ERROR_PX_MAX = 6;\n                  const TIP_MARGIN_PX = 3;\n                  const PCAL_MARGIN_PX = 3;\n                  const cameraGood =\n                    !!H &&\n                    !!imageSize &&\n                    (locked ||\n                      (typeof errorPx === \"number\" && errorPx <= ERROR_PX_MAX));\n                  const tipInVideo =\n                    d.tip.x >= -TIP_MARGIN_PX &&\n                    d.tip.x <= fallbackWidth + TIP_MARGIN_PX &&\n                    d.tip.y >= -TIP_MARGIN_PX &&\n                    d.tip.y <= fallbackHeight + TIP_MARGIN_PX;\n                  const pCalInImage =\n                    pCal.x >= -PCAL_MARGIN_PX &&\n                    pCal.x <= imageSize.w + PCAL_MARGIN_PX &&\n                    pCal.y >= -PCAL_MARGIN_PX &&\n                    pCal.y <= imageSize.h + PCAL_MARGIN_PX;\n                  let onBoard = false;\n                  const pBoard = imageToBoard(H as any, pCal);\n                  if (pBoard) {\n                    const boardR = Math.hypot(pBoard.x, pBoard.y);\n                    const BOARD_MARGIN_MM = 3;\n                    onBoard =\n                      boardR <= BoardRadii.doubleOuter + BOARD_MARGIN_MM;\n                  }\n                  if (!cameraGood || !tipInVideo || !pCalInImage || !onBoard) {\n                    // ignore ghost detection\n                    console.debug(\n                      \"Calibrator: ignoring ghost preview detection\",\n                      cameraGood,\n                      tipInVideo,\n                      pCalInImage,\n                    );\n                  } else {\n                    setLastDetectedValue(val);\n                    setLastDetectedLabel(label);\n                    try {\n                      if (\n                        autoCommitTestMode &&\n                        autoCommitImmediate &&\n                        useMatch.getState().inProgress &&\n                        useMatch.getState().roomId === \"\"\n                      ) {\n                        // commit as offline match visit (3 darts) with dedupe/cooldown to avoid double commits\n                        const sig = `${val}|3`;\n                        const now = performance.now();\n                        if (\n                          !inFlightAutoCommitRef.current &&\n                          !(\n                            sig === lastAutoSigRef.current &&\n                            now - lastAutoSigAtRef.current <\n                              AUTO_COMMIT_COOLDOWN_MS\n                          )\n                        ) {\n                          lastAutoSigRef.current = sig;\n                          lastAutoSigAtRef.current = now;\n                          inFlightAutoCommitRef.current = true;\n                          try {\n                            useMatch\n                              .getState()\n                              .addVisit(val, 3, { visitTotal: val });\n                          } catch (e) {}\n                          try {\n                            window.setTimeout(\n                              () => {\n                                inFlightAutoCommitRef.current = false;\n                              },\n                              Math.max(120, AUTO_COMMIT_COOLDOWN_MS),\n                            );\n                          } catch (e) {}\n                        }\n                      }\n                    } catch (e) {\n                      // ignore commit errors in preview\n                    }\n                    // For online autocommit in test mode, send the message if allowed\n                    try {\n                      const isOnline = useMatch.getState().roomId !== \"\";\n                      if (\n                        autoCommitTestMode &&\n                        autoCommitImmediate &&\n                        useMatch.getState().inProgress &&\n                        isOnline &&\n                        allowAutocommitInOnline\n                      ) {\n                        const pBoard = imageToBoard(H as any, pCal);\n                        if (pBoard) {\n                          useWS().send({\n                            type: \"auto-visit\",\n                            roomId: useMatch.getState().roomId,\n                            value: val,\n                            darts: 3,\n                            ring: scoreObj.ring,\n                            sector: scoreObj.sector,\n                            pBoard,\n                            calibrationValid: true,\n                          });\n                        }\n                      }\n                    } catch (e) {\n                      // ignore online commit errors in preview\n                    }\n                  }\n                }\n              } catch (err) {\n                // ignore detection mapping errors\n              }\n              octx.fillStyle = \"rgba(0,255,0,0.9)\";\n              octx.beginPath();\n              octx.arc(d.tip.x, d.tip.y, 6, 0, Math.PI * 2);\n              octx.fill();\n              // draw axis\n              octx.strokeStyle = \"rgba(0,255,0,0.8)\";\n              octx.lineWidth = 2;\n              if (d.axis) {\n                octx.beginPath();\n                octx.moveTo(d.axis.x1, d.axis.y1);\n                octx.lineTo(d.axis.x2, d.axis.y2);\n                octx.stroke();\n              }\n            }\n          } catch (err) {\n            // ignore animation errors\n          }\n        }, 300);\n      } catch (err) {\n        console.warn(\"[Camera Connection] failed to start dart preview\", err);\n      }\n    }\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n      dartDetectorRef.current = null;\n    };\n  }, [manualOnly, showDartPreview, streaming, detected]);\n\n  useEffect(() => {\n    if (isTestEnv) return;\n    const h = window.location.hostname;\n    if (h === \"localhost\" || h === \"127.0.0.1\") {\n      apiFetch(`/api/hosts`)\n        .then((r) => r.json())\n        .then((j) => {\n          const ip = Array.isArray(j?.hosts) && j.hosts.find((x: string) => x);\n          if (ip) setLanHost(ip);\n        })\n        .catch(() => {});\n    }\n    // Try to detect if server exposes HTTPS info\n    apiFetch(`/api/https-info`)\n      .then((r) => r.json())\n      .then((j) => {\n        if (j && typeof j.https === \"boolean\")\n          setHttpsInfo({ https: !!j.https, port: Number(j.port) || 8788 });\n      })\n      .catch(() => {});\n  }, []);\n\n  // Remove automatic phone pairing on mode change; only pair on explicit user action\n  const mobileUrl = useMemo(() => {\n    const code = pairCode || \"____\";\n    // Prefer configured WS host (Render) when available to build the correct server origin\n    const envUrl = (import.meta as any).env?.VITE_WS_URL as string | undefined;\n    if (envUrl && envUrl.length > 0) {\n      try {\n        const u = new URL(envUrl);\n        const isSecure = u.protocol === \"wss:\";\n        const origin = `${isSecure ? \"https\" : \"http\"}://${u.host}${u.pathname.endsWith(\"/ws\") ? \"\" : u.pathname}`;\n        const base = origin.replace(/\\/?ws$/i, \"\");\n        return `${base}/mobile-cam.html?code=${code}`;\n      } catch (e) {}\n    }\n    // Local dev fallback using detected LAN or current host\n    const host = lanHost || window.location.hostname;\n    const useHttps = !!httpsInfo?.https;\n    const port = useHttps ? httpsInfo?.port || 8788 : 8787;\n    const proto = useHttps ? \"https\" : \"http\";\n    return `${proto}://${host}:${port}/mobile-cam.html?code=${code}`;\n  }, [pairCode, lanHost, httpsInfo]);\n\n  const mobileLandingLink = useMemo(() => {\n    if (!mobileUrl) return null;\n    try {\n      const url = new URL(mobileUrl);\n      url.searchParams.delete(\"code\");\n      return url.toString().replace(/\\?$/, \"\");\n    } catch {\n      if (typeof window !== \"undefined\") {\n        const origin = window.location.origin.replace(/\\/$/, \"\");\n        return `${origin}/mobile-cam.html`;\n      }\n      return \"/mobile-cam.html\";\n    }\n  }, [mobileUrl]);\n\n  // Generate QR code when mobileUrl changes\n  useEffect(() => {\n    if (!mobileUrl || !pairCode) {\n      setQrDataUrl(null);\n      return;\n    }\n    let cancelled = false;\n    makeQrDataUrlWithLogo(mobileUrl, {\n      width: 256,\n      margin: 2,\n      errorCorrectionLevel: \"H\",\n      color: { dark: \"#000000\", light: \"#ffffff\" },\n      logo: false,\n    })\n      .then((url) => {\n        if (!cancelled) setQrDataUrl(url);\n      })\n      .catch(() => {\n        if (!cancelled) setQrDataUrl(null);\n      });\n    return () => {\n      cancelled = true;\n    };\n  }, [mobileUrl, pairCode]);\n\n  useEffect(() => {\n    localStorage.setItem(\"ndn:cal:mode\", mode);\n  }, [mode]);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    try {\n      if (mobileLandingOverride) {\n        window.localStorage.setItem(\"ndn:cal:forceDesktop\", \"1\");\n      } else {\n        window.localStorage.removeItem(\"ndn:cal:forceDesktop\");\n      }\n    } catch (e) {}\n  }, [mobileLandingOverride]);\n\n  useEffect(() => {\n    if (isTestEnv || typeof window === \"undefined\") return;\n    const coarseQuery = window.matchMedia(\"(pointer: coarse)\");\n    const detect = () => {\n      const uaMobile =\n        typeof navigator !== \"undefined\" &&\n        /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);\n      const coarse =\n        typeof coarseQuery.matches === \"boolean\" ? coarseQuery.matches : false;\n      const narrow = window.innerWidth <= 820;\n      setIsMobileDevice(uaMobile || coarse || narrow);\n    };\n    detect();\n    try {\n      if (typeof coarseQuery.addEventListener === \"function\")\n        coarseQuery.addEventListener(\"change\", detect);\n      else if (typeof coarseQuery.addListener === \"function\")\n        coarseQuery.addListener(detect);\n    } catch (e) {}\n    window.addEventListener(\"resize\", detect);\n    return () => {\n      try {\n        if (typeof coarseQuery.removeEventListener === \"function\")\n          coarseQuery.removeEventListener(\"change\", detect);\n        else if (typeof coarseQuery.removeListener === \"function\")\n          coarseQuery.removeListener(detect);\n      } catch (e) {}\n      window.removeEventListener(\"resize\", detect);\n    };\n  }, []);\n\n  // Detect camera permission status where supported\n  useEffect(() => {\n    if (isTestEnv) return;\n    if (typeof navigator === \"undefined\" || !(navigator as any).permissions) {\n      setCameraPerm(\"unsupported\");\n      return;\n    }\n    let mounted = true;\n    (async () => {\n      try {\n        const p = await (navigator as any).permissions.query({\n          name: \"camera\",\n        });\n        if (!mounted) return;\n        setCameraPerm(p.state || \"unknown\");\n        p.onchange = () => {\n          if (mounted) setCameraPerm(p.state);\n        };\n      } catch (err) {\n        // Some browsers don't support 'camera' permission query\n        if (mounted) setCameraPerm(\"unknown\");\n      }\n    })();\n    return () => {\n      mounted = false;\n    };\n  }, []);\n\n  async function refreshVideoDevices() {\n    if (\n      typeof navigator === \"undefined\" ||\n      !navigator.mediaDevices ||\n      !navigator.mediaDevices.enumerateDevices\n    )\n      return;\n    try {\n      const list = await navigator.mediaDevices.enumerateDevices();\n      const vids = list\n        .filter((d) => d.kind === \"videoinput\")\n        .map((d) => ({\n          deviceId: (d as any).deviceId,\n          label: d.label || \"Camera\",\n        }));\n      setVideoDevices(vids);\n      if (vids.length && !selectedDeviceId)\n        setSelectedDeviceId(vids[0].deviceId);\n    } catch (err) {\n      // ignore\n    }\n  }\n\n  useEffect(() => {\n    if (isTestEnv) return;\n    const mounted = true;\n    (async () => {\n      try {\n        await refreshVideoDevices();\n      } catch (e) {}\n      try {\n        if (navigator?.mediaDevices?.addEventListener) {\n          navigator.mediaDevices.addEventListener(\n            \"devicechange\",\n            refreshVideoDevices,\n          );\n        } else {\n          (navigator.mediaDevices as any).ondevicechange = refreshVideoDevices;\n        }\n      } catch (e) {}\n    })();\n    return () => {\n      try {\n        if (navigator?.mediaDevices?.removeEventListener)\n          navigator.mediaDevices.removeEventListener(\n            \"devicechange\",\n            refreshVideoDevices,\n          );\n      } catch (e) {}\n    };\n  }, []);\n\n  async function testCamera(deviceId?: string) {\n    if (\n      typeof navigator === \"undefined\" ||\n      !navigator.mediaDevices ||\n      !navigator.mediaDevices.getUserMedia\n    ) {\n      alert(\"getUserMedia is not available in this browser\");\n      return;\n    }\n    const constraints: any = {\n      video: deviceId\n        ? { deviceId: { exact: deviceId } }\n        : { facingMode: \"environment\" },\n    };\n    let stream: MediaStream | null = null;\n    try {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      // Immediately stop tracks to test access\n      stream.getTracks().forEach((t) => t.stop());\n      setCameraPerm(\"granted\");\n      // If a deviceId was provided, set it as the preferred camera so Start Camera will use it\n      try {\n        if (deviceId && typeof setPreferredCamera === \"function\") {\n          setPreferredCamera(deviceId);\n        }\n      } catch {}\n      alert(\n        \"Camera access granted — your webcam is available and set as preferred.\",\n      );\n    } catch (err: any) {\n      console.error(\"[Camera Connection] testCamera failed\", err);\n      if (\n        err &&\n        (err.name === \"NotAllowedError\" || err.name === \"PermissionDeniedError\")\n      ) {\n        setCameraPerm(\"denied\");\n        alert(\n          \"Camera permission denied. Please allow camera access in your browser settings and try again.\",\n        );\n      } else if (\n        err &&\n        (err.name === \"NotFoundError\" || err.name === \"DevicesNotFoundError\")\n      ) {\n        alert(\n          \"No camera devices found. Ensure your USB webcam is connected and not in use by another app.\",\n        );\n      } else {\n        alert(\"Unable to access the camera: \" + (err?.message || err));\n      }\n    } finally {\n      if (stream) stream.getTracks().forEach((t) => t.stop());\n    }\n  }\n\n  function openBrowserSiteSettings() {\n    if (typeof window === \"undefined\") return;\n    const ua = navigator.userAgent || \"\";\n    let url: string | null = null;\n    if (/Edg\\//.test(ua) || /Chrome\\//.test(ua) || /Chromium\\//.test(ua)) {\n      // Chromium-based browsers: open camera content settings\n      url = \"chrome://settings/content/camera\";\n    } else if (/Firefox\\//.test(ua)) {\n      url = \"about:preferences#privacy\";\n    } else if (/Safari\\//.test(ua) && !/Chrome\\//.test(ua)) {\n      // Safari has no direct site settings page we can open; show instructions instead\n      url = null;\n    }\n    if (url) {\n      const w = window.open(url, \"_blank\");\n      if (!w) {\n        alert(\n          'Unable to open browser settings automatically. Please open your browser settings and search for \"Camera\" permissions for this site.',\n        );\n      }\n    } else {\n      // Fallback instructions\n      alert(\n        \"Please open your browser settings and locate Site Settings → Camera (or Permissions) and allow camera access for this site. In Safari, use Preferences → Websites → Camera.\",\n      );\n    }\n  }\n\n  useEffect(() => {\n    if (isTestEnv || !expiresAt) return;\n    const t = setInterval(() => setNow(Date.now()), 1000);\n    return () => clearInterval(t);\n  }, [expiresAt]);\n  const ttl = useMemo(\n    () => (expiresAt ? Math.max(0, Math.ceil((expiresAt - now) / 1000)) : null),\n    [expiresAt, now],\n  );\n  useEffect(() => {\n    return () => {\n      if (copyTimeoutRef.current) window.clearTimeout(copyTimeoutRef.current);\n    };\n  }, []);\n\n  const copyValue = useCallback(\n    async (value: string | null | undefined, type: \"link\" | \"code\") => {\n      if (!value) return;\n      try {\n        if (navigator.clipboard && navigator.clipboard.writeText) {\n          await navigator.clipboard.writeText(value);\n        } else {\n          const textarea = document.createElement(\"textarea\");\n          textarea.value = value;\n          textarea.style.position = \"fixed\";\n          textarea.style.opacity = \"0\";\n          document.body.appendChild(textarea);\n          textarea.focus();\n          textarea.select();\n          document.execCommand(\"copy\");\n          try {\n            document.body.removeChild(textarea);\n          } catch {\n            // If removal fails, element was already removed\n          }\n        }\n        setCopyFeedback(type);\n        if (copyTimeoutRef.current) window.clearTimeout(copyTimeoutRef.current);\n        copyTimeoutRef.current = window.setTimeout(\n          () => setCopyFeedback(null),\n          1500,\n        );\n      } catch (err) {\n        console.warn(\"[Camera Connection] Copy failed:\", err);\n        setCopyFeedback(null);\n      }\n    },\n    [],\n  );\n  // Removed automatic regeneration of code when ttl expires. Only regenerate on explicit user action.\n\n  // NOTE: Removed automatic permission request on load - it was blocking camera access\n  // Let startCamera() handle the permission request when user clicks \"Enable camera\"\n  // This prevents the camera from being held by the permission test\n\n  useEffect(() => {\n    return () => {\n      // DON'T call stopCamera() on unmount - we want phone camera to persist!\n      // Just clean up local refs\n      // The camera stream stays alive so user can see it in Online/Offline/Tournaments\n    };\n  }, []); // Remove automatic camera restart on preferredCameraId change to prevent flicker\n\n  // Listen for reconnect requests from PhoneCameraOverlay\n  useEffect(() => {\n    if (isTestEnv) return;\n    const handleReconnectRequest = (event: any) => {\n      console.log(\n        \"[Camera Connection] Received reconnect request from PhoneCameraOverlay\",\n      );\n      // If we're in phone mode and already paired, restart the pairing\n      if (mode === \"phone\" && paired) {\n        stopCamera(false);\n        // Give a moment for cleanup, then restart pairing\n        setTimeout(() => {\n          startPhonePairing();\n        }, 500);\n      }\n    };\n\n    window.addEventListener(\n      \"ndn:phone-camera-reconnect\",\n      handleReconnectRequest as EventListener,\n    );\n    return () => {\n      window.removeEventListener(\n        \"ndn:phone-camera-reconnect\",\n        handleReconnectRequest as EventListener,\n      );\n    };\n  }, [mode, paired]);\n\n  // Sync video element to camera session so other components can access it\n  // CRITICAL: Run whenever streaming state changes to keep videoRef synced\n  useEffect(() => {\n    console.log(\"[Camera Connection] 🔄 STREAMING CHANGED:\", {\n      streaming,\n      videoRefAvailable: !!videoRef.current,\n    });\n    if (videoRef.current) {\n      console.log(\n        \"[Camera Connection] ✅ Syncing videoElementRef on streaming change\",\n      );\n      cameraSession.setVideoElementRef(videoRef.current);\n      // Also capture media stream when available\n      if (videoRef.current.srcObject instanceof MediaStream) {\n        console.log(\n          \"[Camera Connection] ✅ Setting mediaStream from video element\",\n        );\n        cameraSession.setMediaStream(videoRef.current.srcObject);\n      }\n    } else {\n      console.warn(\n        \"[Camera Connection] ⚠️ videoRef.current is null on streaming change!\",\n      );\n    }\n  }, [streaming]);\n\n  // Also sync on mount to capture initial videoRef\n  useEffect(() => {\n    console.log(\n      \"[Camera Connection] 🚀 MOUNT: Initial mount - syncing videoRef\",\n    );\n    console.log(\n      \"[Camera Connection] videoRef.current available:\",\n      !!videoRef.current,\n    );\n    console.log(\n      \"[Camera Connection] videoRef.current type:\",\n      videoRef.current?.constructor?.name,\n    );\n\n    if (videoRef.current) {\n      console.log(\"[Camera Connection] ✅ Setting videoElementRef on mount\");\n      console.log(\"[Camera Connection] Video element:\", {\n        tagName: videoRef.current.tagName,\n        srcObject: !!videoRef.current.srcObject,\n        videoWidth: videoRef.current.videoWidth,\n        videoHeight: videoRef.current.videoHeight,\n      });\n      cameraSession.setVideoElementRef(videoRef.current);\n      console.log(\"[Camera Connection] ✅ videoElementRef set successfully\");\n    } else {\n      console.error(\n        \"[Camera Connection] ❌ CRITICAL: videoRef.current is NULL at mount!\",\n      );\n    }\n    // Do NOT clear the videoElementRef on unmount; we want the stream to persist globally\n    return () => {\n      /* keep global video element ref for overlay */\n    };\n  }, []);\n\n  function ensureWS() {\n    // Return existing WebSocket if it's open or connecting\n    if (\n      ws &&\n      (ws.readyState === WebSocket.OPEN ||\n        ws.readyState === WebSocket.CONNECTING)\n    ) {\n      console.log(\n        \"[Camera Connection] ensureWS: Reusing existing WebSocket (state:\",\n        ws.readyState,\n        \")\",\n      );\n      return ws;\n    }\n    // Prefer configured WS endpoint; normalize to include '/ws'. Fallback to same-origin '/ws'.\n    const envUrl = (import.meta as any).env?.VITE_WS_URL as string | undefined;\n    const normalizedEnv =\n      envUrl && envUrl.length > 0\n        ? envUrl.endsWith(\"/ws\")\n          ? envUrl\n          : envUrl.replace(/\\/$/, \"\") + \"/ws\"\n        : undefined;\n    const proto = window.location.protocol === \"https:\" ? \"wss\" : \"ws\";\n    const sameOrigin = `${proto}://${window.location.host}/ws`;\n    const host = window.location.hostname;\n    // Production safeguard: if we are not on the Render backend host and no env URL is set,\n    // prefer the known Render service as a fallback instead of Netlify same-origin.\n    const renderWS = `wss://ninedartnation.onrender.com/ws`;\n    const url =\n      normalizedEnv || (host.endsWith(\"onrender.com\") ? sameOrigin : renderWS);\n    console.log(\n      \"[Camera Connection] ensureWS: Creating new WebSocket to:\",\n      url,\n    );\n    const socket: WebSocket = new WebSocket(url);\n\n    // Set up handlers BEFORE storing the socket to avoid race conditions\n    socket.onerror = (error) => {\n      console.error(\"[Camera Connection] WebSocket connection error:\", error);\n      alert(\n        \"Failed to connect to camera pairing service. Please check your internet connection and try again.\",\n      );\n    };\n    socket.onclose = (event) => {\n      console.log(\n        \"[Camera Connection] WebSocket closed:\",\n        event.code,\n        event.reason,\n      );\n      if (pcRef.current) {\n        try {\n          pcRef.current.close();\n        } catch {}\n        pcRef.current = null;\n      }\n      updatePairCode(null);\n      setExpiresAt(null);\n      setPaired(false);\n      // Only show alert if it wasn't a clean close\n      if (event.code !== 1000) {\n        alert(\"Camera pairing connection lost. Please try pairing again.\");\n        // Also revert to local mode on disconnect so user can restart camera\n        if (mode === \"phone\") setMode(\"local\");\n      }\n    };\n\n    // Store socket BEFORE setting message handler to ensure it's available for message sending\n    setWs(socket);\n    return socket;\n  }\n\n  async function startPhonePairing() {\n    // Do not reset paired/streaming/phase state here to keep UI static\n    // Switch UI into phone pairing mode so the calibrator shows phone-specific hints\n    setMode(\"phone\");\n    // Stop any existing camera streams before switching to phone mode\n    // This ensures clean transition and no resource conflicts\n    // Use true for autoRevert since we're explicitly switching modes, but we already set mode above\n    stopCamera(false);\n    // Lock selection and ensure camera UI is enabled while pairing is active\n    lockSelectionForPairing();\n    try {\n      setCameraEnabled(true);\n    } catch (e) {}\n    const socket = ensureWS();\n    // Send cam-create when socket is ready\n    if (socket.readyState === WebSocket.OPEN) {\n      console.log(\"[Camera Connection] WebSocket open, sending cam-create\");\n      socket.send(JSON.stringify({ type: \"cam-create\" }));\n    } else {\n      console.log(\n        \"[Camera Connection] WebSocket connecting, will send cam-create on open\",\n      );\n      socket.addEventListener(\n        \"open\",\n        () => {\n          console.log(\n            \"[Camera Connection] WebSocket now open, sending cam-create\",\n          );\n          socket.send(JSON.stringify({ type: \"cam-create\" }));\n        },\n        { once: true },\n      );\n    }\n    socket.onmessage = async (ev) => {\n      const data = JSON.parse(ev.data);\n      if (data.type === \"cam-code\") {\n        updatePairCode(data.code);\n        if (data.expiresAt) setExpiresAt(data.expiresAt);\n      } else if (data.type === \"cam-peer-joined\") {\n        // Ensure we have the latest pairing code even if messages arrive out of order\n        if (!pairCodeRef.current && data.code) updatePairCode(data.code);\n        setPaired(true);\n        // When a phone peer joins, proactively send current calibration (if locked)\n        const codeForSession = pairCodeRef.current || data.code || null;\n        if (codeForSession) pairCodeRef.current = codeForSession;\n        try {\n          if (locked && codeForSession) {\n            const imgSize = canvasRef.current\n              ? { w: canvasRef.current.width, h: canvasRef.current.height }\n              : null;\n            const payload = {\n              H,\n              imageSize: imgSize,\n              errorPx: errorPx ?? null,\n              createdAt: Date.now(),\n            };\n            socket.send(\n              JSON.stringify({\n                type: \"cam-calibration\",\n                code: codeForSession,\n                payload,\n              }),\n            );\n            console.log(\n              \"[Camera Connection] Sent calibration to joined phone for code\",\n              codeForSession,\n            );\n          }\n        } catch (e) {\n          console.warn(\n            \"[Camera Connection] Failed to send calibration on peer join\",\n            e,\n          );\n        }\n        const peer = new RTCPeerConnection({\n          iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\n          iceCandidatePoolSize: 10,\n        });\n        pcRef.current = peer;\n\n        // Add connection state monitoring\n        peer.onconnectionstatechange = () => {\n          console.log(\"WebRTC connection state:\", peer.connectionState);\n          if (\n            peer.connectionState === \"failed\" ||\n            peer.connectionState === \"disconnected\"\n          ) {\n            console.error(\"WebRTC connection failed\");\n            alert(\"Camera connection lost. Please try pairing again.\");\n            stopCamera(false);\n          } else if (peer.connectionState === \"connected\") {\n            console.log(\"WebRTC connection established\");\n          }\n        };\n\n        peer.onicecandidate = (e) => {\n          if (e.candidate && codeForSession) {\n            socket.send(\n              JSON.stringify({\n                type: \"cam-ice\",\n                code: codeForSession,\n                payload: e.candidate,\n              }),\n            );\n          }\n        };\n\n        peer.ontrack = (ev) => {\n          console.log(\n            \"[Camera Connection] WebRTC ontrack received:\",\n            ev.streams?.length,\n            \"streams, track kind:\",\n            ev.track?.kind,\n          );\n          if (videoRef.current) {\n            const inbound = ev.streams?.[0];\n            if (inbound) {\n              console.log(\n                \"[Camera Connection] Assigning video stream (tracks:\",\n                inbound.getTracks().length,\n                \") to video element\",\n              );\n              // Ensure video element is visible\n              setHasSnapshot(false);\n              // Use setTimeout to ensure DOM updates before assigning stream\n              setTimeout(() => {\n                if (videoRef.current) {\n                  console.log(\n                    \"[Camera Connection] Setting srcObject and attempting play\",\n                  );\n                  // Clean up any existing stream before assigning new one\n                  if (videoRef.current.srcObject) {\n                    const existingTracks = (\n                      videoRef.current.srcObject as MediaStream\n                    ).getTracks();\n                    existingTracks.forEach((t) => t.stop());\n                  }\n                  videoRef.current.srcObject = inbound;\n                  videoRef.current.muted = true; // Ensure muted for autoplay policy\n                  videoRef.current.playsInline = true; // Mobile/iOS support\n                  videoRef.current\n                    .play()\n                    .then(() => {\n                      console.log(\n                        \"[Camera Connection] Video playback started successfully\",\n                      );\n                      // Mark that we're streaming from the phone and transition to capture\n                      setStreaming(true);\n                      setPhase(\"capture\");\n                      // Update camera session so other components can see the stream\n                      cameraSession.setStreaming(true);\n                      cameraSession.setMode(\"phone\");\n                      cameraSession.setMediaStream(inbound);\n                      // Set user settings to reflect that the active camera is the phone\n                      try {\n                        setPreferredCamera(undefined, \"Phone Camera\", true);\n                      } catch {}\n                      if (!preferredCameraLocked) {\n                        try {\n                          setPreferredCameraLocked(true);\n                        } catch {}\n                      }\n                      try {\n                        setCameraEnabled(true);\n                      } catch {}\n                      // If an overlay prompt was shown earlier, hide it now\n                      setVideoPlayBlocked(false);\n                    })\n                    .catch((err) => {\n                      console.error(\n                        \"[Camera Connection] Video play failed:\",\n                        err,\n                      );\n                      // Show a friendly tap-to-play overlay so user can enable playback\n                      setVideoPlayBlocked(true);\n                      console.warn(\n                        \"[Camera Connection] video play blocked — prompting user interaction\",\n                      );\n                    });\n                }\n              }, 100);\n            } else {\n              console.error(\n                \"[Camera Connection] No inbound stream received in ontrack\",\n              );\n            }\n          } else {\n            console.error(\"[Camera Connection] Video element not available\");\n          }\n        };\n\n        try {\n          // Explicitly add a transceiver to ensure we request video capability\n          // even if the browser defaults for createOffer vary.\n          peer.addTransceiver(\"video\", { direction: \"recvonly\" });\n          const offer = await peer.createOffer({\n            offerToReceiveAudio: false,\n            offerToReceiveVideo: true,\n          });\n          await peer.setLocalDescription(offer);\n          console.log(\n            \"[Camera Connection] Sending cam-offer for code:\",\n            codeForSession,\n          );\n          if (codeForSession)\n            socket.send(\n              JSON.stringify({\n                type: \"cam-offer\",\n                code: codeForSession,\n                payload: offer,\n              }),\n            );\n          else\n            console.warn(\n              \"[Camera Connection] Missing pairing code when sending offer\",\n            );\n        } catch (err) {\n          console.error(\"Failed to create WebRTC offer:\", err);\n          alert(\"Failed to establish camera connection. Please try again.\");\n          stopCamera(false);\n        }\n      } else if (data.type === \"cam-answer\") {\n        console.log(\"[Camera Connection] Received cam-answer\");\n        const peer = pcRef.current;\n        if (peer) {\n          try {\n            await peer.setRemoteDescription(\n              new RTCSessionDescription(data.payload),\n            );\n            console.log(\"[Camera Connection] Remote description set (answer)\");\n\n            // Process any pending ICE candidates that arrived before the answer\n            const pending = pendingIceCandidatesRef.current;\n            console.log(\n              `[Camera Connection] Processing ${pending.length} pending ICE candidates`,\n            );\n            for (const candidate of pending) {\n              try {\n                await peer.addIceCandidate(candidate);\n                console.log(\"[Camera Connection] Queued ICE candidate added\");\n              } catch (err) {\n                console.error(\"Failed to add queued ICE candidate:\", err);\n              }\n            }\n            pendingIceCandidatesRef.current = [];\n          } catch (err) {\n            console.error(\"Failed to set remote description:\", err);\n            alert(\"Camera pairing failed. Please try again.\");\n            stopCamera(false);\n          }\n        } else {\n          console.warn(\n            \"[Camera Connection] Received cam-answer but no peer connection exists\",\n          );\n        }\n      } else if (data.type === \"cam-ice\") {\n        console.log(\"[Camera Connection] Received cam-ice\");\n        const peer = pcRef.current;\n        if (peer) {\n          // Only add ICE candidate if remote description is already set\n          // Otherwise, queue it for later processing\n          if (peer.remoteDescription) {\n            try {\n              await peer.addIceCandidate(data.payload);\n              console.log(\"[Camera Connection] ICE candidate added\");\n            } catch (err) {\n              console.error(\"Failed to add ICE candidate:\", err);\n            }\n          } else {\n            console.log(\n              \"[Camera Connection] Remote description not set yet, queuing ICE candidate\",\n            );\n            pendingIceCandidatesRef.current.push(data.payload);\n          }\n        } else {\n          console.warn(\n            \"[Camera Connection] Received ICE candidate but no peer connection exists\",\n          );\n        }\n      } else if (data.type === \"cam-error\") {\n        console.error(\"Camera pairing error:\", data.code);\n        alert(\n          data.code === \"EXPIRED\"\n            ? \"Code expired. Generate a new code.\"\n            : `Camera error: ${data.code || \"Unknown error\"}`,\n        );\n        stopCamera(false);\n      } else if (data.type === \"cam-calibration\") {\n        // Desktop receives calibration from phone (via server) or phone receives from desktop\n        console.log(\n          \"[Camera Connection] Received calibration from peer:\",\n          data.payload,\n        );\n        try {\n          if (data.payload) {\n            // If payload has a homography, use it. Otherwise if we have 4 connection points, attempt to compute H.\n            let Hpayload = Array.isArray(data.payload.H)\n              ? (data.payload.H as Homography)\n              : null;\n            if (\n              !Hpayload &&\n              Array.isArray(data.payload.calibrationPoints) &&\n              data.payload.calibrationPoints.length >= 4\n            ) {\n              try {\n                const canonicalSrc = [\n                  { x: 0, y: -BoardRadii.doubleOuter },\n                  { x: BoardRadii.doubleOuter, y: 0 },\n                  { x: 0, y: BoardRadii.doubleOuter },\n                  { x: -BoardRadii.doubleOuter, y: 0 },\n                ];\n                Hpayload = computeHomographyDLT(\n                  canonicalSrc,\n                  data.payload.calibrationPoints.slice(0, 4),\n                );\n              } catch (err) {\n                console.warn(\n                  \"[Camera Connection] Failed to compute homography from received connection points\",\n                  err,\n                );\n              }\n            }\n            if (Hpayload) {\n              // Apply the received calibration\n              // Use overlay size from current preview (video or overlay/canvas) if available so visual scale stays consistent\n              const overlaySize = overlayRef?.current\n                ? { w: overlayRef.current.width, h: overlayRef.current.height }\n                : videoRef?.current\n                  ? {\n                      w: videoRef.current.clientWidth,\n                      h: videoRef.current.clientHeight,\n                    }\n                  : (data.payload.imageSize ?? null);\n              setCalibration({\n                H: Hpayload as Homography,\n                createdAt: data.payload.createdAt || Date.now(),\n                errorPx: data.payload.errorPx,\n                imageSize: data.payload.imageSize,\n                overlaySize,\n                locked: true, // Assume locked since peer sent it\n              });\n              console.log(\"[Camera Connection] Applied received calibration\");\n            }\n          }\n        } catch (e) {\n          console.error(\n            \"[Camera Connection] Failed to apply received calibration\",\n            e,\n          );\n        }\n      }\n    };\n  }\n\n  async function startWifiConnection() {\n    setDiscoveringWifi(true);\n    try {\n      const devices = await discoverNetworkDevices();\n      setWifiDevices(devices);\n      if (devices.length === 0) {\n        alert(\n          \"No wifi scoring devices found on your network. Make sure devices are powered on and connected to the same network.\",\n        );\n      }\n    } catch (error) {\n      console.error(\"Wifi device discovery failed:\", error);\n      alert(\n        \"Failed to discover wifi devices. Please check your network connection.\",\n      );\n    } finally {\n      setDiscoveringWifi(false);\n    }\n    setPhase(\"camera\");\n  }\n\n  async function connectToWifiDevice(device: NetworkDevice) {\n    try {\n      setWifiDevices((devices) =>\n        devices.map((d) =>\n          d.id === device.id ? { ...d, status: \"connecting\" as const } : d,\n        ),\n      );\n\n      const stream = await connectToNetworkDevice(device);\n      if (stream && videoRef.current) {\n        // Clean up any existing stream before assigning new one\n        if (videoRef.current.srcObject) {\n          const existingTracks = (\n            videoRef.current.srcObject as MediaStream\n          ).getTracks();\n          existingTracks.forEach((t) => t.stop());\n        }\n        videoRef.current.srcObject = stream;\n        await videoRef.current.play();\n        setStreaming(true);\n        setPhase(\"capture\");\n        setWifiDevices((devices) =>\n          devices.map((d) =>\n            d.id === device.id ? { ...d, status: \"online\" as const } : d,\n          ),\n        );\n      } else {\n        throw new Error(\"Failed to get video stream\");\n      }\n    } catch (error) {\n      console.error(\"Failed to connect to wifi device:\", error);\n      alert(\n        `Failed to connect to ${device.name}. Please check the device and try again.`,\n      );\n      setWifiDevices((devices) =>\n        devices.map((d) =>\n          d.id === device.id ? { ...d, status: \"offline\" as const } : d,\n        ),\n      );\n    }\n  }\n\n  async function startCamera() {\n    if (mode === \"phone\") return startPhonePairing();\n    if (mode === \"wifi\") return startWifiConnection();\n    console.log(\n      \"[Camera Connection] 🎬 START_CAMERA: mode=\",\n      mode,\n      \"preferredCameraId=\",\n      preferredCameraId,\n    );\n    try {\n      let stream: MediaStream | null = null;\n\n      // Step 1: Try with preferred camera ID if available\n      if (preferredCameraId) {\n        try {\n          console.log(\n            \"[Camera Connection] 📹 Attempt 1: Using preferred camera ID:\",\n            preferredCameraId,\n          );\n          stream = await navigator.mediaDevices.getUserMedia({\n            video: { deviceId: { exact: preferredCameraId } },\n            audio: false,\n          });\n          console.log(\n            \"[Camera Connection] ✅ SUCCESS with preferred camera:\",\n            stream.getTracks().length,\n            \"tracks\",\n          );\n        } catch (err: any) {\n          console.warn(\n            \"[Camera Connection] ⚠️ Preferred camera failed:\",\n            err?.name,\n            err?.message,\n          );\n        }\n      }\n\n      // Step 2: If preferred didn't work, try any camera\n      if (!stream) {\n        try {\n          console.log(\n            \"[Camera Connection] 📹 Attempt 2: Using ANY available camera\",\n          );\n          stream = await navigator.mediaDevices.getUserMedia({\n            video: true,\n            audio: false,\n          });\n          console.log(\n            \"[Camera Connection] ✅ SUCCESS with fallback camera:\",\n            stream.getTracks().length,\n            \"tracks\",\n          );\n        } catch (err: any) {\n          console.error(\n            \"[Camera Connection] ❌ BOTH attempts failed:\",\n            err?.name,\n            err?.message,\n          );\n          throw err;\n        }\n      }\n\n      // Step 3: Assign to video element\n      if (!stream) {\n        throw new Error(\"No stream obtained\");\n      }\n\n      if (!videoRef.current) {\n        throw new Error(\"Video element ref is null\");\n      }\n\n      console.log(\"[Camera Connection] 📺 Assigning stream to video element\");\n      videoRef.current.srcObject = stream;\n\n      console.log(\"[Camera Connection] ▶️ Calling play()\");\n      try {\n        await videoRef.current.play();\n        console.log(\"[Camera Connection] ✅ Play succeeded\");\n      } catch (playErr: any) {\n        console.warn(\n          \"[Camera Connection] ⚠️ Play failed, retrying in 100ms:\",\n          playErr?.message,\n        );\n        await new Promise((r) => setTimeout(r, 100));\n        await videoRef.current.play();\n        console.log(\"[Camera Connection] ✅ Play succeeded on retry\");\n      }\n\n      console.log(\"[Camera Connection] 🟢 Setting streaming = true\");\n      setStreaming(true);\n      setPhase(\"capture\");\n      console.log(\"[Camera Connection] 🟢 State updated\");\n    } catch (e: any) {\n      console.error(\"[Camera Connection] 🔴 FATAL:\", e?.message || e);\n      alert(`Camera failed: ${e?.message || \"Unknown error\"}`);\n      // Clean up any partial stream\n      if (videoRef.current?.srcObject) {\n        (videoRef.current.srcObject as MediaStream)\n          .getTracks()\n          .forEach((t) => t.stop());\n        videoRef.current.srcObject = null;\n      }\n    }\n  }\n\n  function stopCamera(autoRevert: boolean = false) {\n    if (videoRef.current && videoRef.current.srcObject) {\n      const tracks = (videoRef.current.srcObject as MediaStream).getTracks();\n      tracks.forEach((t) => t.stop());\n      videoRef.current.srcObject = null;\n      setStreaming(false);\n    }\n    if (pcRef.current) {\n      try {\n        pcRef.current.close();\n      } catch {}\n      pcRef.current = null;\n    }\n    pendingIceCandidatesRef.current = [];\n    updatePairCode(null);\n    setExpiresAt(null);\n    setPaired(false);\n    setMarkerResult(null);\n    // Clear camera session when stopping camera\n    cameraSession.setStreaming(false);\n    cameraSession.setMediaStream(null);\n    // Only revert to local mode if EXPLICITLY requested (user clicked Stop button)\n    // Otherwise preserve the selected mode so user can go to OfflinePlay and come back\n    if (autoRevert && (mode === \"phone\" || mode === \"wifi\")) {\n      setMode(\"local\");\n    }\n  }\n\n  function regenerateCode() {\n    // Only regenerate code, do not reset UI or camera state\n    if (ws && ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({ type: \"cam-create\" }));\n    } else {\n      startPhonePairing();\n    }\n    // Lock the preferred camera selection while pairing is active so it doesn't\n    // flip automatically during the pairing flow.\n    lockSelectionForPairing();\n  }\n\n  // When user regenerates a pairing code we lock the preferred camera selection so\n  // it won't be changed accidentally by other parts of the UI while pairing is active.\n  // This implements the user's request that the camera selection 'stay static' after\n  // generating a code. The lock can be toggled by the user in the DevicePicker UI.\n  function lockSelectionForPairing() {\n    try {\n      if (!preferredCameraLocked) {\n        setPreferredCameraLocked(true);\n      }\n    } catch {}\n  }\n\n  // Allow uploading a photo instead of using a live camera\n  function triggerUpload() {\n    try {\n      fileInputRef.current?.click();\n    } catch {}\n  }\n\n  function openMarkerSheet() {\n    // Open the marker sheet page in a new tab for printing\n    const markerSheetUrl = `${window.location.origin}/marker-sheet.html`;\n    window.open(markerSheetUrl, \"_blank\");\n  }\n\n  function onUploadPhotoChange(e: React.ChangeEvent<HTMLInputElement>) {\n    const f = e.target.files?.[0];\n    if (!f) return;\n    const img = new Image();\n    img.onload = () => {\n      try {\n        if (!canvasRef.current) return;\n        const c = canvasRef.current;\n        c.width = img.naturalWidth;\n        c.height = img.naturalHeight;\n        const ctx = c.getContext(\"2d\")!;\n        ctx.drawImage(img, 0, 0, c.width, c.height);\n        setHasSnapshot(true);\n        setFrameSize({ w: c.width, h: c.height });\n        setPhase(\"select\");\n        setDstPoints([]);\n        setMarkerResult(null);\n        // Clear any previous video stream\n        stopCamera(false);\n      } catch {}\n    };\n    img.onerror = () => {\n      alert(\"Could not load image. Please try a different photo.\");\n    };\n    img.src = URL.createObjectURL(f);\n    // reset input value so the same file can be reselected\n    try {\n      e.target.value = \"\";\n    } catch {}\n  }\n\n  function captureFrame() {\n    if (!videoRef.current || !canvasRef.current) return;\n    const v = videoRef.current;\n    const c = canvasRef.current;\n    c.width = v.videoWidth;\n    c.height = v.videoHeight;\n    const ctx = c.getContext(\"2d\")!;\n    ctx.drawImage(v, 0, 0, c.width, c.height);\n    setHasSnapshot(true);\n    setFrameSize({ w: c.width, h: c.height });\n    setPhase(\"select\");\n    // Ensure we start fresh with 0 points - log for debugging\n    console.log(\"[Camera Connection] captureFrame: resetting dstPoints to []\");\n    setDstPoints([]);\n    setDetected(null); // Also clear auto-detected rings\n    setForceDetectedOnly(false);\n    setMarkerResult(null);\n    // Clear the overlay canvas to remove any leftover drawings (dart axis lines, etc.)\n    if (overlayRef.current) {\n      const o = overlayRef.current;\n      o.width = c.width;\n      o.height = c.height;\n      const octx = o.getContext(\"2d\");\n      if (octx) octx.clearRect(0, 0, o.width, o.height);\n    }\n    // If liveDetect is on, kick a detect on this captured frame\n    if (liveDetect)\n      setTimeout(() => {\n        autoDetectRings();\n      }, 0);\n  }\n\n  function drawOverlay(\n    currentPoints = dstPoints,\n    HH: Homography | null = null,\n  ) {\n    if (!canvasRef.current || !overlayRef.current) return;\n    const img = canvasRef.current;\n    const o = overlayRef.current;\n    o.width = img.width;\n    o.height = img.height;\n    const ctx = o.getContext(\"2d\")!;\n    ctx.clearRect(0, 0, o.width, o.height);\n\n    // Ensure overlay is interactive: attach click handler for align operation\n    if (overlayRef.current) {\n      overlayRef.current.onclick = (e: MouseEvent) => onOverlayClick(e);\n    }\n\n    // Only use stored H for drawing rings if we have enough points OR if explicitly passed HH\n    // During calibration point collection (phase=\"select\" with < REQUIRED points), don't use old H\n    // as it may be from a previous frame and draw incorrectly\n    const Huse =\n      HH || (currentPoints.length >= REQUIRED_POINT_COUNT ? H : null);\n    // Apply the correction to the stored calibration H so both overlay and scoring match\n    // Add translation after scaling for pixel-perfect alignment\n    const CORRECTION_SX = correctionSx; // <1 compresses horizontally\n    const CORRECTION_TX = correctionTx; // pixels right (+) or left (-)\n    const CORRECTION_TY = correctionTy; // pixels down (+) or up (-)\n    let Hcorrected = Huse;\n    if (Hcorrected && CORRECTION_SX !== 1)\n      Hcorrected = scaleHomography(Hcorrected, CORRECTION_SX, 1);\n    if (Hcorrected && (CORRECTION_TX !== 0 || CORRECTION_TY !== 0))\n      Hcorrected = translateHomography(\n        Hcorrected,\n        CORRECTION_TX,\n        CORRECTION_TY,\n      );\n\n    // Apply translation corrections to center coordinates (when detected exists)\n    const adjustedCenterX = detected ? detected.cx + correctionTx : 0;\n    const adjustedCenterY = detected ? detected.cy + correctionTy : 0;\n\n    // Precompute detected radii map (useful even if we later bypass homography)\n    const WIDEN_FACTOR = 1.0; // use raw detected radii for exact alignment\n    const detectedRingMap: { [key: number]: number } = {};\n    if (detected) {\n      // Store raw scaled radii (before applying correctionSx for display as ellipses)\n      detectedRingMap[BoardRadii.bullInner] = detected.bullInner * WIDEN_FACTOR;\n      detectedRingMap[BoardRadii.bullOuter] = detected.bullOuter * WIDEN_FACTOR;\n      detectedRingMap[BoardRadii.trebleInner] =\n        detected.trebleInner * WIDEN_FACTOR;\n      detectedRingMap[BoardRadii.trebleOuter] =\n        detected.trebleOuter * WIDEN_FACTOR;\n      detectedRingMap[BoardRadii.doubleInner] =\n        detected.doubleInner * WIDEN_FACTOR;\n      detectedRingMap[BoardRadii.doubleOuter] =\n        detected.doubleOuter * WIDEN_FACTOR;\n    }\n\n    // Per-ring adjustments if needed (quick fix for non-standard boards)\n    const perRingAdjust: { [key: number]: number } = {};\n    // Apply per-ring adjustments using UI-controlled state\n    perRingAdjust[BoardRadii.doubleOuter] = doubleOuterAdjust;\n    perRingAdjust[BoardRadii.trebleOuter] = trebleOuterAdjust;\n\n    // Helper to draw the detected rings directly (bypass homography)\n    function drawDetectedRings(): number {\n      if (!detected) return 0;\n      let drawn = 0;\n      try {\n        // Colors using pass/fail heuristics are available below; use default colors here\n        const bullFill = \"rgba(52,211,153,0.08)\";\n        const trebleFill = \"rgba(253,224,71,0.06)\";\n        const doubleFill = \"rgba(34,211,238,0.06)\";\n\n        const drawBand = (\n          rInner: number,\n          rOuter: number,\n          fillStyle: string,\n          strokeStyle?: string,\n        ) => {\n          const inner = detectedRingMap[rInner];\n          const outer = detectedRingMap[rOuter];\n          if (!inner || !outer) return false;\n          ctx.save();\n          ctx.shadowColor = \"rgba(0,0,0,0.45)\";\n          ctx.shadowBlur = 6;\n          ctx.beginPath();\n          const outerAdj = outer * (perRingAdjust[rOuter] || 1);\n          const innerAdj = inner * (perRingAdjust[rInner] || 1);\n          // Draw as circles based on adjusted radii; no ellipse distortions\n          ctx.arc(adjustedCenterX, adjustedCenterY, outerAdj, 0, Math.PI * 2);\n          ctx.arc(\n            adjustedCenterX,\n            adjustedCenterY,\n            innerAdj,\n            0,\n            Math.PI * 2,\n            true,\n          );\n          ctx.closePath();\n          ctx.fillStyle = fillStyle;\n          ctx.fill();\n          if (strokeStyle) {\n            ctx.strokeStyle = strokeStyle;\n            ctx.lineWidth = 2;\n            ctx.stroke();\n          }\n          ctx.restore();\n          return true;\n        };\n\n        drawBand(BoardRadii.bullInner, BoardRadii.bullOuter, bullFill);\n        drawn++;\n        drawBand(BoardRadii.trebleInner, BoardRadii.trebleOuter, trebleFill);\n        drawn++;\n        drawBand(BoardRadii.doubleInner, BoardRadii.doubleOuter, doubleFill);\n        drawn++;\n\n        // Outlines for clarity\n        const OUTLINE_STEPS = 360;\n        const outlines = [\n          { r: BoardRadii.bullInner, color: \"#00ff66\" },\n          { r: BoardRadii.bullOuter, color: \"#ffffff\" },\n          { r: BoardRadii.trebleInner, color: \"#fde047\" },\n          { r: BoardRadii.trebleOuter, color: \"#fde047\" },\n          { r: BoardRadii.doubleInner, color: \"#22d3ee\" },\n          { r: BoardRadii.doubleOuter, color: \"#22d3ee\" },\n        ];\n        for (const oline of outlines) {\n          const radius = detectedRingMap[oline.r];\n          if (!radius) continue;\n          const poly: Point[] = [];\n          for (let i = 0; i < OUTLINE_STEPS; i++) {\n            const angle = (i / OUTLINE_STEPS) * Math.PI * 2;\n            const rAdj = radius * correctionSx * (perRingAdjust[oline.r] || 1);\n            poly.push({\n              x: adjustedCenterX + rAdj * Math.cos(angle),\n              y: adjustedCenterY + rAdj * Math.sin(angle),\n            });\n          }\n          drawPolyline(ctx, poly, \"rgba(0,0,0,0.45)\", 3);\n          drawPolyline(ctx, poly, oline.color, 1.5);\n        }\n      } catch (err) {\n        return 0;\n      }\n      return 3;\n    }\n\n    // Click handler for overlay to support 'align ring by click'\n    function onOverlayClick(evt: MouseEvent) {\n      if (!aligningRing || !overlayRef.current || !detected) return;\n      const rect = overlayRef.current.getBoundingClientRect();\n      const x =\n        (evt.clientX - rect.left) * (overlayRef.current.width / rect.width);\n      const y =\n        (evt.clientY - rect.top) * (overlayRef.current.height / rect.height);\n      const dx = x - adjustedCenterX;\n      const dy = y - adjustedCenterY;\n      const clickedRadius = Math.hypot(dx, dy);\n      let key: number;\n      if (aligningRing === \"double\") key = BoardRadii.doubleOuter;\n      else if (aligningRing === \"treble\") key = BoardRadii.trebleOuter;\n      else key = BoardRadii.bullOuter;\n      const currentRadius = detectedRingMap[key];\n      if (!currentRadius || currentRadius <= 0) return;\n      const newAdjust = clickedRadius / (currentRadius * correctionSx);\n      if (aligningRing === \"double\") setDoubleOuterAdjust(newAdjust);\n      if (aligningRing === \"treble\") setTrebleOuterAdjust(newAdjust);\n      if (aligningRing === \"bull\") {\n        // Update bull adjustments via Sx temporarily (only for display) - more complex per-ring state could be added\n        setCorrectionSx((prev) => prev * (newAdjust / prev));\n      }\n      setAligningRing(null);\n      console.log(\n        \"[Camera Connection] Aligned \",\n        aligningRing,\n        \" adjust=\",\n        newAdjust.toFixed(4),\n      );\n    }\n    // Use Hcorrected everywhere below (for overlay and for scoring)\n    // If you want to make this user-tunable, expose CORRECTION_SX as a setting\n    // (for now, hardcoded for millimetre alignment)\n    // Note: this means the correction is always applied, including when saving calibration\n    // and when mapping points for scoring.\n    const Hdraw = Hcorrected;\n    if (HH) {\n      console.log(\"[drawOverlay] Using passed homography:\", {\n        HH: HH.slice(0, 6),\n        currentPointsCount: currentPoints.length,\n        canvasSize: { w: o.width, h: o.height },\n      });\n    }\n    if (forceDetectedOnly && detected) {\n      // Force-only: draw detected rings directly and skip homography-based overlay\n      const drawn = drawDetectedRings();\n      console.log(\n        \"[drawOverlay] Forced detected-only drawing, rings drawn:\",\n        drawn,\n      );\n      // Draw sector labels around the double center using detected theta\n      try {\n        const ctx2 = overlayRef.current?.getContext(\"2d\");\n        const hasCtx = !!ctx2 && overlayRef.current;\n        if (hasCtx && detected) {\n          ctx2!.save();\n          ctx2!.font = \"12px Sans-Serif\";\n          ctx2!.fillStyle = \"#ffffff\";\n          ctx2!.strokeStyle = \"#000000\";\n          ctx2!.lineWidth = 3;\n          const labels = SectorOrder; // canonical order\n          const centerX = adjustedCenterX;\n          const centerY = adjustedCenterY;\n          const rLabel = (detected.doubleInner + detected.doubleOuter) / 2 + 14; // just outside double center\n          const thetaVal = typeof theta === \"number\" ? theta : 0;\n          for (let i = 0; i < labels.length; i++) {\n            const ang =\n              (i / labels.length) * Math.PI * 2 - Math.PI / 2 - thetaVal;\n            const lx = centerX + rLabel * Math.cos(ang);\n            const ly = centerY + rLabel * Math.sin(ang);\n            const text = String(labels[i]);\n            const tw = ctx2!.measureText(text).width;\n            ctx2!.strokeText(text, lx - tw / 2, ly + 4);\n            ctx2!.fillText(text, lx - tw / 2, ly + 4);\n          }\n          ctx2!.restore();\n        }\n      } catch {}\n      return; // don't draw homography overlay\n    }\n\n    if (Huse) {\n      // Decide overlay color scheme based on verification and error\n      // Use errorPx from calibration store\n      const errPx = typeof errorPx === \"number\" ? errorPx : null;\n      const hasVerification =\n        verificationResults && verificationResults.length > 0;\n      const allPass = hasVerification\n        ? verificationResults.every((r) => r.match)\n        : null;\n      const passByError = typeof errPx === \"number\" ? errPx <= 1.5 : null; // strict pass threshold\n      const pass = allPass === true || passByError === true;\n      const fail = hasVerification\n        ? verificationResults.some((r) => !r.match)\n        : passByError === false;\n\n      console.log(\"[drawOverlay] Drawing via homography transform\");\n      const rings = [\n        BoardRadii.bullInner,\n        BoardRadii.bullOuter,\n        BoardRadii.trebleInner,\n        BoardRadii.trebleOuter,\n        BoardRadii.doubleInner,\n        BoardRadii.doubleOuter,\n      ];\n      let drawnCount = 0;\n\n      // Use precomputed detectedRingMap above (if present) - no need to recompute here\n\n      // Helper to draw a filled band between inner and outer radii\n      // Use detected radii when available for perfect alignment\n      const drawRingBand = (\n        Hmat: Homography,\n        rInner: number,\n        rOuter: number,\n        fillStyle: string,\n        strokeStyle?: string,\n      ) => {\n        try {\n          const STEPS = 720; // high resolution for smoothness\n\n          // If we have detected radii for both inner and outer, use direct circles\n          const detectedInner = detectedRingMap[rInner];\n          const detectedOuter = detectedRingMap[rOuter];\n          if (detected && detectedInner && detectedOuter) {\n            ctx.save();\n            // subtle shadow to improve contrast over busy backgrounds\n            ctx.shadowColor = \"rgba(0,0,0,0.45)\";\n            ctx.shadowBlur = 6;\n            ctx.beginPath();\n            // Draw ellipses to support horizontal scaling correction\n            if (ctx.ellipse) {\n              ctx.ellipse(\n                adjustedCenterX,\n                adjustedCenterY,\n                detectedOuter * correctionSx,\n                detectedOuter,\n                0,\n                0,\n                Math.PI * 2,\n              );\n              ctx.ellipse(\n                adjustedCenterX,\n                adjustedCenterY,\n                detectedInner * correctionSx,\n                detectedInner,\n                0,\n                0,\n                Math.PI * 2,\n                true,\n              );\n            } else {\n              ctx.arc(\n                adjustedCenterX,\n                adjustedCenterY,\n                detectedOuter,\n                0,\n                Math.PI * 2,\n              );\n              ctx.arc(\n                adjustedCenterX,\n                adjustedCenterY,\n                detectedInner,\n                0,\n                Math.PI * 2,\n                true,\n              );\n            }\n            ctx.closePath();\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n            if (strokeStyle) {\n              ctx.strokeStyle = strokeStyle;\n              ctx.lineWidth = 2;\n              ctx.stroke();\n            }\n            ctx.restore();\n            return true;\n          }\n\n          // Otherwise use homography-based drawing\n          const outer = sampleRing(Hmat, rOuter, STEPS);\n          const inner = sampleRing(Hmat, rInner, STEPS).reverse();\n          if (!outer.length || !inner.length) return false;\n          ctx.save();\n          // subtle shadow to improve contrast over busy backgrounds\n          ctx.shadowColor = \"rgba(0,0,0,0.45)\";\n          ctx.shadowBlur = 6;\n          ctx.beginPath();\n          ctx.moveTo(outer[0].x, outer[0].y);\n          for (let i = 1; i < outer.length; i++)\n            ctx.lineTo(outer[i].x, outer[i].y);\n          for (let i = 0; i < inner.length; i++)\n            ctx.lineTo(inner[i].x, inner[i].y);\n          ctx.closePath();\n          ctx.fillStyle = fillStyle;\n          ctx.fill();\n          if (strokeStyle) {\n            ctx.strokeStyle = strokeStyle;\n            ctx.lineWidth = 2;\n            ctx.stroke();\n          }\n          ctx.restore();\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n      // Draw bands for ONLY bull, treble and double (playable zones)\n      // Do NOT draw any ring outside the double outer rim\n      if (Hdraw) {\n        // Colors: use green when pass, red when fail, else default\n        const bullFill = pass\n          ? \"rgba(0,255,102,0.12)\"\n          : fail\n            ? \"rgba(255,45,45,0.12)\"\n            : \"rgba(52,211,153,0.08)\";\n        const trebleFill = pass\n          ? \"rgba(0,255,102,0.08)\"\n          : fail\n            ? \"rgba(255,45,45,0.08)\"\n            : \"rgba(253,224,71,0.06)\";\n        const doubleFill = pass\n          ? \"rgba(0,255,102,0.06)\"\n          : fail\n            ? \"rgba(255,45,45,0.06)\"\n            : \"rgba(34,211,238,0.06)\";\n\n        // Bull (fill inner and outer ring area) - use real board radii\n        drawRingBand(\n          Hdraw as any,\n          BoardRadii.bullInner,\n          BoardRadii.bullOuter,\n          bullFill,\n          \"rgba(255,255,255,0.06)\",\n        );\n        drawnCount++;\n\n        // Treble band - use DETECTED radii if available, otherwise use calibration guide\n        const trebleInnerToUse =\n          detected?.trebleInner || CalibrationGuideRadii.trebleInner;\n        const trebleOuterToUse =\n          detected?.trebleOuter || CalibrationGuideRadii.trebleOuter;\n        drawRingBand(\n          Hdraw as any,\n          trebleInnerToUse,\n          trebleOuterToUse,\n          trebleFill,\n          \"rgba(255,255,255,0.06)\",\n        );\n        drawnCount++;\n\n        // Double band - use DETECTED radii if available, otherwise use calibration guide\n        const doubleInnerToUse =\n          detected?.doubleInner || CalibrationGuideRadii.doubleInner;\n        const doubleOuterToUse =\n          detected?.doubleOuter || CalibrationGuideRadii.doubleOuter;\n        drawRingBand(\n          Hdraw as any,\n          doubleInnerToUse,\n          doubleOuterToUse,\n          doubleFill,\n          \"rgba(255,255,255,0.06)\",\n        );\n        drawnCount++;\n\n        // Draw ONLY cyan outlines for the playable rings: bullInner, bullOuter, trebleInner, trebleOuter, doubleInner, doubleOuter\n        // Do NOT draw any outer board edge\n        try {\n          const OUTLINE_STEPS = 720;\n          const outlines = [\n            {\n              r: BoardRadii.bullInner,\n              color: pass ? \"#00ff66\" : fail ? \"#ff2d2d\" : \"#ffffff\",\n              key: \"bullInner\",\n            },\n            { r: BoardRadii.bullOuter, color: \"#ffffff\", key: \"bullOuter\" },\n            {\n              r: trebleInnerToUse,\n              color: pass ? \"#00ff66\" : fail ? \"#ff2d2d\" : \"#fde047\",\n              key: \"trebleInner\",\n            },\n            { r: trebleOuterToUse, color: \"#fde047\", key: \"trebleOuter\" },\n            {\n              r: doubleInnerToUse,\n              color: pass ? \"#00ff66\" : fail ? \"#ff2d2d\" : \"#22d3ee\",\n              key: \"doubleInner\",\n            },\n            { r: doubleOuterToUse, color: \"#22d3ee\", key: \"doubleOuter\" }, // <-- Last cyan ring; nothing beyond this\n          ];\n          for (const oline of outlines) {\n            const detectedRadius = detectedRingMap[oline.r];\n            let poly: Point[];\n            if (detected && detectedRadius) {\n              // Use detected radius for direct circle\n              poly = [];\n              for (let i = 0; i < OUTLINE_STEPS; i++) {\n                const angle = (i / OUTLINE_STEPS) * Math.PI * 2;\n                poly.push({\n                  x: adjustedCenterX + detectedRadius * Math.cos(angle),\n                  y: adjustedCenterY + detectedRadius * Math.sin(angle),\n                });\n              }\n            } else {\n              poly = sampleRing(Hdraw as any, oline.r, OUTLINE_STEPS);\n            }\n            // Draw a thin darker stroke then a brighter stroke on top for contrast\n            drawPolyline(ctx, poly, \"rgba(0,0,0,0.45)\", 3);\n            drawPolyline(ctx, poly, oline.color, 1.5);\n          }\n        } catch (err) {\n          // ignore outline errors\n        }\n      }\n      console.log(\"[drawOverlay] Drew\", drawnCount, \"rings via homography\");\n      // Draw sector labels when using homography too (align using theta if present)\n      try {\n        const ctx2 = overlayRef.current?.getContext(\"2d\");\n        const hasCtx = !!ctx2 && overlayRef.current;\n        if (hasCtx) {\n          // Compute board center in image via homography\n          const cImg = applyHomography(Hdraw || HH!, { x: 0, y: 0 });\n          const rCenter =\n            (BoardRadii.doubleInner + BoardRadii.doubleOuter) / 2 + 14;\n          const labels = SectorOrder;\n          ctx2!.save();\n          ctx2!.font = \"12px Sans-Serif\";\n          ctx2!.fillStyle = \"#ffffff\";\n          ctx2!.strokeStyle = \"#000000\";\n          ctx2!.lineWidth = 3;\n          const thetaVal = typeof theta === \"number\" ? theta : 0;\n          for (let i = 0; i < labels.length; i++) {\n            const ang =\n              (i / labels.length) * Math.PI * 2 - Math.PI / 2 - thetaVal;\n            const p = applyHomography(Hdraw || HH!, {\n              x: (rCenter - 14) * Math.cos(ang),\n              y: (rCenter - 14) * Math.sin(ang),\n            });\n            const text = String(labels[i]);\n            const tw = ctx2!.measureText(text).width;\n            ctx2!.strokeText(text, p.x - tw / 2, p.y + 4);\n            ctx2!.fillText(text, p.x - tw / 2, p.y + 4);\n          }\n          ctx2!.restore();\n        }\n      } catch {}\n\n      // PASS/FAIL flash badge (top-right) for ~1.5s after verification\n      if (flashStatus.type && Date.now() < flashStatus.until) {\n        const isPass = flashStatus.type === \"pass\";\n        const bg = isPass ? \"rgba(0,255,102,0.9)\" : \"rgba(255,45,45,0.9)\";\n        const text = isPass ? \"CALIBRATION PASS\" : \"CALIBRATION FAIL\";\n        ctx.save();\n        const pad = 12;\n        const x = o.width - 240 - pad;\n        const y = pad;\n        ctx.fillStyle = bg;\n        ctx.strokeStyle = \"rgba(0,0,0,0.25)\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.roundRect(x, y, 240, 34, 8);\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = \"#00110a\";\n        ctx.font = \"bold 14px system-ui, sans-serif\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(text, x + 12, y + 17);\n        ctx.restore();\n      }\n    }\n    // Always draw detected circles if enabled (for debugging detection accuracy)\n    if (detected && showDetectedOverlay) {\n      console.log(\"[drawOverlay] Drawing detected circles overlay:\", {\n        adjustedCx: Math.round(adjustedCenterX),\n        adjustedCy: Math.round(adjustedCenterY),\n        doubleOuter: Math.round(detected.doubleOuter),\n        trebleOuter: Math.round(detected.trebleOuter),\n        bullOuter: Math.round(detected.bullOuter),\n      });\n      const drawCircle = (r: number, color: string, w = 2) => {\n        if (!Number.isFinite(r) || r <= 0) return;\n        ctx.save();\n        ctx.strokeStyle = color;\n        ctx.lineWidth = w;\n        ctx.setLineDash([5, 5]); // Dashed to distinguish from overlay\n        ctx.beginPath();\n        const radScale = correctionSx; // use uniform scale for debug circles\n        const rx = r * radScale;\n        const ry = r * radScale;\n        if (ctx.ellipse)\n          ctx.ellipse(\n            adjustedCenterX,\n            adjustedCenterY,\n            rx,\n            ry,\n            0,\n            0,\n            Math.PI * 2,\n          );\n        else ctx.arc(adjustedCenterX, adjustedCenterY, r, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.restore();\n      };\n      // Draw detected rings with dashed lines\n      drawCircle(detected.doubleOuter, \"#ff6b6b\", 3); // Red for detected double\n      drawCircle(detected.doubleInner, \"#ff6b6b\", 2);\n      drawCircle(detected.trebleOuter, \"#ffd93d\", 2); // Yellow for detected treble\n      drawCircle(detected.trebleInner, \"#ffd93d\", 2);\n      drawCircle(detected.bullOuter, \"#6bcf7f\", 2); // Green for detected bull\n      drawCircle(detected.bullInner, \"#6bcf7f\", 3);\n\n      // Also draw homography-sampled rings (if Hdraw present) for comparison\n      if (Hdraw && !forceDetectedOnly) {\n        const sampleAndDraw = (rMm: number, color: string) => {\n          const poly = sampleRing(Hdraw as any, rMm, 180);\n          if (!poly.length) return;\n          ctx.save();\n          ctx.setLineDash([6, 4]);\n          ctx.strokeStyle = color;\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.moveTo(poly[0].x, poly[0].y);\n          for (let i = 1; i < poly.length; i++)\n            ctx.lineTo(poly[i].x, poly[i].y);\n          ctx.closePath();\n          ctx.stroke();\n          ctx.restore();\n        };\n        sampleAndDraw(BoardRadii.doubleOuter, \"#00ffff\");\n        sampleAndDraw(BoardRadii.trebleOuter, \"#ffff00\");\n      }\n    }\n    // Display detected metadata for debugging\n    if (detected) {\n      ctx.save();\n      ctx.fillStyle = \"rgba(0,0,0,0.65)\";\n      ctx.fillRect(8, 8, 260, 72);\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"12px system-ui, sans-serif\";\n      ctx.fillText(\n        `Detected cx:${Math.round(detected.cx)} cy:${Math.round(detected.cy)}`,\n        16,\n        28,\n      );\n      ctx.fillText(\n        `Double: ${Math.round(detected.doubleOuter)} Treble: ${Math.round(detected.trebleOuter)}`,\n        16,\n        48,\n      );\n      ctx.fillText(\n        `Adjusts: Sx:${correctionSx.toFixed(3)} Tx:${correctionTx} Ty:${correctionTy}`,\n        16,\n        68,\n      );\n      ctx.restore();\n    }\n\n    // Show calibration guide circles ONLY when we have a freshly computed homography (HH)\n    // from at least 4 clicked points in this session - don't use old stored H for guides\n    // as it may be incorrect and mislead the user\n    const targetPoints = canonicalRimTargets(\"outer\");\n    const showGuides =\n      currentPoints.length >= 4 &&\n      currentPoints.length < targetPoints.length &&\n      HH;\n    if (showGuides) {\n      ctx.save();\n      ctx.strokeStyle = \"rgba(255,193,7,0.4)\";\n      ctx.lineWidth = 2;\n      ctx.setLineDash([4, 4]);\n      // Show the remaining expected click positions (e.g., BULL after D20, D6, D3, D11)\n      for (let i = currentPoints.length; i < targetPoints.length; i++) {\n        try {\n          // Use the same visual correction for guide circles so they align with the rings\n          const p = applyHomography(Hdraw || HH, targetPoints[i]);\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.save();\n          ctx.fillStyle = \"rgba(255,255,255,0.65)\";\n          ctx.font = \"12px sans-serif\";\n          ctx.fillText(\n            CALIBRATION_POINT_LABELS[i] ?? String(i + 1),\n            p.x + 10,\n            p.y - 10,\n          );\n          ctx.restore();\n        } catch {}\n      }\n      ctx.restore();\n    }\n\n    // Show \"Click on X\" instruction prominently on the overlay\n    if (currentPoints.length < REQUIRED_POINT_COUNT) {\n      ctx.save();\n      ctx.fillStyle = \"rgba(0,0,0,0.7)\";\n      ctx.fillRect(10, 10, 200, 40);\n      ctx.fillStyle = \"#fbbf24\";\n      ctx.font = \"bold 16px sans-serif\";\n      ctx.fillText(\n        `Click on ${CALIBRATION_POINT_LABELS[currentPoints.length]}`,\n        20,\n        36,\n      );\n      ctx.restore();\n    }\n\n    // Draw clicked points with sector labels so users know which doubles have been mapped\n    currentPoints.forEach((p, i) => {\n      drawCross(ctx, p, \"#f472b6\");\n      ctx.save();\n      ctx.fillStyle = \"#f472b6\";\n      ctx.font = \"14px sans-serif\";\n      ctx.fillText(\n        CALIBRATION_POINT_LABELS[i] ?? String(i + 1),\n        p.x + 6,\n        p.y - 6,\n      );\n      ctx.restore();\n    });\n\n    // Preferred-view framing guide (if enabled and not yet calibrated)\n    if (calibrationGuide && !locked) {\n      ctx.save();\n      // Semi-transparent vignette to encourage centered, face-on framing\n      ctx.fillStyle = \"rgba(59,130,246,0.10)\";\n      const pad = Math.round(Math.min(o.width, o.height) * 0.08);\n      const w = o.width - pad * 2;\n      const h = o.height - pad * 2;\n      ctx.fillRect(pad, pad, w, h);\n      // Horizon/tilt line and vertical center line\n      ctx.strokeStyle = \"rgba(34,197,94,0.9)\";\n      ctx.lineWidth = 2;\n      // Horizontal line roughly through bull height\n      ctx.beginPath();\n      ctx.moveTo(pad, o.height / 2);\n      ctx.lineTo(o.width - pad, o.height / 2);\n      ctx.stroke();\n      // Vertical center\n      ctx.beginPath();\n      ctx.moveTo(o.width / 2, pad);\n      ctx.lineTo(o.width / 2, o.height - pad);\n      ctx.stroke();\n      // Angle brackets to suggest slight top-down 10–15°\n      ctx.strokeStyle = \"rgba(234,179,8,0.9)\";\n      ctx.setLineDash([6, 4]);\n      const ax = pad + 30,\n        ay = pad + 30;\n      ctx.beginPath();\n      ctx.moveTo(ax, ay + 30);\n      ctx.lineTo(ax + 60, ay);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(o.width - ax, ay + 30);\n      ctx.lineTo(o.width - ax - 60, ay);\n      ctx.stroke();\n      ctx.restore();\n      // Legend - draw at fixed size regardless of zoom\n      ctx.save();\n      ctx.scale(1 / zoom, 1 / zoom); // Inverse scale to keep text static\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      ctx.font = \"12px sans-serif\";\n      ctx.fillText(\n        \"Tip: Frame board centered, edges parallel; slight top-down is okay. Keep bull near center.\",\n        pad * zoom,\n        (pad + 18) * zoom,\n      );\n      ctx.restore();\n    }\n  }\n\n  const applyTestAutoDetectResult = (result: TestAutoDetectResult) => {\n    if (!result) return;\n    setAutoCalibrating(false);\n    setDetected(null);\n    setForceDetectedOnly(false);\n    if (result.anchors?.dst && result.anchors.dst.length > 0) {\n      setDstPoints(result.anchors.dst);\n      drawOverlay(result.anchors.dst, result.H);\n    }\n    // Save the corrected H so scoring and overlay match\n    // Save the corrected H (with scale and translation) so scoring and overlay match\n    let Hcal = result.H;\n    if (correctionSx !== 1) Hcal = scaleHomography(Hcal, correctionSx, 1);\n    if (correctionTx !== 0 || correctionTy !== 0)\n      Hcal = translateHomography(Hcal, correctionTx, correctionTy);\n    setCalibration({\n      H: Hcal,\n      createdAt: Date.now(),\n      errorPx: result.errorPx,\n      imageSize: result.imageSize,\n      overlaySize: result.overlaySize,\n      anchors: result.anchors,\n      locked: result.locked,\n    });\n    setPhase(result.phase ?? \"computed\");\n    setConfidence(result.confidence ?? 100);\n    setDetectionMessage(\"Test auto-detect applied\");\n    delete (globalThis as any).__TEST_AUTO_DETECT_RESULT;\n  };\n\n  function onClickOverlay(e: React.PointerEvent<HTMLCanvasElement>) {\n    console.debug(\"[Camera Connection] onClickOverlay entry\", phase, e.type);\n    e.stopPropagation();\n    e.preventDefault();\n    // For selection mode allow adding anchor points, but for computed mode we interpret as a test click\n    // Also allow camera mode when autocommit test mode is enabled so tests can simulate a click-to-detect\n    const allowCameraClick =\n      (phase === \"camera\" || phase === \"capture\") && autoCommitTestMode;\n    if (phase !== \"select\" && phase !== \"computed\" && !allowCameraClick) return;\n    const el = e.target as HTMLCanvasElement;\n    const rect = el.getBoundingClientRect();\n    const cssX = e.clientX - rect.left;\n    const cssY = e.clientY - rect.top;\n    // Map CSS coordinates back to the overlay canvas pixel coordinates, accounting for CSS scaling and zoom\n    const scaleX =\n      el.width > 0\n        ? el.width /\n          (rect.width || canvasRef.current?.clientWidth || rect.width)\n        : 1;\n    const scaleY =\n      el.height > 0\n        ? el.height /\n          (rect.height || canvasRef.current?.clientHeight || rect.height)\n        : 1;\n    const x = cssX * scaleX;\n    const y = cssY * scaleY;\n    console.debug(\"[Camera Connection] onClickOverlay css/x/y\", {\n      cssX,\n      cssY,\n      scaleX,\n      scaleY,\n      x,\n      y,\n    });\n    if (phase === \"select\") {\n      console.log(\n        \"[Camera Connection] Adding point. Current dstPoints.length:\",\n        dstPoints.length,\n        \"New point:\",\n        { x, y },\n      );\n      const pts = [...dstPoints, { x, y }];\n      console.log(\n        \"[Camera Connection] After add, pts.length:\",\n        pts.length,\n        \"REQUIRED:\",\n        REQUIRED_POINT_COUNT,\n      );\n      if (pts.length <= REQUIRED_POINT_COUNT) {\n        setDstPoints(pts);\n        // If we have 4+ points, compute a temporary homography to show guide for remaining points\n        if (pts.length >= 4) {\n          const src = canonicalRimTargets(\"outer\");\n          const tempH = computeHomographyDLT(src.slice(0, 4), pts.slice(0, 4));\n          drawOverlay(pts, tempH);\n        } else {\n          drawOverlay(pts);\n        }\n      }\n      return;\n    }\n    const testClickValue = (globalThis as any).__TEST_CALIBRATION_CLICK_VALUE;\n    let val: number | null = null;\n    let label = \"\";\n    let detectionMeta: {\n      pBoard: ReturnType<typeof imageToBoard>;\n      scoreObj: ReturnType<typeof scoreAtBoardPoint>;\n    } | null = null;\n    try {\n      if (typeof testClickValue === \"number\") {\n        val = testClickValue;\n        label = `TEST ${val}`;\n        const fallbackScoreObj = {\n          base: val,\n          mult: 1,\n          ring: \"SINGLE\",\n          sector: null,\n        } as ReturnType<typeof scoreAtBoardPoint>;\n        detectionMeta = {\n          scoreObj: fallbackScoreObj,\n          pBoard: { x: 0, y: 0 } as ReturnType<typeof imageToBoard>,\n        };\n        delete (globalThis as any).__TEST_CALIBRATION_CLICK_VALUE;\n      } else {\n        const calibState = (useCalibration as any).getState\n          ? (useCalibration as any).getState()\n          : undefined;\n        const Hcur = calibState?.H ?? H;\n        const imgSize = calibState?.imageSize ?? imageSize;\n        console.debug(\"[Camera Connection] onClickOverlay state\", {\n          Hcur,\n          imgSize,\n        });\n        if (!Hcur || !overlayRef.current || !imgSize) return;\n        const o = overlayRef.current;\n        // Some test environments may not set canvas width/height; fall back to CSS bounding rect\n        const rect2 = o.getBoundingClientRect();\n        const fallbackWidth =\n          canvasRef.current && canvasRef.current.width\n            ? canvasRef.current.width\n            : rect2.width;\n        const fallbackHeight =\n          canvasRef.current && canvasRef.current.height\n            ? canvasRef.current.height\n            : rect2.height;\n        const sx =\n          o.width && imgSize.w\n            ? o.width / imgSize.w\n            : fallbackWidth / imgSize.w;\n        const sy =\n          o.height && imgSize.h\n            ? o.height / imgSize.h\n            : fallbackHeight / imgSize.h;\n        console.debug(\"[Camera Connection] onClickOverlay dims\", {\n          oWidth: o.width,\n          oHeight: o.height,\n          rectWidth: rect2.width,\n          rectHeight: rect2.height,\n          fallbackWidth,\n          fallbackHeight,\n          sx,\n          sy,\n        });\n        const clientWidth = rect2.width || fallbackWidth;\n        const clientHeight = rect2.height || fallbackHeight;\n        const fracX = clientWidth ? cssX / clientWidth : 0;\n        const fracY = clientHeight ? cssY / clientHeight : 0;\n        const pCal = { x: fracX * imgSize.w, y: fracY * imgSize.h };\n        const pBoard = imageToBoard(Hcur as any, pCal);\n        console.debug(\n          \"[Camera Connection] onClickOverlay pCal/pBoard\",\n          pCal,\n          pBoard,\n        );\n        if (!pBoard) {\n          console.warn(\n            \"[Camera Connection] Failed to map point to board - homography inversion failed\",\n          );\n          return;\n        }\n        const scoreObj = scoreAtBoardPointTheta(\n          pBoard,\n          typeof theta === \"number\" ? theta : 0,\n          sectorOffset ?? 0,\n        );\n        detectionMeta = { scoreObj, pBoard };\n        val = scoreObj.base;\n        // If user/test click is on bull or inner bull, capture an image-space center hint for auto-calibrate\n        if (scoreObj.ring === \"BULL\" || scoreObj.ring === \"INNER_BULL\") {\n          setBullHint(pCal);\n        }\n        console.debug(\n          \"[Camera Connection] autoCommitTestMode\",\n          autoCommitTestMode,\n        );\n        if (autoCommitTestMode && val === 0) {\n          val = 25;\n        }\n        label = `${scoreObj.ring} ${val}`.trim();\n      }\n      if (val == null) return;\n      setLastDetectedValue(val);\n      console.debug(\"[Camera Connection] onClickOverlay detected\", val, label);\n      setLastDetectedLabel(label);\n      try {\n        const calibSt = (useCalibration as any).getState\n          ? (useCalibration as any).getState()\n          : undefined;\n        const calibrationValidSt =\n          !!calibSt?.H &&\n          !!calibSt?.imageSize &&\n          (calibSt.locked ||\n            (typeof calibSt.errorPx === \"number\" &&\n              calibSt.errorPx <= ERROR_PX_MAX));\n        if (\n          autoCommitTestMode &&\n          !autoCommitImmediate &&\n          calibrationValidSt &&\n          useMatch.getState().inProgress\n        ) {\n          doCommit(val);\n        }\n      } catch {}\n      if (\n        autoCommitTestMode &&\n        autoCommitImmediate &&\n        useMatch.getState().inProgress\n      ) {\n        const calibSt2 = (useCalibration as any).getState\n          ? (useCalibration as any).getState()\n          : (undefined as any);\n        const calibrationValidSt2 =\n          !!calibSt2?.H &&\n          !!calibSt2?.imageSize &&\n          (calibSt2.locked ||\n            (typeof calibSt2.errorPx === \"number\" &&\n              calibSt2.errorPx <= ERROR_PX_MAX));\n        if (!calibrationValidSt2) {\n          console.debug(\n            \"[Camera Connection] immediate autocommit skipped due to invalid calibration\",\n            { calibrationValidSt2 },\n          );\n        } else {\n          const isOnline = useMatch.getState().roomId !== \"\";\n          console.debug(\"[Camera Connection] immediate-branch conditions\", {\n            autoCommitTestMode,\n            autoCommitImmediate,\n            inProgress: useMatch.getState().inProgress,\n            isOnline,\n          });\n          if (!isOnline) {\n            const sig = `${val}|3`;\n            const now = performance.now();\n            if (\n              !inFlightAutoCommitRef.current &&\n              !(\n                sig === lastAutoSigRef.current &&\n                now - lastAutoSigAtRef.current < AUTO_COMMIT_COOLDOWN_MS\n              )\n            ) {\n              lastAutoSigRef.current = sig;\n              lastAutoSigAtRef.current = now;\n              inFlightAutoCommitRef.current = true;\n              useMatch.getState().addVisit(val, 3, { visitTotal: val });\n              try {\n                window.setTimeout(\n                  () => {\n                    inFlightAutoCommitRef.current = false;\n                  },\n                  Math.max(120, AUTO_COMMIT_COOLDOWN_MS),\n                );\n              } catch (e) {}\n            }\n          } else if (allowAutocommitInOnline) {\n            if (!detectionMeta) {\n              console.debug(\n                \"[Camera Connection] immediate autocommit skipped, detection metadata missing\",\n              );\n            } else {\n              const { pBoard, scoreObj } = detectionMeta;\n              try {\n                console.debug(\"[Camera Connection] sending auto-visit\", {\n                  roomId: useMatch.getState().roomId,\n                  allowAutocommitInOnline,\n                });\n                useWS().send({\n                  type: \"auto-visit\",\n                  roomId: useMatch.getState().roomId,\n                  value: val,\n                  darts: 3,\n                  ring: scoreObj.ring,\n                  sector: scoreObj.sector,\n                  pBoard,\n                  calibrationValid: true,\n                });\n              } catch (e) {\n                console.debug(\n                  \"[Camera Connection] immediate autocommit remote send failed\",\n                  e,\n                );\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      /* ignore */\n    }\n  }\n\n  function doCommit(val?: number) {\n    try {\n      const v = typeof val === \"number\" ? val : lastDetectedValue;\n      console.debug(\"[Camera Connection] doCommit invoked\", {\n        v,\n        inProgress: useMatch.getState().inProgress,\n      });\n      // Only commit when calibration is (still) valid; re-evaluate store state at call-time\n      const calState = (useCalibration as any).getState\n        ? (useCalibration as any).getState()\n        : (undefined as any);\n      const curCalValid =\n        !!calState?.H &&\n        !!calState?.imageSize &&\n        (calState.locked ||\n          (typeof calState.errorPx === \"number\" &&\n            calState.errorPx <= ERROR_PX_MAX));\n      if (v != null && useMatch.getState().inProgress && curCalValid) {\n        // prevent double commits by checking cooldown signature\n        const sig = `${v}|3`;\n        const now = performance.now();\n        if (\n          !inFlightAutoCommitRef.current &&\n          !(\n            sig === lastAutoSigRef.current &&\n            now - lastAutoSigAtRef.current < AUTO_COMMIT_COOLDOWN_MS\n          )\n        ) {\n          lastAutoSigRef.current = sig;\n          lastAutoSigAtRef.current = now;\n          inFlightAutoCommitRef.current = true;\n          console.debug(\"[Camera Connection] doCommit: committing visit\", v, {\n            calState,\n            curCalValid,\n          });\n          try {\n            useMatch.getState().addVisit(v, 3, { visitTotal: v });\n          } catch (e) {}\n          try {\n            window.setTimeout(\n              () => {\n                inFlightAutoCommitRef.current = false;\n              },\n              Math.max(120, AUTO_COMMIT_COOLDOWN_MS),\n            );\n          } catch (e) {}\n        } else {\n          console.debug(\n            \"[Camera Connection] doCommit: deduped commit skipped\",\n            {\n              v,\n              curCalValid,\n              sig,\n            },\n          );\n        }\n      } else {\n        console.debug(\n          \"[Camera Connection] doCommit: NOT committing (invalid cal or no match)\",\n          {\n            v,\n            inProgress: useMatch.getState().inProgress,\n            curCalValid,\n            calState,\n          },\n        );\n      }\n    } catch (e) {}\n  }\n\n  function undoPoint() {\n    const pts = dstPoints.slice(0, -1);\n    setDstPoints(pts);\n    drawOverlay(pts);\n  }\n\n  function refinePoints() {\n    if (!canvasRef.current || dstPoints.length === 0) return;\n    const refined = refinePointsSobel(canvasRef.current, dstPoints, 8);\n    setDstPoints(refined);\n    drawOverlay(refined);\n  }\n\n  function compute() {\n    if (!canvasRef.current) return null;\n    if (dstPoints.length < REQUIRED_POINT_COUNT) {\n      alert(\n        \"Click the 5 alignment points: D20, D6, D3, D11, and Bullseye (center).\",\n      );\n      return null;\n    }\n    try {\n      const src = canonicalRimTargets(\"outer\"); // board space mm\n      // Use all 5 points (including bullseye) for better accuracy\n      // Ensure we have exactly 5 points for the homography calculation to match src\n      const dst = dstPoints.slice(0, 5);\n\n      const Hcalc = computeHomographyDLT(src, dst);\n      drawOverlay(dstPoints, Hcalc);\n      const err = rmsError(Hcalc, src, dst);\n      const overlaySize = overlayRef?.current\n        ? { w: overlayRef.current.width, h: overlayRef.current.height }\n        : videoRef?.current\n          ? {\n              w: videoRef.current.clientWidth,\n              h: videoRef.current.clientHeight,\n            }\n          : { w: canvasRef.current.width, h: canvasRef.current.height };\n\n      // Use actual video frame dimensions for imageSize, not canvas display dimensions\n      // This ensures correct scaling when CameraView draws the video to its own canvas\n      const actualImageSize = videoRef.current\n        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }\n        : { w: canvasRef.current.width, h: canvasRef.current.height };\n\n      setCalibration({\n        H: Hcalc as Homography,\n        createdAt: Date.now(),\n        errorPx: err,\n        imageSize: actualImageSize,\n        overlaySize,\n        anchors: { src, dst: dstPoints }, // Save all points including any extras\n      });\n      setConfidence(100);\n      setPhase(\"computed\");\n      return Hcalc as Homography;\n    } catch (e) {\n      console.error(\"[Camera Connection] Compute failed:\", e);\n      alert(\"Alignment failed. Try clearing points and clicking them again.\");\n      return null;\n    }\n  }\n\n  function runVerification() {\n    if (!H || !overlayRef.current) {\n      alert(\"Lock the camera connection before running this check.\");\n      return;\n    }\n    // Prefer using the locked anchors from calibration store if available, to ensure we verify what was actually computed\n    const pointsToVerify =\n      anchors?.dst && anchors.dst.length >= 4 ? anchors.dst : dstPoints;\n\n    if (pointsToVerify.length < 4) {\n      alert(\n        \"Select at least the four double-ring points before running this check.\",\n      );\n      return;\n    }\n    const overlayCanvas = overlayRef.current;\n    const ctx = overlayCanvas.getContext(\"2d\");\n    if (!ctx) {\n      console.warn(\n        \"[Camera Connection] Overlay context missing for verification\",\n      );\n      return;\n    }\n    drawOverlay(pointsToVerify, H);\n    const canonicalTargets = canonicalRimTargets(\"outer\");\n    const results: VerificationResult[] = VERIFICATION_ANCHORS.map((anchor) => {\n      const actualPoint = pointsToVerify[anchor.idx];\n      const expectedBoard = canonicalTargets[anchor.idx];\n      if (!actualPoint || !expectedBoard) {\n        return {\n          label: anchor.label,\n          expected: { ring: anchor.ring, sector: anchor.sector },\n          detected: null,\n          deltaMm: null,\n          deltaPx: null,\n          match: false,\n          note: \"Point missing — click this anchor to verify\",\n        };\n      }\n      const projectedImage = applyHomography(H as any, expectedBoard);\n      const boardFromActual = imageToBoard(H as any, actualPoint);\n      if (!boardFromActual) {\n        // If homography inversion failed, treat as mismatch\n        return {\n          label: anchor.label,\n          expected: { ring: anchor.ring, sector: anchor.sector },\n          detected: null,\n          deltaMm: null,\n          deltaPx: null,\n          match: false,\n          note: \"Homography inversion failed - recalibrate\",\n        };\n      }\n      const detectedScore = scoreAtBoardPointTheta(\n        boardFromActual,\n        typeof theta === \"number\" ? theta : 0,\n        sectorOffset ?? 0,\n      );\n      const deltaMm = Math.hypot(\n        boardFromActual.x - expectedBoard.x,\n        boardFromActual.y - expectedBoard.y,\n      );\n      const deltaPx = Math.hypot(\n        actualPoint.x - projectedImage.x,\n        actualPoint.y - projectedImage.y,\n      );\n      const ringMatch =\n        anchor.ring === \"INNER_BULL\"\n          ? detectedScore.ring === \"INNER_BULL\" || detectedScore.ring === \"BULL\"\n          : detectedScore.ring === anchor.ring;\n      const sectorMatch =\n        anchor.sector == null || detectedScore.sector === anchor.sector;\n      const withinTolerance = deltaMm <= anchor.toleranceMm;\n      const match = ringMatch && sectorMatch && withinTolerance;\n\n      // Detailed logging for debugging tolerance mismatch\n      console.log(`[Verification] ${anchor.label}:`, {\n        anchor: anchor,\n        actualPoint: {\n          x: actualPoint.x.toFixed(1),\n          y: actualPoint.y.toFixed(1),\n        },\n        expectedBoard: {\n          x: expectedBoard.x.toFixed(2),\n          y: expectedBoard.y.toFixed(2),\n        },\n        projectedImage: {\n          x: projectedImage.x.toFixed(1),\n          y: projectedImage.y.toFixed(1),\n        },\n        boardFromActual: {\n          x: boardFromActual.x.toFixed(2),\n          y: boardFromActual.y.toFixed(2),\n        },\n        detectedScore: detectedScore,\n        deltaMm: deltaMm.toFixed(2),\n        deltaPx: deltaPx.toFixed(1),\n        toleranceMm: anchor.toleranceMm,\n        ringMatch,\n        sectorMatch,\n        withinTolerance,\n        match,\n      });\n\n      drawCross(ctx, actualPoint, match ? \"#10b981\" : \"#ef4444\");\n      ctx.save();\n      ctx.fillStyle = match ? \"#10b981\" : \"#ef4444\";\n      ctx.font = \"12px sans-serif\";\n      ctx.fillText(\n        `${anchor.label} · ${deltaMm.toFixed(1)}mm`,\n        actualPoint.x + 6,\n        actualPoint.y - 6,\n      );\n      ctx.restore();\n      let note: string | undefined;\n      if (!ringMatch || !sectorMatch) {\n        note = \"Sector/ring mismatch\";\n      } else if (!withinTolerance) {\n        note = `Off by ${deltaMm.toFixed(1)}mm (limit ±${anchor.toleranceMm}mm)`;\n      }\n      return {\n        label: anchor.label,\n        expected: { ring: anchor.ring, sector: anchor.sector },\n        detected: detectedScore,\n        deltaMm,\n        deltaPx,\n        match,\n        note,\n      };\n    });\n    setVerificationResults(results);\n    console.log(`[Camera Connection] Verification complete:`, results);\n    // Trigger PASS/FAIL flash for user feedback\n    const allPass = results.every((r) => r.match);\n    triggerFlash(allPass, 1500);\n  }\n\n  // Auto-resize the board - AGGRESSIVE: Recompute homography directly from all 5 points\n  async function autoResizeBoard() {\n    if (!H) {\n      alert(\"Please save the calibration first (click Save).\");\n      return;\n    }\n\n    if (verificationResults.length === 0) {\n      console.log(\n        \"[Camera Connection] Verification not run yet, running now before resize...\",\n      );\n      runVerification();\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n\n    const canonicalTargets = canonicalRimTargets(\"outer\");\n    const pointsToVerify =\n      anchors?.dst && anchors.dst.length >= 4 ? anchors.dst : dstPoints;\n\n    if (pointsToVerify.length < 5) {\n      alert(\"Need at least 5 connection points to resize.\");\n      return;\n    }\n\n    console.log(\n      `[Camera Connection] Starting AGGRESSIVE resize: Recomputing homography from all 5 points`,\n    );\n\n    // NUCLEAR OPTION: Recompute homography using all 5 points directly\n    // This forces the homography to map the clicked points to the expected board positions\n    const src = canonicalTargets.slice(0, 5); // Expected board positions (in mm)\n    const dst = pointsToVerify.slice(0, 5); // Actual clicked image positions\n\n    try {\n      // Recompute homography using DLT (Direct Linear Transform)\n      // This will find the H that best fits all 5 points\n      const newH = computeHomographyDLT(src, dst);\n\n      console.log(`[Camera Connection] Recomputed homography from 5 points`);\n\n      // Verify the new homography\n      const verifyResults = VERIFICATION_ANCHORS.map((anchor) => {\n        const actualPoint = pointsToVerify[anchor.idx];\n        const expectedBoard = canonicalTargets[anchor.idx];\n        if (!actualPoint || !expectedBoard) {\n          return {\n            match: false,\n            deltaMm: null,\n            ringMatch: false,\n            sectorMatch: false,\n          };\n        }\n        const boardFromActual = imageToBoard(newH as any, actualPoint);\n        if (!boardFromActual) {\n          return {\n            match: false,\n            deltaMm: null,\n            ringMatch: false,\n            sectorMatch: false,\n          };\n        }\n        const detectedScore = scoreAtBoardPointTheta(\n          boardFromActual,\n          typeof theta === \"number\" ? theta : 0,\n          sectorOffset ?? 0,\n        );\n        const deltaMm = Math.hypot(\n          boardFromActual.x - expectedBoard.x,\n          boardFromActual.y - expectedBoard.y,\n        );\n        const ringMatch =\n          anchor.ring === \"INNER_BULL\"\n            ? detectedScore.ring === \"INNER_BULL\" ||\n              detectedScore.ring === \"BULL\"\n            : detectedScore.ring === anchor.ring;\n        const sectorMatch =\n          anchor.sector == null || detectedScore.sector === anchor.sector;\n        const withinTolerance = deltaMm <= anchor.toleranceMm;\n        const match = ringMatch && sectorMatch && withinTolerance;\n\n        console.log(\n          `  Anchor ${anchor.label}: ring=${ringMatch}, sector=${sectorMatch}, deltaMm=${deltaMm.toFixed(2)}`,\n        );\n        return {\n          match,\n          deltaMm,\n          ringMatch,\n          sectorMatch,\n          detectedScore,\n          expectedBoard,\n        };\n      });\n\n      const passCount = verifyResults.filter((r) => r.match).length;\n      const totalCount = verifyResults.length;\n\n      console.log(\n        `[Camera Connection] Result: ${passCount}/${totalCount} anchors pass`,\n      );\n\n      // Save the recalibrated homography\n      const overlaySize = overlayRef?.current\n        ? { w: overlayRef.current.width, h: overlayRef.current.height }\n        : videoRef?.current\n          ? {\n              w: videoRef.current.clientWidth,\n              h: videoRef.current.clientHeight,\n            }\n          : { w: canvasRef.current!.width, h: canvasRef.current!.height };\n\n      const actualImageSize = videoRef.current\n        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }\n        : { w: canvasRef.current!.width, h: canvasRef.current!.height };\n\n      const err = rmsError(newH, src, dst);\n      setCalibration({\n        H: newH,\n        createdAt: Date.now(),\n        errorPx: err,\n        imageSize: actualImageSize,\n        overlaySize,\n        anchors: { src, dst },\n      });\n\n      drawOverlay(pointsToVerify, newH);\n      runVerificationWithH(newH);\n\n      if (passCount === totalCount) {\n        console.log(`[Camera Connection] ✅ PERFECT! All 5 anchors pass!`);\n        alert(\n          `✅ PERFECT CALIBRATION!\\n\\nAll 5 anchors pass! Your dartboard is perfectly calibrated.`,\n        );\n      } else {\n        console.warn(\n          `[Camera Connection] Only ${passCount}/5 anchors pass. Anchors may be clicked incorrectly.`,\n        );\n        alert(\n          `⚠️ Resize Result: ${passCount}/5 anchors pass.\\n\\nThe anchors showing red \"Adjust\" may have been clicked on the wrong ring.\\n\\nPlease re-click those anchors more carefully, then try Resize again.`,\n        );\n      }\n    } catch (e) {\n      console.error(`[Camera Connection] Error recomputing homography:`, e);\n      alert(\n        `❌ Error: Could not recompute calibration.\\n\\nYour anchor clicks may be invalid.\\n\\nPlease recalibrate from scratch.`,\n      );\n    }\n  }\n\n  // Helper function to run verification with a specific homography\n  function runVerificationWithH(verifyH: Homography) {\n    const canonicalTargets = canonicalRimTargets(\"outer\");\n    const pointsToVerify =\n      anchors?.dst && anchors.dst.length >= 4 ? anchors.dst : dstPoints;\n\n    if (pointsToVerify.length < 4) return;\n\n    const results: VerificationResult[] = VERIFICATION_ANCHORS.map((anchor) => {\n      const actualPoint = pointsToVerify[anchor.idx];\n      const expectedBoard = canonicalTargets[anchor.idx];\n      if (!actualPoint || !expectedBoard) {\n        return {\n          label: anchor.label,\n          expected: { ring: anchor.ring, sector: anchor.sector },\n          detected: null,\n          deltaMm: null,\n          deltaPx: null,\n          match: false,\n          note: \"Point missing — click this anchor to verify\",\n        };\n      }\n      const projectedImage = applyHomography(verifyH, expectedBoard);\n      const boardFromActual = imageToBoard(verifyH as any, actualPoint);\n      if (!boardFromActual) {\n        // If homography inversion failed, treat as mismatch\n        return {\n          label: anchor.label,\n          expected: { ring: anchor.ring, sector: anchor.sector },\n          detected: null,\n          deltaMm: null,\n          deltaPx: null,\n          match: false,\n          note: \"Homography inversion failed - recalibrate\",\n        };\n      }\n      const detectedScore = scoreAtBoardPointTheta(\n        boardFromActual,\n        typeof theta === \"number\" ? theta : 0,\n        sectorOffset ?? 0,\n      );\n      const deltaMm = Math.hypot(\n        boardFromActual.x - expectedBoard.x,\n        boardFromActual.y - expectedBoard.y,\n      );\n      const deltaPx = Math.hypot(\n        actualPoint.x - projectedImage.x,\n        actualPoint.y - projectedImage.y,\n      );\n      const ringMatch =\n        anchor.ring === \"INNER_BULL\"\n          ? detectedScore.ring === \"INNER_BULL\" || detectedScore.ring === \"BULL\"\n          : detectedScore.ring === anchor.ring;\n      const sectorMatch =\n        anchor.sector == null || detectedScore.sector === anchor.sector;\n      const withinTolerance = deltaMm <= anchor.toleranceMm;\n      const match = ringMatch && sectorMatch && withinTolerance;\n\n      let note: string | undefined;\n      if (!ringMatch || !sectorMatch) {\n        note = \"Sector/ring mismatch\";\n      } else if (!withinTolerance) {\n        note = `Off by ${deltaMm.toFixed(1)}mm (limit ±${anchor.toleranceMm}mm)`;\n      }\n\n      const result = {\n        label: anchor.label,\n        expected: { ring: anchor.ring, sector: anchor.sector },\n        detected: detectedScore,\n        deltaMm,\n        deltaPx,\n        match,\n        note,\n      } as VerificationResult;\n      return result;\n    });\n\n    // Auto-estimate sectorOffset if there is a consistent whole-sector mismatch\n    try {\n      const diffs: number[] = [];\n      for (const r of results) {\n        if (\n          r.expected.ring === \"DOUBLE\" &&\n          r.expected.sector != null &&\n          r.detected?.sector != null\n        ) {\n          const expected = r.expected.sector as number;\n          const detected = r.detected.sector as number;\n          const expIdx = SectorOrder.indexOf(expected);\n          const detIdx = SectorOrder.indexOf(detected);\n          if (expIdx >= 0 && detIdx >= 0) {\n            let diff = detIdx - expIdx;\n            if (diff > 10) diff -= 20;\n            if (diff < -10) diff += 20;\n            diffs.push(diff);\n          }\n        }\n      }\n      if (diffs.length >= 3) {\n        const counts = new Map<number, number>();\n        for (const d of diffs) counts.set(d, (counts.get(d) ?? 0) + 1);\n        let best = 0,\n          bestN = 0;\n        for (const [d, n] of counts.entries()) {\n          if (n > bestN) {\n            bestN = n;\n            best = d;\n          }\n        }\n        const current = sectorOffset ?? 0;\n        if (bestN >= 2 && best !== current) {\n          setCalibration({ sectorOffset: best });\n        }\n      }\n    } catch {}\n\n    setVerificationResults(results);\n  }\n\n  function resetAll() {\n    setDstPoints([]);\n    setHasSnapshot(false);\n    setPhase(\"camera\");\n    drawOverlay([]);\n    setMarkerResult(null);\n    reset();\n  }\n\n  // --- Auto-detect the double rim from the current snapshot and compute homography ---\n  async function autoDetectRings() {\n    try {\n      console.debug(\"[Camera Connection] autoDetectRings invoked\");\n      if (!canvasRef.current) {\n        alert(\"Load a photo or capture a frame first.\");\n        setAutoCalibrating(false);\n        return;\n      }\n      const testAutoDetectResult = (globalThis as any)\n        .__TEST_AUTO_DETECT_RESULT as TestAutoDetectResult | undefined;\n      if (testAutoDetectResult) {\n        console.debug(\n          \"[Camera Connection] testAutoDetectResult detected (legacy)\",\n        );\n        applyTestAutoDetectResult(testAutoDetectResult);\n        return;\n      }\n      setAutoCalibrating(true);\n      setDetectionMessage(\"Using advanced detection algorithm...\");\n      setMarkerResult(null);\n\n      // Use the advanced detectBoard algorithm instead of the legacy circle search\n      // The legacy algorithm is not robust enough for various lighting conditions\n      const refined = detectBoard(\n        canvasRef.current!,\n        bullHint\n          ? { centerHint: bullHint, colorAssist: true }\n          : { colorAssist: true },\n      );\n\n      console.log(\n        \"[Camera Connection] detectBoard returned:\",\n        {\n          success: refined.success,\n          confidence: refined.confidence,\n          hasHomography: !!refined.homography,\n          numPoints: refined.calibrationPoints.length,\n        },\n        refined.message,\n      );\n\n      if (!refined.success || !refined.homography || refined.confidence < 40) {\n        console.warn(\"[Camera Connection] Auto-detect failed, result:\", {\n          success: refined.success,\n          confidence: refined.confidence,\n          hasHomography: !!refined.homography,\n        });\n        setDetectionMessage(\n          refined.message ||\n            \"❌ Detection failed. Try better lighting or different angle.\",\n        );\n        setAutoCalibrating(false);\n        return;\n      }\n\n      // Apply detection results\n      setDetected({\n        cx: refined.cx,\n        cy: refined.cy,\n        bullInner: refined.bullInner,\n        bullOuter: refined.bullOuter,\n        trebleInner: refined.trebleInner,\n        trebleOuter: refined.trebleOuter,\n        doubleInner: refined.doubleInner,\n        doubleOuter: refined.doubleOuter,\n      });\n      // Auto-enable forced detected-only overlay to let the user see the detected circles immediately\n      setForceDetectedOnly(true);\n      setDstPoints(refined.calibrationPoints);\n      drawOverlay(refined.calibrationPoints, refined.homography);\n\n      // Store calibration\n      const overlaySize = overlayRef?.current\n        ? { w: overlayRef.current.width, h: overlayRef.current.height }\n        : videoRef?.current\n          ? {\n              w: videoRef.current.clientWidth,\n              h: videoRef.current.clientHeight,\n            }\n          : { w: canvasRef.current.width, h: canvasRef.current.height };\n      const actualImageSize = videoRef.current\n        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }\n        : { w: canvasRef.current.width, h: canvasRef.current.height };\n\n      // Auto-estimate sector offset from homography so 20 aligns to top\n      const autoOffset = estimateSectorOffsetFromHomography(\n        refined.homography,\n        \"outer\",\n      );\n\n      setCalibration({\n        H: refined.homography as Homography,\n        createdAt: Date.now(),\n        errorPx: refined.errorPx ?? null,\n        imageSize: actualImageSize,\n        overlaySize,\n        anchors: {\n          src: canonicalRimTargets(\"outer\").slice(0, 4),\n          dst: refined.calibrationPoints,\n        },\n        theta: typeof refined.theta === \"number\" ? refined.theta : null,\n        sectorOffset: autoOffset,\n      });\n\n      // Verify that detected rings match the actual board\n      const verificationResults = verifyCalibration(\n        refined.homography as Homography,\n        refined.calibrationPoints,\n      );\n      setVerificationResults(verificationResults);\n\n      setPhase(\"verify\");\n      setConfidence(forceConfidence ? 100 : Math.round(refined.confidence));\n      setDetectionMessage(\n        `✅ Detected rings — Please verify alignment by looking at the overlay`,\n      );\n      setAutoCalibrating(false);\n\n      // Validate stability\n      try {\n        const runs = 3;\n        let stableCount = 1;\n        for (let i = 1; i < runs; i++) {\n          const tmp = document.createElement(\"canvas\");\n          tmp.width = Math.max(1, Math.round(canvasRef.current!.width * 0.9));\n          tmp.height = Math.max(1, Math.round(canvasRef.current!.height * 0.9));\n          const tctx = tmp.getContext(\"2d\")!;\n          tctx.drawImage(canvasRef.current!, 0, 0, tmp.width, tmp.height);\n          const hintScaledA = bullHint\n            ? {\n                centerHint: { x: bullHint.x * 0.9, y: bullHint.y * 0.9 },\n                colorAssist: true,\n              }\n            : { colorAssist: true };\n          const bd = detectBoard(tmp as any as HTMLCanvasElement, hintScaledA);\n          if (isSimilarDetection(refined as any, bd as any)) stableCount++;\n        }\n        const stable = stableCount >= Math.ceil(runs * 0.66);\n        if (stable) {\n          // Don't auto-lock yet - let user verify first\n          console.log(\"[Camera Connection] Detection is stable\");\n        }\n      } catch (err) {\n        console.warn(\"[Camera Connection] Legacy stability check failed:\", err);\n      }\n    } catch (err) {\n      console.error(\"[Camera Connection] autoDetectRings failed:\", err);\n      setDetectionMessage(\n        `❌ Auto-detect failed: ${err instanceof Error ? err.message : String(err)}`,\n      );\n      setAutoCalibrating(false);\n    }\n  }\n\n  // Check that auto-detected camera connection matches the actual dartboard\n  function verifyCalibration(\n    H: Homography,\n    connectionPoints: Point[],\n  ): VerificationResult[] {\n    const results: VerificationResult[] = [];\n\n    if (!H || !connectionPoints || connectionPoints.length === 0) {\n      return results;\n    }\n\n    // Check each verification anchor point\n    for (const anchor of VERIFICATION_ANCHORS) {\n      if (anchor.idx >= connectionPoints.length) continue;\n\n      const imgPoint = connectionPoints[anchor.idx];\n      let boardPoint: Point | null = null;\n\n      try {\n        boardPoint = imageToBoard(H, imgPoint);\n      } catch (err) {\n        console.warn(\n          \"[Camera Connection] Failed to convert image point to board space:\",\n          err,\n        );\n      }\n\n      let detectedScore: ScoreInfo | null = null;\n      let deltaMm = null;\n      let deltaPx = null;\n      let match = false;\n\n      if (boardPoint) {\n        try {\n          detectedScore = scoreAtBoardPointTheta(\n            boardPoint,\n            typeof theta === \"number\" ? theta : 0,\n            sectorOffset ?? 0,\n          );\n\n          // Calculate distance from expected ring\n          if (\n            detectedScore.ring === anchor.ring &&\n            detectedScore.sector === anchor.sector\n          ) {\n            match = true;\n            deltaMm = 0;\n          } else {\n            // Calculate Euclidean distance in mm from detected point to expected ring\n            const expectedRadius =\n              BoardRadii[\n                anchor.ring === \"DOUBLE\"\n                  ? \"doubleOuter\"\n                  : anchor.ring === \"INNER_BULL\"\n                    ? \"bullInner\"\n                    : anchor.ring === \"BULL\"\n                      ? \"bullOuter\"\n                      : \"doubleOuter\"\n              ];\n            const actualRadius = Math.hypot(boardPoint.x, boardPoint.y);\n            deltaMm = Math.abs(actualRadius - expectedRadius);\n            deltaPx = Math.hypot(\n              imgPoint.x - (detected?.cx ?? 0),\n              imgPoint.y - (detected?.cy ?? 0),\n            );\n            match = deltaMm <= anchor.toleranceMm;\n          }\n        } catch (err) {\n          console.warn(\n            \"[Camera Connection] Failed to score detected point:\",\n            err,\n          );\n        }\n      }\n\n      results.push({\n        label: anchor.label,\n        expected: { ring: anchor.ring, sector: anchor.sector },\n        detected: detectedScore,\n        deltaMm,\n        deltaPx,\n        match,\n        note: match ? \"✅ OK\" : `❌ Off by ${deltaMm?.toFixed(1)}mm`,\n      });\n    }\n\n    return results;\n  }\n\n  // Helper: refine detection stability by running the same ring detection a few times and ensure values are close\n  function isSimilarDetection(a: any, b: any, tol = 0.03) {\n    if (!a || !b) return false;\n    const dx = Math.abs((a.cx - b.cx) / (a.cx || 1));\n    const dy = Math.abs((a.cy - b.cy) / (a.cy || 1));\n    const dr = Math.abs((a.doubleOuter - b.doubleOuter) / (a.doubleOuter || 1));\n    return dx <= tol && dy <= tol && dr <= tol;\n  }\n\n  const workerRef = useRef<Worker | null>(null);\n  useEffect(() => {\n    if (isTestEnv) {\n      workerRef.current = null;\n      return;\n    }\n    let w: Worker | null = null;\n    try {\n      w = new Worker(\n        new URL(\"../workers/boardDetection.worker.ts\", import.meta.url),\n        { type: \"module\" } as any,\n      );\n      workerRef.current = w;\n      console.log(\"[Camera Connection] Board detection worker created\");\n    } catch (err) {\n      console.warn(\n        \"[Camera Connection] Failed to create board detection worker, will fallback to main thread: \",\n        err,\n      );\n      workerRef.current = null;\n    }\n    return () => {\n      try {\n        w?.terminate();\n      } catch {}\n    };\n  }, []);\n\n  // Advanced auto-alignment: detect board features without markers or manual clicking\n  async function autoCalibrate() {\n    if (!canvasRef.current) {\n      alert(\"Capture a frame or upload a photo first.\");\n      return;\n    }\n    const testAutoDetectResult = (globalThis as any)\n      .__TEST_AUTO_DETECT_RESULT as TestAutoDetectResult | undefined;\n    if (testAutoDetectResult) {\n      applyTestAutoDetectResult(testAutoDetectResult);\n      return;\n    }\n    // If worker is available, use it; otherwise fall back to synchronous detection\n    if (workerRef.current) {\n      setAutoCalibrating(true);\n      let bitmap: ImageBitmap | null = null;\n      try {\n        bitmap = await createImageBitmap(canvasRef.current);\n      } catch (err) {\n        console.warn(\n          \"[Camera Connection] createImageBitmap failed; falling back to main thread detection\",\n          err,\n        );\n        bitmap = null;\n      }\n      if (!bitmap) {\n        setAutoCalibrating(false);\n        // fallback: run sync detection\n        return autoCalibrateSync();\n      }\n      try {\n        const worker = workerRef.current;\n        if (!worker) return autoCalibrateSync();\n        return new Promise<void>((resolve) => {\n          // eslint-disable-next-line prefer-const\n          let timeoutId: ReturnType<typeof setTimeout> | undefined;\n          const onMessage = async (ev: MessageEvent) => {\n            try {\n              if (ev.data && ev.data.error) {\n                const errMsg = ev.data.error || \"Auto-alignment failed\";\n                alert(`Auto-alignment failed: ${errMsg}`);\n                setDetectionMessage(errMsg);\n                setAutoCalibrating(false);\n                if (timeoutId) clearTimeout(timeoutId);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve();\n                return;\n              }\n              if (ev.data && ev.data.type === \"result\") {\n                const boardDetection = ev.data\n                  .detection as BoardDetectionResult;\n                // Respect forceConfidence\n                if (forceConfidence) boardDetection.confidence = 100;\n                // If we have missing homography, try to compute a homography from detected points\n                if (\n                  !boardDetection.homography ||\n                  !Array.isArray(boardDetection.calibrationPoints) ||\n                  boardDetection.calibrationPoints.length < 4\n                ) {\n                  const points = boardDetection.calibrationPoints || [];\n                  if (points.length >= 4) {\n                    const canonicalSrc = [\n                      { x: 0, y: -BoardRadii.doubleOuter },\n                      { x: BoardRadii.doubleOuter, y: 0 },\n                      { x: 0, y: BoardRadii.doubleOuter },\n                      { x: -BoardRadii.doubleOuter, y: 0 },\n                    ];\n                    try {\n                      const H = computeHomographyDLT(\n                        canonicalSrc,\n                        points.slice(0, 4),\n                      );\n                      boardDetection.homography = H;\n                      boardDetection.errorPx = rmsError(\n                        H,\n                        canonicalSrc,\n                        points.slice(0, 4),\n                      );\n                    } catch (err) {\n                      console.warn(\n                        \"[Camera Connection] Worker homography compute failed\",\n                        err,\n                      );\n                    }\n                  }\n                }\n                if (\n                  !boardDetection.success ||\n                  !boardDetection.homography ||\n                  (!forceConfidence && boardDetection.confidence < 40)\n                ) {\n                  alert(\n                    `❌ Board Detection Failed\\n\\nConfidence: ${Math.round(boardDetection.confidence)}%\\n\\n${boardDetection.message}\\n\\nTry:\\n• Better lighting\\n• Closer camera angle\\n• Make sure entire board is visible\\n• Use manual alignment instead (click the 4 double-ring points: D20, D6, D3, D11)`,\n                  );\n                  setAutoCalibrating(false);\n                  if (timeoutId) clearTimeout(timeoutId);\n                  worker.removeEventListener(\"message\", onMessage);\n                  resolve();\n                  return;\n                }\n                // Apply the connection\n                setDetected({\n                  cx: boardDetection.cx,\n                  cy: boardDetection.cy,\n                  bullInner: boardDetection.bullInner,\n                  bullOuter: boardDetection.bullOuter,\n                  trebleInner: boardDetection.trebleInner,\n                  trebleOuter: boardDetection.trebleOuter,\n                  doubleInner: boardDetection.doubleInner,\n                  doubleOuter: boardDetection.doubleOuter,\n                });\n                setDstPoints(boardDetection.calibrationPoints);\n                console.log(\n                  \"[Camera Connection] Auto-detect: Drawing overlay at detected center (\",\n                  Math.round(boardDetection.cx),\n                  \",\",\n                  Math.round(boardDetection.cy),\n                  \") with connection points:\",\n                  boardDetection.calibrationPoints\n                    .map((p) => `(${Math.round(p.x)},${Math.round(p.y)})`)\n                    .join(\" \"),\n                );\n                drawOverlay(\n                  boardDetection.calibrationPoints,\n                  boardDetection.homography,\n                );\n                let shouldLock =\n                  (boardDetection.errorPx ?? Number.POSITIVE_INFINITY) <= 2.0;\n                // Validate detection stability by rerunning local detection a couple times\n                // WITH YIELDS to prevent UI freeze\n                try {\n                  let stableCount2 = 1;\n                  const runs2 = 3;\n                  for (let i = 1; i < runs2; i++) {\n                    // Yield before each stability check\n                    await new Promise((resolveYield) =>\n                      setTimeout(resolveYield, 0),\n                    );\n\n                    const small = document.createElement(\"canvas\");\n                    small.width = Math.max(\n                      1,\n                      Math.round(canvasRef.current!.width * 0.8),\n                    );\n                    small.height = Math.max(\n                      1,\n                      Math.round(canvasRef.current!.height * 0.8),\n                    );\n                    const sctx = small.getContext(\"2d\")!;\n                    sctx.drawImage(\n                      canvasRef.current!,\n                      0,\n                      0,\n                      small.width,\n                      small.height,\n                    );\n                    const scaleSmall = small.width / canvasRef.current!.width;\n                    const hintScaledSmall = bullHint\n                      ? {\n                          centerHint: {\n                            x: bullHint.x * scaleSmall,\n                            y: bullHint.y * scaleSmall,\n                          },\n                        }\n                      : undefined;\n                    const bd2 = detectBoard(\n                      small as any as HTMLCanvasElement,\n                      hintScaledSmall,\n                    );\n                    if (isSimilarDetection(boardDetection as any, bd2 as any))\n                      stableCount2++;\n                  }\n                  const stable2 = stableCount2 >= Math.ceil(runs2 * 0.66);\n                  shouldLock = shouldLock && stable2;\n                } catch (err) {\n                  // ignore stability failures\n                }\n                const overlaySize = overlayRef?.current\n                  ? {\n                      w: overlayRef.current.width,\n                      h: overlayRef.current.height,\n                    }\n                  : videoRef?.current\n                    ? {\n                        w: videoRef.current.clientWidth,\n                        h: videoRef.current.clientHeight,\n                      }\n                    : {\n                        w: canvasRef.current?.width ?? 0,\n                        h: canvasRef.current?.height ?? 0,\n                      };\n                setCalibration({\n                  H: boardDetection.homography as Homography,\n                  createdAt: Date.now(),\n                  errorPx: boardDetection.errorPx ?? null,\n                  imageSize: {\n                    w: canvasRef.current?.width ?? 0,\n                    h: canvasRef.current?.height ?? 0,\n                  },\n                  overlaySize,\n                  anchors: {\n                    src: canonicalRimTargets(\"outer\").slice(0, 4),\n                    dst: boardDetection.calibrationPoints,\n                  },\n                  locked: shouldLock ? true : locked,\n                });\n                setDetectionMessage(\n                  boardDetection.message ??\n                    `Auto-alignment success (confidence ${Math.round(boardDetection.confidence)}%)`,\n                );\n                setPhase(\"computed\");\n                setConfidence(\n                  forceConfidence ? 100 : Math.round(boardDetection.confidence),\n                );\n                setCalibration({ errorPx: boardDetection.errorPx ?? null });\n                setAutoCalibrating(false);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve();\n                return;\n              }\n            } catch (err) {\n              console.warn(\n                \"[Camera Connection] Worker message processing failed\",\n                err,\n              );\n              setAutoCalibrating(false);\n              worker.removeEventListener(\"message\", onMessage);\n              resolve();\n              return;\n            }\n          };\n          worker.addEventListener(\"message\", onMessage);\n          // TypeScript's postMessage overloads are picky about transfer lists;\n          // ensure we only transfer non-null bitmaps.\n          if (bitmap) {\n            worker.postMessage({ type: \"detect\", bitmap }, undefined, [\n              bitmap,\n            ] as unknown as Transferable[]);\n          } else {\n            worker.postMessage({ type: \"detect\", bitmap });\n          }\n          // safety timeout - fallback to sync after 8s\n          timeoutId = setTimeout(() => {\n            if (autoCalibrating) {\n              console.warn(\n                \"[Camera Connection] Worker timed out, attempting sync fallback\",\n              );\n              setAutoCalibrating(false);\n              if (timeoutId) clearTimeout(timeoutId);\n              worker.removeEventListener(\"message\", onMessage);\n              autoCalibrateSync().catch((err) =>\n                console.error(\n                  \"[Camera Connection] Fallback sync detection failed:\",\n                  err,\n                ),\n              );\n            }\n          }, 8000);\n        });\n      } catch (err) {\n        console.warn(\n          \"[Camera Connection] AutoCalibrate worker payload failed\",\n          err,\n        );\n        setAutoCalibrating(false);\n        return await autoCalibrateSync();\n      }\n    } else {\n      return await autoCalibrateSync();\n    }\n  }\n\n  // Asynchronous non-blocking fallback for autoCalibrate\n  async function autoCalibrateSync() {\n    try {\n      setAutoCalibrating(true);\n\n      // Yield to browser to show \"Auto-calibrating...\" state before heavy work\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      let boardDetection = detectBoard(\n        canvasRef.current!,\n        bullHint\n          ? { centerHint: bullHint, colorAssist: true }\n          : { colorAssist: true },\n      );\n      boardDetection = refineRingDetection(boardDetection);\n      if (forceConfidence) boardDetection.confidence = 100;\n\n      // Yield again to keep UI responsive between detections\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      if (\n        !boardDetection.homography ||\n        !Array.isArray(boardDetection.calibrationPoints) ||\n        boardDetection.calibrationPoints.length < 4\n      ) {\n        try {\n          const points = boardDetection.calibrationPoints || [];\n          if (points.length >= 4) {\n            const canonicalSrc = [\n              { x: 0, y: -BoardRadii.doubleOuter },\n              { x: BoardRadii.doubleOuter, y: 0 },\n              { x: 0, y: BoardRadii.doubleOuter },\n              { x: -BoardRadii.doubleOuter, y: 0 },\n            ];\n            const H = computeHomographyDLT(canonicalSrc, points.slice(0, 4));\n            boardDetection.homography = H;\n            boardDetection.errorPx = rmsError(\n              H,\n              canonicalSrc,\n              points.slice(0, 4),\n            );\n          }\n        } catch (err) {\n          console.warn(\n            \"[Camera Connection] sync forced homography compute failed\",\n            err,\n          );\n        }\n      }\n\n      // Try multi-scale detection attempts - with yields to prevent freezing\n      if (\n        !boardDetection.success ||\n        !boardDetection.homography ||\n        (!forceConfidence && boardDetection.confidence < 50)\n      ) {\n        const scales = [0.9, 0.8, 1.1, 1.2];\n        for (const scale of scales) {\n          try {\n            // Yield before each scale attempt\n            await new Promise((resolve) => setTimeout(resolve, 0));\n\n            const srcCanvas = canvasRef.current!;\n            const tmp = document.createElement(\"canvas\");\n            tmp.width = Math.max(1, Math.round(srcCanvas.width * scale));\n            tmp.height = Math.max(1, Math.round(srcCanvas.height * scale));\n            const tctx = tmp.getContext(\"2d\");\n            if (!tctx) continue;\n            tctx.drawImage(srcCanvas, 0, 0, tmp.width, tmp.height);\n            // Scale bull hint into the resized tmp space if available\n            const hintScaled = bullHint\n              ? {\n                  centerHint: { x: bullHint.x * scale, y: bullHint.y * scale },\n                  colorAssist: true,\n                }\n              : { colorAssist: true };\n            let bd = detectBoard(tmp as any as HTMLCanvasElement, hintScaled);\n            bd = refineRingDetection(bd);\n            if (bd.success && bd.homography) {\n              // Scale found points back to original coordinate space\n              const invScale = 1 / scale;\n              bd.cx *= invScale;\n              bd.cy *= invScale;\n              bd.bullInner *= invScale;\n              bd.bullOuter *= invScale;\n              bd.trebleInner *= invScale;\n              bd.trebleOuter *= invScale;\n              bd.doubleInner *= invScale;\n              bd.doubleOuter *= invScale;\n              bd.calibrationPoints = bd.calibrationPoints.map((p) => ({\n                x: p.x * invScale,\n                y: p.y * invScale,\n              }));\n              boardDetection = bd;\n              break;\n            }\n          } catch (err) {\n            // continue on error\n          }\n        }\n      }\n\n      // Re-run the post-success checks after potential multi-scale detection\n      if (\n        !boardDetection.success ||\n        !boardDetection.homography ||\n        (!forceConfidence && boardDetection.confidence < 50)\n      ) {\n        alert(\n          `❌ Board Detection Failed\\n\\nConfidence: ${Math.round(boardDetection.confidence)}%\\n\\n${boardDetection.message}\\n\\nTry:\\n• Better lighting\\n• Closer camera angle\\n• Make sure entire board is visible\\n• Use manual alignment instead (click the 4 double-ring points: D20, D6, D3, D11)`,\n        );\n        setDetectionMessage(boardDetection.message ?? null);\n        setAutoCalibrating(false);\n        return;\n      }\n\n      // Yield before applying detection to UI\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      // Apply detection (same as worker result processing)\n      setDetected({\n        cx: boardDetection.cx,\n        cy: boardDetection.cy,\n        bullInner: boardDetection.bullInner,\n        bullOuter: boardDetection.bullOuter,\n        trebleInner: boardDetection.trebleInner,\n        trebleOuter: boardDetection.trebleOuter,\n        doubleInner: boardDetection.doubleInner,\n        doubleOuter: boardDetection.doubleOuter,\n      });\n      setDstPoints(boardDetection.calibrationPoints);\n      drawOverlay(boardDetection.calibrationPoints, boardDetection.homography);\n\n      // Check stability of the detection across quick re-runs - with yields\n      const baseCheck =\n        (boardDetection.errorPx ?? Number.POSITIVE_INFINITY) <= 2.0;\n      let stabilityCount = 1;\n      const stabilityRuns = 3;\n      for (let i = 1; i < stabilityRuns; i++) {\n        try {\n          // Yield before stability check\n          await new Promise((resolve) => setTimeout(resolve, 0));\n\n          const tmp = document.createElement(\"canvas\");\n          tmp.width = Math.max(1, Math.round(canvasRef.current!.width * 0.9));\n          tmp.height = Math.max(1, Math.round(canvasRef.current!.height * 0.9));\n          const tctx = tmp.getContext(\"2d\")!;\n          tctx.drawImage(canvasRef.current!, 0, 0, tmp.width, tmp.height);\n          const hintScaled2 = bullHint\n            ? {\n                centerHint: { x: bullHint.x * 0.9, y: bullHint.y * 0.9 },\n                colorAssist: true,\n              }\n            : { colorAssist: true };\n          const bd2 = detectBoard(tmp as any as HTMLCanvasElement, hintScaled2);\n          if (isSimilarDetection(boardDetection as any, bd2 as any))\n            stabilityCount++;\n        } catch (err) {\n          // ignore\n        }\n      }\n      const stable = stabilityCount >= Math.ceil(stabilityRuns * 0.66);\n      const shouldLock = baseCheck && stable;\n      const overlaySize = overlayRef?.current\n        ? { w: overlayRef.current.width, h: overlayRef.current.height }\n        : videoRef?.current\n          ? {\n              w: videoRef.current.clientWidth,\n              h: videoRef.current.clientHeight,\n            }\n          : { w: canvasRef.current!.width, h: canvasRef.current!.height };\n      // Use actual video frame dimensions for imageSize, not canvas display dimensions\n      const actualImageSize = videoRef.current\n        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }\n        : { w: canvasRef.current!.width, h: canvasRef.current!.height };\n\n      // Auto-estimate sector offset from homography so 20 aligns to top\n      const autoOffset = estimateSectorOffsetFromHomography(\n        boardDetection.homography as Homography,\n        \"outer\",\n      );\n\n      setCalibration({\n        H: boardDetection.homography as Homography,\n        createdAt: Date.now(),\n        errorPx: boardDetection.errorPx ?? null,\n        imageSize: actualImageSize,\n        overlaySize,\n        anchors: {\n          // Match black outline guide: calibrate using the double OUTER rim\n          src: canonicalRimTargets(\"outer\").slice(0, 4),\n          dst: boardDetection.calibrationPoints,\n        },\n        locked: shouldLock ? true : locked,\n        theta: boardDetection.theta,\n        sectorOffset: autoOffset,\n      });\n      setPhase(\"computed\");\n      setConfidence(\n        forceConfidence ? 100 : Math.round(boardDetection.confidence),\n      );\n      setCalibration({ errorPx: boardDetection.errorPx ?? null });\n      setDetectionMessage(boardDetection.message ?? null);\n      setAutoCalibrating(false);\n    } catch (err) {\n      console.error(\"[Camera Connection] autoConnectSync failed:\", err);\n      const errorMsg = err instanceof Error ? err.message : String(err);\n      setDetectionMessage(`❌ Auto-alignment failed: ${errorMsg}`);\n      setAutoCalibrating(false);\n    }\n  }\n\n  function detectMarkers() {\n    if (!canvasRef.current)\n      return alert(\"Capture a frame or upload a photo first.\");\n    const result = detectMarkersFromCanvas(canvasRef.current);\n    setMarkerResult(result);\n    if (!result.success || !result.homography) {\n      const missingMsg = result.missing.length\n        ? ` Missing markers: ${result.missing.map((k) => `${k.toUpperCase()} (ID ${MARKER_TARGETS[k]})`).join(\", \")}`\n        : \"\";\n      const foundMsg =\n        result.markersFound.length > 0\n          ? `\\n\\nDetected ${result.markersFound.length} markers with IDs: ${result.markersFound.map((m) => m.id).join(\", \")}`\n          : \"\\n\\nNo markers detected. Make sure markers are on white paper, fully visible, and well-lit.\";\n      const fullMsg = `${result.message}${missingMsg}${foundMsg}\\n\\nYou can still use manual alignment: click the 4 double-ring points (D20, D6, D3, D11).`;\n      alert(fullMsg);\n      return;\n    }\n    setDetected(null);\n    setDstPoints(result.points);\n    drawOverlay(result.points, result.homography);\n    const src = canonicalRimTargets(\"outer\");\n    const imageSize = {\n      w: canvasRef.current.width,\n      h: canvasRef.current.height,\n    };\n    const overlaySize = overlayRef?.current\n      ? { w: overlayRef.current.width, h: overlayRef.current.height }\n      : videoRef?.current\n        ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }\n        : { w: canvasRef.current.width, h: canvasRef.current.height };\n    const shouldLock = (result.errorPx ?? Number.POSITIVE_INFINITY) <= 1.2;\n    setCalibration({\n      H: result.homography as Homography,\n      createdAt: Date.now(),\n      errorPx: result.errorPx ?? null,\n      imageSize,\n      overlaySize,\n      anchors: { src, dst: result.points },\n      locked: shouldLock ? true : locked,\n    });\n    setPhase(\"computed\");\n  }\n\n  useEffect(() => {\n    drawOverlay();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [hasSnapshot, H, correctionSx, correctionTx, correctionTy]);\n\n  // Live detection loop (runs only when streaming and liveDetect is on)\n  useEffect(() => {\n    if (!liveDetect || !streaming) return;\n    let raf = 0;\n    const tick = () => {\n      try {\n        captureFrame();\n      } catch {}\n      raf = requestAnimationFrame(tick);\n    };\n    raf = requestAnimationFrame(tick);\n    return () => cancelAnimationFrame(raf);\n  }, [liveDetect, streaming]);\n\n  // When connection is locked and we have a pairing code, publish connection to server\n  useEffect(() => {\n    (async () => {\n      try {\n        if (!locked || !pairCode) return;\n        // Build a compact connection payload including current canvas size if available\n        const imgSize = canvasRef.current\n          ? { w: canvasRef.current.width, h: canvasRef.current.height }\n          : null;\n        const bodyStr = JSON.stringify({\n          H,\n          anchors: null,\n          imageSize: imgSize,\n          errorPx: errorPx ?? null,\n        });\n        try {\n          await apiFetch(`/cam/calibration/${pairCode}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: bodyStr,\n          });\n          console.log(\n            \"[Camera Connection] Posted connection for code\",\n            pairCode,\n          );\n        } catch (err) {\n          console.warn(\"[Camera Connection] Upload connection failed\", err);\n        }\n        // If user is authenticated, persist connection to their account (Supabase-backed)\n        try {\n          const token = localStorage.getItem(\"authToken\");\n          if (token) {\n            await apiFetch(\"/api/user/calibration\", {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${token}`,\n              },\n              body: bodyStr,\n            });\n            console.log(\n              \"[Camera Connection] Synced connection to user account\",\n            );\n          }\n        } catch (err) {\n          console.warn(\"[Camera Connection] User connection sync failed\", err);\n        }\n      } catch (e) {\n        /* ignore */\n      }\n    })();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [locked, pairCode]);\n\n  const showMobileLanding = isMobileDevice && !mobileLandingOverride;\n\n  if (showMobileLanding) {\n    const linkForMobile =\n      mobileLandingLink ??\n      (typeof window !== \"undefined\"\n        ? `${window.location.origin.replace(/\\/$/, \"\")}/mobile-cam.html`\n        : \"/mobile-cam.html\");\n    return (\n      <div className=\"mx-auto flex min-h-[calc(100vh-140px)] w-full max-w-xl flex-col justify-center gap-6 p-6\">\n        <div className=\"space-y-5 rounded-3xl border border-indigo-400/30 bg-slate-900/70 p-6 text-slate-100 shadow-xl\">\n          <div className=\"space-y-2\">\n            <p className=\"text-xs font-semibold uppercase tracking-wide text-indigo-300\">\n              Choose Mode\n            </p>\n            <h2 className=\"text-2xl font-semibold leading-tight text-white\">\n              How do you want to use this device?\n            </h2>\n            <p className=\"text-sm text-slate-200/80\">\n              You can stream this camera to another device (Remote Camera) or\\n\n              play and calibrate directly on this screen.\n            </p>\n          </div>\n          <div className=\"space-y-2\">\n            <a\n              href={linkForMobile}\n              className=\"btn w-full justify-center px-4 py-2 text-base\"\n            >\n              Open mobile camera\n            </a>\n            <button\n              type=\"button\"\n              className=\"btn btn--ghost w-full justify-center px-4 py-2 text-sm\"\n              onClick={() => copyValue(linkForMobile, \"link\")}\n            >\n              {copyFeedback === \"link\" ? \"Link copied!\" : \"Copy link\"}\n            </button>\n          </div>\n          <p className=\"text-xs text-slate-300/70\">\n            On a desktop, open Camera Connection and generate a pairing code.\n            Then tap <span className=\"font-semibold\">Pair with Desktop</span>{\" \"}\n            from the mobile camera page to connect this device.\n          </p>\n        </div>\n        <button\n          type=\"button\"\n          className=\"self-center text-xs font-medium text-indigo-200 underline decoration-dotted decoration-indigo-300/70 transition hover:text-indigo-100\"\n          onClick={() => setMobileLandingOverride(true)}\n        >\n          Continue to desktop connection\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {isMobileDevice && mobileLandingOverride && (\n        <div className=\"rounded-2xl border border-indigo-400/30 bg-indigo-500/10 p-4 text-sm text-indigo-100\">\n          <div className=\"flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between\">\n            <p className=\"leading-relaxed\">\n              Using a phone? Switch back to the streamlined mobile camera\n              interface for an easier pairing flow.\n            </p>\n            <button\n              type=\"button\"\n              className=\"btn btn--ghost px-3 py-1 text-xs\"\n              onClick={() => setMobileLandingOverride(false)}\n            >\n              Open mobile camera mode\n            </button>\n          </div>\n        </div>\n      )}\n      <div className=\"card space-y-6 p-6\">\n        <header className=\"flex flex-wrap items-start justify-between gap-4\">\n          <div className=\"space-y-2\">\n            <p className=\"text-xs font-semibold uppercase tracking-wide text-indigo-300\">\n              Camera alignment\n            </p>\n            <h2 className=\"text-2xl font-semibold leading-tight text-white\">\n              Camera connection\n            </h2>\n            <p className=\"max-w-2xl text-sm opacity-80\">\n              Select and test your camera. Manual scoring mode does not require\n              calibration.\n            </p>\n          </div>\n          <div className=\"flex flex-col items-end gap-2 text-xs font-medium\">\n            <span className=\"inline-flex items-center gap-2 rounded-full border border-indigo-400/50 bg-indigo-500/10 px-3 py-1\">\n              <span className=\"opacity-60\">Mode</span>\n              <span>\n                {mode === \"local\"\n                  ? \"Desktop camera\"\n                  : mode === \"phone\"\n                    ? \"Phone camera\"\n                    : \"Wifi device\"}\n              </span>\n            </span>\n            <span\n              className={`inline-flex items-center gap-2 rounded-full border px-3 py-1 ${streaming ? \"border-emerald-400/60 bg-emerald-500/10 text-emerald-100\" : \"border-white/20 bg-white/5 text-slate-200\"}`}\n            >\n              <span\n                className={`h-2 w-2 rounded-full ${streaming ? \"bg-emerald-400\" : \"bg-slate-400\"}`}\n              />\n              {streaming ? \"Live stream active\" : \"Stream idle\"}\n            </span>\n            {locked ? (\n              <div className=\"space-y-3 rounded-2xl border border-emerald-400/40 bg-emerald-500/10 p-4 text-sm\">\n                <div className=\"flex items-center justify-between gap-2\">\n                  <div className=\"flex items-center gap-3\">\n                    <div className=\"flex h-10 w-10 items-center justify-center rounded-full bg-emerald-500/20\">\n                      <span className=\"text-lg\">✓</span>\n                    </div>\n                    <div>\n                      <h4 className=\"font-semibold text-emerald-100\">\n                        Connection locked\n                      </h4>\n                      <p className=\"text-xs opacity-80\">\n                        Your camera connection is saved and active across all\n                        game modes. It will be used in Online, Offline, and\n                        Tournaments.\n                      </p>\n                    </div>\n                  </div>\n                  <button\n                    className=\"btn btn--ghost px-2 py-1 text-xs whitespace-nowrap\"\n                    onClick={() => setCalibration({ locked: false })}\n                    title=\"Unlock to realign\"\n                  >\n                    Unlock\n                  </button>\n                </div>\n                {errorPx != null && (\n                  <div className=\"text-xs opacity-75\">\n                    Precision: {errorPx.toFixed(2)} px RMS error\n                  </div>\n                )}\n              </div>\n            ) : null}\n          </div>\n        </header>\n\n        <div className=\"grid gap-6 xl:grid-cols-[minmax(0,2fr)_minmax(320px,1fr)]\">\n          <section className=\"space-y-4\">\n            <div className=\"space-y-4 rounded-2xl border border-white/10 bg-black/40 p-4\">\n              <div className=\"flex flex-wrap items-center justify-between gap-4 text-xs\">\n                <div className=\"flex flex-wrap items-center gap-3\">\n                  <span className=\"uppercase tracking-wide opacity-60\">\n                    Video source\n                  </span>\n                  <div className=\"flex items-center gap-1\">\n                    <button\n                      className={`btn px-3 py-1 ${mode === \"local\" ? \"bg-emerald-600 hover:bg-emerald-700\" : \"bg-slate-700 hover:bg-slate-600\"}`}\n                      data-testid=\"mode-local\"\n                      onClick={() => {\n                        setMode(\"local\");\n                        if (\n                          typeof DROPDOWN_DEBUG !== \"undefined\" &&\n                          DROPDOWN_DEBUG\n                        )\n                          console.debug(\n                            \"[Camera Connection] setMode(local)\",\n                            Date.now(),\n                          );\n                        stopCamera(false);\n                      }}\n                      title=\"Use local camera\"\n                    >\n                      Local\n                    </button>\n                    <button\n                      className={`btn px-3 py-1 ${mode === \"phone\" ? \"bg-emerald-600 hover:bg-emerald-700\" : \"bg-slate-700 hover:bg-slate-600\"}`}\n                      data-testid=\"mode-phone\"\n                      onClick={() => {\n                        setMode(\"phone\");\n                        if (\n                          typeof DROPDOWN_DEBUG !== \"undefined\" &&\n                          DROPDOWN_DEBUG\n                        )\n                          console.debug(\n                            \"[Camera Connection] setMode(phone)\",\n                            Date.now(),\n                          );\n                        stopCamera(false);\n                      }}\n                      title=\"Enable camera on this device\"\n                    >\n                      Phone\n                    </button>\n                    <button\n                      className={`btn px-3 py-1 ${mode === \"wifi\" ? \"bg-emerald-600 hover:bg-emerald-700\" : \"bg-slate-700 hover:bg-slate-600\"}`}\n                      data-testid=\"mode-wifi\"\n                      onClick={() => {\n                        setMode(\"wifi\");\n                        if (\n                          typeof DROPDOWN_DEBUG !== \"undefined\" &&\n                          DROPDOWN_DEBUG\n                        )\n                          console.debug(\n                            \"[Camera Connection] setMode(wifi)\",\n                            Date.now(),\n                          );\n                        stopCamera(false);\n                        try {\n                          startWifiConnection();\n                        } catch (e) {\n                          console.debug(\n                            \"[Camera Connection] startWifiConnection failed\",\n                            e,\n                          );\n                        }\n                      }}\n                      title=\"Discover wifi/USB autoscoring devices\"\n                    >\n                      Wifi\n                    </button>\n                  </div>\n                </div>\n                <div className=\"flex flex-wrap items-center gap-3\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"opacity-70\">Zoom</span>\n                    <input\n                      type=\"range\"\n                      min={50}\n                      max={200}\n                      step={5}\n                      value={Math.round((zoom || 1) * 100)}\n                      onChange={(e) =>\n                        setZoom(\n                          Math.max(\n                            0.5,\n                            Math.min(2, Number(e.target.value) / 100),\n                          ),\n                        )\n                      }\n                    />\n                    <span className=\"w-12 text-right\">\n                      {Math.round((zoom || 1) * 100)}%\n                    </span>\n                  </div>\n                  <button className=\"btn px-3 py-1\" onClick={() => setZoom(1)}>\n                    Actual\n                  </button>\n                </div>\n              </div>\n              {/* Tools pill (always visible) */}\n              <div className=\"ml-3 relative\">\n                <button\n                  className=\"inline-flex items-center gap-2 rounded-full border border-indigo-400/30 bg-indigo-400/10 px-3 py-1 text-sm\"\n                  onClick={() => setToolsPopoverOpen(!toolsPopoverOpen)}\n                  data-testid=\"cal-tools-popper-button\"\n                >\n                  <span className=\"font-semibold\">Cam Tools</span>\n                  {preserveCalibrationOverlay && (\n                    <span className=\"ml-2 text-xs opacity-70\">\n                      (overlay preserved)\n                    </span>\n                  )}\n                </button>\n                {toolsPopoverOpen && (\n                  <div\n                    className=\"absolute right-0 mt-2 w-64 rounded-lg border bg-gray-900/80 p-3 shadow-lg z-50\"\n                    data-testid=\"cal-tools-popover\"\n                    role=\"dialog\"\n                  >\n                    <div className=\"text-xs mb-2\">\n                      Camera connection quick tools\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-show-darts\"\n                        type=\"checkbox\"\n                        checked={showDartPreview}\n                        onChange={(e) => setShowDartPreview(e.target.checked)}\n                      />\n                      <label htmlFor=\"hdr-show-darts\" className=\"text-sm\">\n                        Show darts overlay\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <button\n                        className=\"btn btn--ghost btn-sm\"\n                        onClick={() => resetVisualAdjustments()}\n                      >\n                        Reset visual adjustments\n                      </button>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-autocommit\"\n                        type=\"checkbox\"\n                        checked={autoCommitTestMode}\n                        onChange={(e) =>\n                          setAutoCommitTestMode(e.target.checked)\n                        }\n                      />\n                      <label htmlFor=\"hdr-autocommit\" className=\"text-sm\">\n                        Enable autocommit test\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-autocommit-online\"\n                        type=\"checkbox\"\n                        checked={allowAutocommitInOnline}\n                        onChange={(e) =>\n                          setAllowAutocommitInOnline(e.target.checked)\n                        }\n                        disabled={!autoCommitTestMode}\n                      />\n                      <label\n                        htmlFor=\"hdr-autocommit-online\"\n                        className=\"text-sm\"\n                      >\n                        Allow autocommit in Online/Tournament matches\n                        (dangerous)\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-autocommit-immediate\"\n                        type=\"checkbox\"\n                        checked={autoCommitImmediate}\n                        onChange={(e) =>\n                          setAutoCommitImmediate(e.target.checked)\n                        }\n                      />\n                      <label\n                        htmlFor=\"hdr-autocommit-immediate\"\n                        className=\"text-sm\"\n                      >\n                        Autocommit immediate when detected\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-show-detected\"\n                        type=\"checkbox\"\n                        checked={showDetectedOverlay}\n                        onChange={(e) =>\n                          setShowDetectedOverlay(e.target.checked)\n                        }\n                      />\n                      <label htmlFor=\"hdr-show-detected\" className=\"text-sm\">\n                        Show detected rings overlay\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <input\n                        id=\"hdr-force-detected\"\n                        type=\"checkbox\"\n                        checked={forceDetectedOnly}\n                        onChange={(e) => setForceDetectedOnly(e.target.checked)}\n                      />\n                      <label htmlFor=\"hdr-force-detected\" className=\"text-sm\">\n                        Force detected-only overlay (bypass homography)\n                      </label>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <label\n                        htmlFor=\"hdr-double-adjust\"\n                        className=\"text-sm mr-2\"\n                      >\n                        Double adj\n                      </label>\n                      <input\n                        id=\"hdr-double-adjust\"\n                        type=\"range\"\n                        min={0.95}\n                        max={1.1}\n                        step={0.005}\n                        value={doubleOuterAdjust}\n                        onChange={(e) =>\n                          setDoubleOuterAdjust(parseFloat(e.target.value))\n                        }\n                      />\n                      <span className=\"text-xs ml-2\">\n                        {(doubleOuterAdjust * 100).toFixed(1)}%\n                      </span>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <label\n                        htmlFor=\"hdr-treble-adjust\"\n                        className=\"text-sm mr-2\"\n                      >\n                        Treble adj\n                      </label>\n                      <input\n                        id=\"hdr-treble-adjust\"\n                        type=\"range\"\n                        min={0.95}\n                        max={1.1}\n                        step={0.005}\n                        value={trebleOuterAdjust}\n                        onChange={(e) =>\n                          setTrebleOuterAdjust(parseFloat(e.target.value))\n                        }\n                      />\n                      <span className=\"text-xs ml-2\">\n                        {(trebleOuterAdjust * 100).toFixed(1)}%\n                      </span>\n                    </div>\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <select\n                        id=\"hdr-align-select\"\n                        className=\"input\"\n                        value={aligningRing || \"\"}\n                        onChange={(e) =>\n                          setAligningRing(\n                            e.target.value ? (e.target.value as any) : null,\n                          )\n                        }\n                      >\n                        <option value=\"\">-- Align ring --</option>\n                        <option value=\"double\">Double Outer</option>\n                        <option value=\"treble\">Treble Outer</option>\n                        <option value=\"bull\">Bull Outer</option>\n                      </select>\n                      <div className=\"text-xs opacity-70 ml-2\">\n                        Click on the physical ring to align\n                      </div>\n                    </div>\n                    <div className=\"flex items-center justify-between mt-2\">\n                      <div className=\"text-xs opacity-70\">\n                        {lastDetectedLabel || \"No recent detection\"}\n                      </div>\n                      <div>\n                        <button\n                          className=\"btn btn--small\"\n                          onClick={() => {\n                            console.debug(\n                              \"[Camera Connection] popover Commit click (onClick)\",\n                            ); // eslint-disable-line no-console\n                            doCommit();\n                          }}\n                          onPointerDown={() => {\n                            console.debug(\n                              \"[Camera Connection] popover Commit click (onPointerDown)\",\n                            ); // eslint-disable-line no-console\n                            doCommit();\n                          }}\n                        >\n                          Commit\n                        </button>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              </div>\n\n              <div\n                className=\"relative w-full overflow-hidden rounded-2xl border border-indigo-400/30 bg-black\"\n                style={{\n                  aspectRatio: frameSize\n                    ? `${frameSize.w} / ${frameSize.h}`\n                    : \"16 / 9\",\n                }}\n              >\n                <div className=\"absolute top-2 right-2 z-40 flex items-center gap-2 rounded-full bg-black/40 px-2 py-1 text-[11px] text-white backdrop-blur\">\n                  <span\n                    className={`inline-block h-2 w-2 rounded-full ${streaming ? \"bg-emerald-400\" : \"bg-rose-500\"}`}\n                    aria-hidden=\"true\"\n                  />\n                  <span>{streaming ? \"Connected\" : \"Disconnected\"}</span>\n                </div>\n                <div\n                  className=\"absolute inset-0\"\n                  style={{\n                    transform: `scale(${zoom || 1})`,\n                    transformOrigin: \"center center\",\n                  }}\n                >\n                  <video\n                    ref={videoRef}\n                    onLoadedMetadata={(ev) => {\n                      try {\n                        const v = ev.currentTarget as HTMLVideoElement;\n                        if (v.videoWidth && v.videoHeight)\n                          setFrameSize({ w: v.videoWidth, h: v.videoHeight });\n                      } catch {}\n                    }}\n                    className={`absolute inset-0 h-full w-full object-cover transition-opacity duration-300 ${hasSnapshot ? \"opacity-0 -z-10\" : \"opacity-100 z-10\"}`}\n                    autoPlay\n                    playsInline\n                    muted\n                    controls={false}\n                  />\n                  {videoPlayBlocked && (\n                    <div className=\"absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur\">\n                      <button\n                        className=\"rounded-lg bg-white px-4 py-2 font-semibold text-slate-900 shadow-lg\"\n                        onClick={async () => {\n                          try {\n                            await videoRef.current?.play();\n                            setVideoPlayBlocked(false);\n                            setStreaming(true);\n                            setPhase(\"capture\");\n                          } catch (e) {\n                            console.warn(\"Tap-to-play retry failed\", e);\n                            alert(\n                              \"Tap to enable video failed. Please check browser settings or reload the page.\",\n                            );\n                          }\n                        }}\n                      >\n                        Tap to allow video\n                      </button>\n                    </div>\n                  )}\n                  <canvas\n                    ref={canvasRef}\n                    className={`absolute inset-0 h-full w-full transition-opacity duration-300 ${hasSnapshot ? \"opacity-100 z-10\" : \"opacity-0 -z-10\"}`}\n                  />\n                </div>\n              </div>\n\n              <div className=\"mt-4 flex flex-wrap items-center gap-2\">\n                {streaming ? (\n                  <button className=\"btn\" onClick={() => stopCamera(true)}>\n                    Disconnect\n                  </button>\n                ) : (\n                  <button className=\"btn\" onClick={startCamera}>\n                    Connect\n                  </button>\n                )}\n                <span className=\"text-xs opacity-70\">\n                  {streaming ? \"Camera connected\" : \"Camera not connected\"}\n                </span>\n              </div>\n            </div>\n          </section>\n\n          <aside className=\"space-y-4\">\n            <DevicePicker\n              videoDevices={videoDevices}\n              streaming={streaming}\n              refreshVideoDevices={refreshVideoDevices}\n              testCamera={testCamera}\n              onSelectPhoneCamera={handleSelectPhoneCamera}\n              lastDetectedLabel={lastDetectedLabel}\n              autoCommitTestMode={autoCommitTestMode}\n              doCommit={doCommit}\n              lastDetectedValue={lastDetectedValue}\n              cameraConnected={streaming}\n            />\n\n            {mode === \"phone\" && (\n              <section className=\"space-y-3 rounded-2xl border border-indigo-400/30 bg-black/40 p-4 text-xs text-white\">\n                <div className=\"font-semibold\">Phone pairing</div>\n                {qrDataUrl && pairCode && (\n                  <div className=\"flex flex-col items-center gap-2 rounded-xl bg-white p-3\">\n                    <img\n                      src={qrDataUrl}\n                      alt=\"Scan to pair mobile camera\"\n                      className=\"w-48 h-48\"\n                      draggable={false}\n                    />\n                    <div className=\"text-[11px] text-slate-700 text-center font-medium\">\n                      Scan with your phone to pair\n                    </div>\n                  </div>\n                )}\n                <button\n                  type=\"button\"\n                  className=\"w-full text-left px-3 py-2 rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 transition flex items-center gap-2\"\n                  onClick={() => copyValue(mobileUrl, \"link\")}\n                  title=\"Copy mobile camera link\"\n                >\n                  <span className=\"flex-1 min-w-0 font-mono break-all text-[11px]\">\n                    {mobileUrl}\n                  </span>\n                  <span className=\"text-[10px] uppercase tracking-wide whitespace-nowrap text-emerald-200\">\n                    {copyFeedback === \"link\" ? \"Copied!\" : \"Copy link\"}\n                  </span>\n                </button>\n                <div className=\"flex items-center gap-2 text-[11px]\">\n                  <a\n                    href={mobileUrl}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                    className=\"underline decoration-dotted text-indigo-200 hover:text-indigo-100 transition\"\n                  >\n                    Open link in new tab\n                  </a>\n                </div>\n                <div className=\"opacity-80\">\n                  WS:{\" \"}\n                  {ws\n                    ? ws.readyState === 1\n                      ? \"open\"\n                      : ws.readyState === 0\n                        ? \"connecting\"\n                        : ws.readyState === 2\n                          ? \"closing\"\n                          : \"closed\"\n                    : \"not started\"}{\" \"}\n                  · {httpsInfo?.https ? \"HTTPS on\" : \"HTTP only\"}\n                </div>\n                {pairCode && (\n                  <button\n                    type=\"button\"\n                    className=\"w-full text-left px-3 py-2 rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 transition flex items-center justify-between gap-2\"\n                    onClick={() => copyValue(pairCode, \"code\")}\n                    title=\"Copy pairing code\"\n                  >\n                    <span className=\"font-mono tracking-[0.3em] text-sm\">\n                      {pairCode}\n                    </span>\n                    <span className=\"text-[10px] uppercase tracking-wide whitespace-nowrap text-emerald-200\">\n                      {copyFeedback === \"code\" ? \"Copied!\" : \"Copy code\"}\n                    </span>\n                  </button>\n                )}\n                <div className=\"flex items-center gap-2\">\n                  {ttl !== null && <span>Expires in {ttl}s</span>}\n                  <button\n                    className=\"btn px-2 py-1 text-xs\"\n                    onClick={regenerateCode}\n                  >\n                    Regenerate\n                  </button>\n                </div>\n                {showTips && (\n                  <div className=\"space-y-2 rounded-lg border border-slate-700/50 bg-slate-900/60 p-3 text-slate-200\">\n                    <div className=\"font-semibold\">Troubleshooting</div>\n                    <ul className=\"list-disc space-y-1 pl-4\">\n                      <li>\n                        Phone and desktop must be on the same Wi‑Fi network.\n                      </li>\n                      <li>\n                        Allow the server through your firewall (ports 8787 and{\" \"}\n                        {httpsInfo?.https ? httpsInfo.port : 8788}).\n                      </li>\n                      <li>\n                        On iPhone, use HTTPS links (QR will prefer HTTPS when\n                        enabled).\n                      </li>\n                    </ul>\n                    <div className=\"text-right\">\n                      <button\n                        className=\"btn btn--ghost px-2 py-1 text-xs\"\n                        onClick={() => setShowTips(false)}\n                      >\n                        Hide tips\n                      </button>\n                    </div>\n                  </div>\n                )}\n              </section>\n            )}\n\n            {/* Sidebar Step cards intentionally removed — these controls remain available in the main stage cards above to avoid showing duplicate controls in the right-hand sidebar. */}\n          </aside>\n        </div>\n\n        {mode === \"wifi\" && !streaming && (\n          <section className=\"space-y-3 rounded-2xl border border-indigo-400/30 bg-black/40 p-4 text-xs text-white\">\n            <div className=\"font-semibold\">Wifi scoring devices</div>\n            {discoveringWifi ? (\n              <div className=\"flex items-center gap-2\">\n                <div className=\"h-4 w-4 animate-spin rounded-full border-b-2 border-white\" />\n                <span>Scanning network for devices…</span>\n              </div>\n            ) : wifiDevices.length > 0 ? (\n              <div className=\"space-y-2\">\n                {wifiDevices.map((device) => (\n                  <div\n                    key={device.id}\n                    className=\"flex items-center justify-between rounded border border-slate-700/50 bg-slate-900/60 p-2\"\n                  >\n                    <div>\n                      <div className=\"font-medium\">{device.name}</div>\n                      <div className=\"opacity-70\">\n                        {device.ip}:{device.port} · {device.type.toUpperCase()}\n                      </div>\n                      <div className=\"opacity-70 text-xs\">\n                        Capabilities: {device.capabilities.join(\", \")}\n                      </div>\n                    </div>\n                    <button\n                      className={`btn px-2 py-1 text-xs ${device.status === \"connecting\" ? \"bg-yellow-600\" : device.status === \"online\" ? \"bg-green-600\" : \"bg-blue-600\"}`}\n                      onClick={() => connectToWifiDevice(device)}\n                      disabled={device.status === \"connecting\"}\n                    >\n                      {device.status === \"connecting\"\n                        ? \"Connecting…\"\n                        : \"Connect\"}\n                    </button>\n                  </div>\n                ))}\n                <div className=\"text-center\">\n                  <button\n                    className=\"btn px-2 py-1 text-xs\"\n                    onClick={startWifiConnection}\n                  >\n                    Rescan network\n                  </button>\n                </div>\n              </div>\n            ) : (\n              <div className=\"space-y-2 text-center\">\n                <div>No wifi scoring devices found.</div>\n                <div className=\"opacity-70\">\n                  Ensure your wifi cameras are powered on and on the same\n                  network.\n                </div>\n                <button\n                  className=\"btn px-2 py-1 text-xs\"\n                  onClick={startWifiConnection}\n                >\n                  Scan again\n                </button>\n              </div>\n            )}\n          </section>\n        )}\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport Calibrator from \"./Calibrator.js\";\n\nexport default function CameraSetup() {\n  return (\n    <div className=\"card ndn-game-shell relative overflow-hidden\">\n      <h2 className=\"text-3xl font-bold text-brand-700 mb-4\">Camera Setup</h2>\n      <div className=\"ndn-shell-body\">\n        <Calibrator />\n      </div>\n    </div>\n  );\n}\n"],"names":["markerIdToMatrix","id","grid","bits","i","r","rowIdx","bitA","bitB","isFinitePoint","p","isFiniteHomography","H","findDartboardRings","canvas","centerHint","ctx","w","h","mapW","scale","mapH","workCtx","data","accumulator","magThreshold","y","x","iL","iR","iU","iD","lumL","lumR","lumU","lumD","dx","dy","mag","ux","uy","minR","maxR","v1x","v1y","v2x","v2y","smoothedAcc","blurR","sum","maxVotes","peakX","peakY","border","votes","roughCx","roughCy","scanW","scanScale","scanH","scanCtx","scanData","scanDx","scanDy","fullData","lum","ix","idx","angleCount","radiiByRing","a","angle","cos","sin","gradients","xInner","yInner","xOuter","yOuter","lumInner","lumOuter","grad","peaks","prev","curr","next","ringKey","k","entry","b","tierIndex","ringRadii","key","radii","median","filteredRings","last","secondLast","ratio","doubleOuterRadius","detectionConfidence","computeBoardOrientation","cx","cy","radius","sampleCount","sampleRadius","gradSamples","rInner","rOuter","imageData","iy","maxGrad","cur","g","smoothed","v","s","d","peakAngles","sectorCenters","a1","diff","sectorCount","canonicalAngles","_","bestRot","bestErr","shift","err","detectedAngle","canonicalAngle","refineHomographyByRings","gx","gy","cImg","applyHomography","ringScore","Htest","rings","BoardRadii","score","pts","sampleRing","nx","ny","nlen","bestH","bestScore","toRad","deg","rotSteps","txSteps","scaleSteps","rot","Hr","rotateHomography","tx","ty","Ht","translateHomography","Hs","scaleHomography","sc","detectBoard","opts","centerX","centerY","srcCanvas","oc","c","octx","rgb2hsv","rn","gn","bn","max","min","hh","isRed","isGreen","detection","detected","theta","canonicalSrc","canonicalRimTargets","calibrationPoints","px","py","homography","errorPx","confidence","inlierRatio","useRansac","useUserSettings","ransac","ransacHomography","computeHomographyDLT","rmsError","centerImg","global","getGlobalCalibrationConfidence","pointsValid","homographyValid","success","detRingCount","result","discoverNetworkDevices","devices","localIPs","getLocalIPs","localIP","scanResults","scanNetwork","device","probeDevice","error","ips","pc","offer","resolve","timeout","event","ipMatch","ip","isPrivateIP","parts","ports","results","baseIP","promises","port","checkPort","index","portIndex","ipIndex","endpoints","endpoint","response","contentType","text","connectToNetworkDevice","streamUrl","video","reject","stream","drawFrame","canPromise","toSJISFunction","CODEWORDS_COUNT","utils","version","digit","f","kanji","exports","fromString","string","level","value","defaultValue","BitBuffer","bufIndex","num","length","bit","bitBuffer","BitMatrix","size","row","col","reserved","bitMatrix","getSymbolSize","require$$0","posCount","intervals","positions","coords","pos","posLength","j","FINDER_PATTERN_SIZE","finderPattern","PenaltyScores","mask","points","sameCountCol","sameCountRow","lastCol","lastRow","module","bitsCol","bitsRow","darkCount","modulesCount","getMaskAt","maskPattern","pattern","setupFormatFunc","numPatterns","bestPattern","lowerPenalty","penalty","ECLevel","EC_BLOCKS_TABLE","EC_CODEWORDS_TABLE","errorCorrectionCode","errorCorrectionLevel","EXP_TABLE","LOG_TABLE","galoisField","n","GF","p1","p2","coeff","divident","divisor","offset","degree","poly","Polynomial","ReedSolomonEncoder","paddedData","remainder","start","buff","reedSolomonEncoder","versionCheck","numeric","alphanumeric","byte","regex","TEST_KANJI","TEST_NUMERIC","TEST_ALPHANUMERIC","str","VersionCheck","Regex","require$$1","mode","dataStr","Utils","ECCode","require$$2","Mode","require$$3","require$$4","G18","G18_BCH","getBestVersionForDataLength","currentVersion","getReservedBitsCount","getTotalBitsFromDataArray","segments","totalBits","reservedBits","getBestVersionForMixedData","totalCodewords","ecTotalCodewords","dataTotalCodewordsBits","usableBits","seg","ecl","G15","G15_MASK","G15_BCH","formatInfo","NumericData","group","remainingNum","numericData","ALPHA_NUM_CHARS","AlphanumericData","alphanumericData","ByteData","l","byteData","KanjiData","kanjiData","dijkstra","graph","predecessors","costs","open","closest","u","cost_of_s_to_u","adjacent_nodes","cost_of_e","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","first_visit","msg","nodes","T","cost","item","require$$5","require$$6","require$$7","getStringByteLength","getSegments","getSegmentsFromString","numSegs","alphaNumSegs","byteSegs","kanjiSegs","s1","s2","obj","getSegmentBitsLength","mergeSegments","segs","acc","prevSeg","buildNodes","buildGraph","table","prevNodeIds","nodeGroup","currentNodeIds","node","prevNodeId","buildSingleSegment","modesHint","bestMode","array","path","optimizedSegs","AlignmentPattern","FinderPattern","MaskPattern","require$$8","Version","require$$9","FormatInfo","require$$10","require$$11","Segments","require$$12","setupFinderPattern","matrix","setupTimingPattern","setupAlignmentPattern","setupVersionInfo","mod","setupFormatInfo","setupData","inc","bitIndex","byteIndex","dark","createData","buffer","remainingByte","createCodewords","dataTotalCodewords","ecTotalBlocks","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","dcData","ecData","maxDataSize","dataSize","createSymbol","estimatedVersion","rawSegments","bestVersion","dataBits","moduleCount","modules","qrcode","options","hex2rgba","hex","hexCode","hexValue","margin","width","qrSize","imgData","qr","symbolSize","scaledMargin","palette","posDst","pxColor","iSrc","jSrc","clearCanvas","getCanvasElement","qrData","canvasEl","image","type","rendererOpts","getColorAttrib","color","attrib","alpha","svgCmd","cmd","qrToPath","moveBy","newRow","lineLength","svgTag","cb","qrcodesize","bg","viewBox","QRCode","CanvasRenderer","SvgRenderer","renderCanvas","renderFunc","args","argsNum","isLastArgCb","e","browser","loadImage","src","img","composeQrWithLogo","qrDataUrl","qrImg","logoImg","logoSize","shape","pad","bx","by","bw","bh","makeQrDataUrlWithLogo","logo","base","DevicePicker","videoDevices","streaming","refreshVideoDevices","testCamera","onSelectPhoneCamera","lastDetectedLabel","autoCommitTestMode","doCommit","lastDetectedValue","cameraConnected","preferredCameraId","preferredCameraLabel","setPreferredCamera","cameraEnabled","setCameraEnabled","preferredCameraLocked","setPreferredCameraLocked","setErr","useState","dropdownOpen","setDropdownOpen","dropdownRef","useRef","handleRefreshDevices","useCallback","useEffect","handleClickOutside","selectedDevice","selectedLabel","preferredCameraUnavailable","handleSelectCamera","deviceId","label","handlePhoneCamera","handleLockToggle","jsxs","jsx","CALIBRATION_POINT_LABELS","REQUIRED_POINT_COUNT","VERIFICATION_ANCHORS","matMul3","Calibrator","videoRef","canvasRef","overlayRef","cameraPerm","setCameraPerm","setVideoDevices","selectedDeviceId","setSelectedDeviceId","setStreaming","videoPlayBlocked","setVideoPlayBlocked","setMode","dstPoints","setDstPoints","hasSnapshot","setHasSnapshot","phase","setPhase","handleSelectPhoneCamera","frameSize","setFrameSize","zoom","setZoom","mobileLandingOverride","setMobileLandingOverride","isMobileDevice","setIsMobileDevice","setCalibration","reset","locked","overlaySize","imageSize","anchors","sectorOffset","useCalibration","ERROR_PX_MAX","cameraSession","useCameraSession","calibrationGuide","setCalibrationGuide","preserveCalibrationOverlay","allowAutocommitInOnline","setAllowAutocommitInOnline","manualOnly","setDetected","liveDetect","setLiveDetect","setConfidence","autoCalibrating","setAutoCalibrating","detectionMessage","setDetectionMessage","forceConfidence","setForceConfidence","markerResult","setMarkerResult","showDartPreview","setShowDartPreview","setAutoCommitTestMode","autoCommitImmediate","setAutoCommitImmediate","setLastDetectedValue","setLastDetectedLabel","bullHint","setBullHint","toolsPopoverOpen","setToolsPopoverOpen","dartDetectorRef","delta","inFlightAutoCommitRef","lastAutoSigRef","lastAutoSigAtRef","AUTO_COMMIT_COOLDOWN_MS","verificationResults","setVerificationResults","flashStatus","setFlashStatus","correctionSx","setCorrectionSx","correctionTx","setCorrectionTx","correctionTy","setCorrectionTy","showDetectedOverlay","setShowDetectedOverlay","forceDetectedOnly","setForceDetectedOnly","doubleOuterAdjust","setDoubleOuterAdjust","trebleOuterAdjust","setTrebleOuterAdjust","aligningRing","setAligningRing","resetVisualAdjustments","rows","cols","cellW","cellH","setQrDataUrl","pairCode","setPairCode","pairCodeRef","ws","setWs","pcRef","pendingIceCandidatesRef","expiresAt","setExpiresAt","now","setNow","paired","setPaired","updatePairCode","code","lanHost","setLanHost","httpsInfo","setHttpsInfo","showTips","setShowTips","wifiDevices","setWifiDevices","discoveringWifi","setDiscoveringWifi","copyFeedback","setCopyFeedback","copyTimeoutRef","apiFetch","mobileUrl","useMemo","envUrl","host","useHttps","mobileLandingLink","url","cancelled","coarseQuery","detect","uaMobile","coarse","narrow","mounted","vids","constraints","t","ttl","copyValue","textarea","handleReconnectRequest","stopCamera","startPhonePairing","ensureWS","normalizedEnv","sameOrigin","socket","lockSelectionForPairing","ev","codeForSession","imgSize","payload","peer","inbound","pending","candidate","Hpayload","startWifiConnection","connectToWifiDevice","startCamera","playErr","autoRevert","regenerateCode","captureFrame","o","autoDetectRings","drawOverlay","currentPoints","HH","onOverlayClick","Huse","CORRECTION_SX","CORRECTION_TX","CORRECTION_TY","Hcorrected","adjustedCenterX","adjustedCenterY","WIDEN_FACTOR","detectedRingMap","perRingAdjust","drawDetectedRings","drawn","bullFill","trebleFill","doubleFill","drawBand","fillStyle","strokeStyle","inner","outer","outerAdj","innerAdj","OUTLINE_STEPS","outlines","oline","rAdj","drawPolyline","evt","rect","clickedRadius","currentRadius","newAdjust","Hdraw","ctx2","labels","SectorOrder","rLabel","thetaVal","ang","lx","ly","tw","errPx","hasVerification","allPass","passByError","pass","fail","drawnCount","drawRingBand","Hmat","detectedInner","detectedOuter","trebleInnerToUse","CalibrationGuideRadii","trebleOuterToUse","doubleInnerToUse","doubleOuterToUse","detectedRadius","rCenter","isPass","drawCircle","radScale","rx","ry","sampleAndDraw","rMm","targetPoints","drawCross","ax","ay","applyTestAutoDetectResult","Hcal","val","useMatch","calState","curCalValid","sig","testAutoDetectResult","refined","actualImageSize","autoOffset","estimateSectorOffsetFromHomography","verifyCalibration","stableCount","tmp","hintScaledA","bd","isSimilarDetection","connectionPoints","anchor","imgPoint","boardPoint","imageToBoard","detectedScore","deltaMm","deltaPx","match","scoreAtBoardPointTheta","expectedRadius","actualRadius","tol","dr","workerRef","raf","tick","bodyStr","token","linkForMobile","CameraSetup"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}