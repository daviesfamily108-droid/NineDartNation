{"version":3,"file":"boardDetection.worker-B-mvMoXK.js","sources":["../src/utils/vision.ts","../src/utils/boardDetection.ts","../src/workers/boardDetection.worker.ts"],"sourcesContent":["// Vision and calibration utilities for dartboard mapping\n// Standard dartboard: 18 inches (457.2 mm) outer diameter\n// Board dimensions follow standard measurements (millimeters)\n// - Inner bull radius: 6.35 mm (12.7 mm diameter)\n// - Outer bull radius: 15.9 mm (31.8 mm diameter)\n// - Treble inner radius: 99 mm\n// - Treble outer radius: 107 mm\n// - Double inner radius: 162 mm\n// - Double outer radius: 170 mm (playing field outer edge = 340 mm diameter)\n\nexport type Point = { x: number; y: number };\nexport type Homography = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n]; // row-major 3x3\n\nexport const BoardRadii = {\n  bullInner: 6.35,\n  bullOuter: 15.9,\n  trebleInner: 99,\n  trebleOuter: 107,\n  doubleInner: 162,\n  doubleOuter: 170,\n};\n\nexport const SectorOrder = [\n  20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5,\n];\n\n// Basic 3x3 matrix operations\nfunction matMul3(a: Homography, b: Homography): Homography {\n  const r = new Array(9).fill(0);\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      for (let k = 0; k < 3; k++) {\n        r[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j];\n      }\n    }\n  }\n  return r as Homography;\n}\n\nexport function applyHomography(H: Homography, p: Point): Point {\n  const x = p.x,\n    y = p.y;\n  const w = H[6] * x + H[7] * y + H[8];\n  const nx = (H[0] * x + H[1] * y + H[2]) / w;\n  const ny = (H[3] * x + H[4] * y + H[5]) / w;\n  return { x: nx, y: ny };\n}\n\n// Scale a homography by sx, sy on the destination/image side: H' = S * H\n// Where S = diag([sx, sy, 1])\nexport function scaleHomography(\n  H: Homography,\n  sx: number,\n  sy: number,\n): Homography {\n  return [\n    sx * H[0],\n    sx * H[1],\n    sx * H[2],\n    sy * H[3],\n    sy * H[4],\n    sy * H[5],\n    H[6],\n    H[7],\n    H[8],\n  ] as Homography;\n}\n\nexport function invertHomography(H: Homography): Homography {\n  // Inverse of 3x3 matrix\n  const m = H;\n  const a = m[0],\n    b = m[1],\n    c = m[2],\n    d = m[3],\n    e = m[4],\n    f = m[5],\n    g = m[6],\n    h = m[7],\n    i = m[8];\n  const A = e * i - f * h;\n  const B = c * h - b * i;\n  const C = b * f - c * e;\n  const D = f * g - d * i;\n  const E = a * i - c * g;\n  const F = c * d - a * f;\n  const G = d * h - e * g;\n  const Hh = b * g - a * h;\n  const I = a * e - b * d;\n  const det = a * A + b * D + c * G;\n  if (Math.abs(det) < 1e-12) throw new Error(\"Singular homography\");\n  const inv = [\n    A / det,\n    B / det,\n    C / det,\n    D / det,\n    E / det,\n    F / det,\n    G / det,\n    Hh / det,\n    I / det,\n  ] as Homography;\n  return inv;\n}\n\n// Compute homography H that maps src (board space) -> dst (image space)\n// Using N correspondences via DLT (solved by Gaussian elimination) with least-squares fit\n// Supports overdetermined systems (N > 4) for improved accuracy\nexport function computeHomographyDLT(src: Point[], dst: Point[]): Homography {\n  if (src.length < 4 || dst.length < 4)\n    throw new Error(\"Need at least 4 correspondences\");\n  if (src.length !== dst.length)\n    throw new Error(\"Correspondences must have equal length\");\n  // Build A * h = b where h = [h11 h12 h13 h21 h22 h23 h31 h32]^T and h33 = 1\n  const A: number[][] = [];\n  const B: number[] = [];\n  for (let k = 0; k < src.length; k++) {\n    const { x: X, y: Y } = src[k];\n    const { x: x, y: y } = dst[k];\n    // x = (h11 X + h12 Y + h13) / (h31 X + h32 Y + 1)\n    // y = (h21 X + h22 Y + h23) / (h31 X + h32 Y + 1)\n    // => x*(h31 X + h32 Y + 1) = h11 X + h12 Y + h13\n    // => y*(h31 X + h32 Y + 1) = h21 X + h22 Y + h23\n    A.push([X, Y, 1, 0, 0, 0, -x * X, -x * Y]);\n    B.push(x);\n    A.push([0, 0, 0, X, Y, 1, -y * X, -y * Y]);\n    B.push(y);\n  }\n  const h = solveLeastSquares(A, B); // length 8\n  const H: Homography = [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1];\n  return H;\n}\n\n// Solve A x = b in least squares sense using Gaussian elimination with partial pivoting\nfunction solveLeastSquares(A: number[][], b: number[]): number[] {\n  // Normal equations: (A^T A) x = A^T b\n  const m = A.length,\n    n = A[0].length;\n  const AtA: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));\n  const Atb: number[] = new Array(n).fill(0);\n  for (let r = 0; r < m; r++) {\n    for (let i = 0; i < n; i++) {\n      Atb[i] += A[r][i] * b[r];\n      for (let j = 0; j < n; j++) {\n        AtA[i][j] += A[r][i] * A[r][j];\n      }\n    }\n  }\n  return gaussianSolve(AtA, Atb);\n}\n\nfunction gaussianSolve(M: number[][], v: number[]): number[] {\n  const n = v.length;\n  // Augment matrix\n  const A = M.map((row, i) => row.concat([v[i]]));\n  for (let i = 0; i < n; i++) {\n    // Pivot\n    let maxRow = i;\n    for (let r = i + 1; r < n; r++) {\n      if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;\n    }\n    if (Math.abs(A[maxRow][i]) < 1e-12) throw new Error(\"Singular matrix\");\n    if (maxRow !== i) {\n      const tmp = A[i];\n      A[i] = A[maxRow];\n      A[maxRow] = tmp;\n    }\n    // Eliminate\n    for (let r = i + 1; r < n; r++) {\n      const f = A[r][i] / A[i][i];\n      for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c];\n    }\n  }\n  // Back substitution\n  const x = new Array(n).fill(0);\n  for (let i = n - 1; i >= 0; i--) {\n    let s = A[i][n];\n    for (let c = i + 1; c < n; c++) s -= A[i][c] * x[c];\n    x[i] = s / A[i][i];\n  }\n  return x;\n}\n\n// Canonical calibration targets in board space (mm)\n// We now anchor the homography with four evenly spaced double-ring sectors:\n// D20 (top), D6 (right), D3 (bottom), and D11 (left).\nexport function canonicalRimTargets(): Point[] {\n  const doubleR = BoardRadii.doubleOuter;\n  const targetSectors = [20, 6, 3, 11] as const;\n  return targetSectors.map((sector) => {\n    const idx = SectorOrder.indexOf(sector);\n    const angle = (idx / SectorOrder.length) * Math.PI * 2 - Math.PI / 2;\n    const x = doubleR * Math.cos(angle);\n    const y = doubleR * Math.sin(angle);\n    return {\n      x: Math.abs(x) < 1e-9 ? 0 : x,\n      y: Math.abs(y) < 1e-9 ? 0 : y,\n    };\n  });\n}\n\n// Given a homography mapping board->image, produce polylines for overlay rings (in image px)\nexport function sampleRing(\n  H: Homography,\n  radius: number,\n  steps = 256,\n): Point[] {\n  const pts: Point[] = [];\n  for (let k = 0; k < steps; k++) {\n    const theta = (k / steps) * Math.PI * 2;\n    const p = applyHomography(H, {\n      x: radius * Math.cos(theta),\n      y: radius * Math.sin(theta),\n    });\n    pts.push(p);\n  }\n  return pts;\n}\n\nexport function rmsError(H: Homography, src: Point[], dst: Point[]): number {\n  let e2 = 0;\n  for (let i = 0; i < src.length; i++) {\n    const p = applyHomography(H, src[i]);\n    const dx = p.x - dst[i].x;\n    const dy = p.y - dst[i].y;\n    e2 += dx * dx + dy * dy;\n  }\n  return Math.sqrt(e2 / src.length);\n}\n\n// Map an image point to board coordinates using inverse homography (image->board)\nexport function imageToBoard(H_boardToImage: Homography, pImg: Point): Point {\n  const inv = invertHomography(H_boardToImage);\n  return applyHomography(inv as Homography, pImg);\n}\n\n// Compute score for a board coordinate (mm)\nexport function scoreAtBoardPoint(p: Point): {\n  base: number;\n  ring: \"MISS\" | \"SINGLE\" | \"DOUBLE\" | \"TRIPLE\" | \"BULL\" | \"INNER_BULL\";\n  sector: number | null;\n  mult: 0 | 1 | 2 | 3;\n} {\n  const r = Math.hypot(p.x, p.y);\n  const ang = Math.atan2(p.y, p.x); // 0 rad at +X, increasing CCW\n  // Rotate so that sector 20 is at the top (negative Y). Top corresponds to -90 degrees (or 270)\n  let deg = (ang * 180) / Math.PI;\n  deg = (deg + 360 + 90) % 360; // shift so 0 deg is at top\n  const sector = SectorOrder[Math.floor(((360 - deg) % 360) / 18)]; // clockwise ordering\n\n  if (r <= BoardRadii.bullInner)\n    return { base: 50, ring: \"INNER_BULL\", sector: 25, mult: 2 };\n  if (r <= BoardRadii.bullOuter)\n    return { base: 25, ring: \"BULL\", sector: 25, mult: 1 };\n  if (r >= BoardRadii.doubleOuter)\n    return { base: 0, ring: \"MISS\", sector: null, mult: 0 };\n  if (r >= BoardRadii.doubleInner)\n    return { base: sector * 2, ring: \"DOUBLE\", sector, mult: 2 };\n  if (r >= BoardRadii.trebleOuter)\n    return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\n  if (r >= BoardRadii.trebleInner)\n    return { base: sector * 3, ring: \"TRIPLE\", sector, mult: 3 };\n  return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\n}\n\nexport function drawPolyline(\n  ctx: CanvasRenderingContext2D,\n  pts: Point[],\n  color = \"#10b981\",\n  width = 2,\n) {\n  if (!pts.length) return;\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  ctx.beginPath();\n  ctx.moveTo(pts[0].x, pts[0].y);\n  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nexport function drawCross(\n  ctx: CanvasRenderingContext2D,\n  p: Point,\n  color = \"#f59e0b\",\n) {\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(p.x - 8, p.y);\n  ctx.lineTo(p.x + 8, p.y);\n  ctx.moveTo(p.x, p.y - 8);\n  ctx.lineTo(p.x, p.y + 8);\n  ctx.stroke();\n  ctx.restore();\n}\n\n// --- Point refinement using Sobel gradient ---\nfunction clamp(v: number, lo: number, hi: number) {\n  return Math.max(lo, Math.min(hi, v));\n}\n\nfunction sobelAtGray(img: ImageData, x: number, y: number): number {\n  const { width, data } = img;\n  // Sobel kernels\n  const gx = [\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1],\n  ];\n  const gy = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [1, 2, 1],\n  ];\n  let sx = 0,\n    sy = 0;\n  for (let j = -1; j <= 1; j++) {\n    for (let i = -1; i <= 1; i++) {\n      const xi = clamp(x + i, 0, width - 1);\n      const yi = clamp(y + j, 0, img.height - 1);\n      const idx = (yi * width + xi) * 4;\n      const r = data[idx],\n        g = data[idx + 1],\n        b = data[idx + 2];\n      const gray = 0.299 * r + 0.587 * g + 0.114 * b;\n      sx += gray * gx[j + 1][i + 1];\n      sy += gray * gy[j + 1][i + 1];\n    }\n  }\n  return Math.hypot(sx, sy);\n}\n\nexport function refinePointSobel(\n  canvas: HTMLCanvasElement,\n  p: Point,\n  radius = 6,\n): Point {\n  const ctx = canvas.getContext(\"2d\")!;\n  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const cx = clamp(Math.round(p.x), 1, canvas.width - 2);\n  const cy = clamp(Math.round(p.y), 1, canvas.height - 2);\n  let best = { x: cx, y: cy, mag: -1 };\n  for (let y = cy - radius; y <= cy + radius; y++) {\n    for (let x = cx - radius; x <= cx + radius; x++) {\n      if (x <= 0 || y <= 0 || x >= canvas.width - 1 || y >= canvas.height - 1)\n        continue;\n      const mag = sobelAtGray(img, x, y);\n      if (mag > best.mag) best = { x, y, mag };\n    }\n  }\n  return { x: best.x, y: best.y };\n}\n\nexport function refinePointsSobel(\n  canvas: HTMLCanvasElement,\n  pts: Point[],\n  radius = 6,\n): Point[] {\n  return pts.map((p) => refinePointSobel(canvas, p, radius));\n}\n","/**\n * Advanced Dartboard Auto-Calibration\n *\n * Detects dartboard features automatically without markers or manual clicking:\n * 1. Detects bull (inner & outer rings) using circle detection\n * 2. Detects treble and double rings using edge/circle detection\n * 3. Computes board center and orientation\n * 4. Generates calibration points from detected rings\n * 5. Computes homography without user interaction\n */\n\nimport {\n  BoardRadii,\n  computeHomographyDLT,\n  rmsError,\n  type Homography,\n  type Point,\n} from \"./vision\";\n\nconst isFinitePoint = (p: Point | undefined): p is Point =>\n  !!p && Number.isFinite(p.x) && Number.isFinite(p.y);\nconst isFiniteHomography = (\n  H: Homography | null | undefined,\n): H is Homography =>\n  Array.isArray(H) && H.length === 9 && H.every(Number.isFinite);\n\nexport interface BoardDetectionResult {\n  success: boolean;\n  cx: number; // Board center X in image\n  cy: number; // Board center Y in image\n  bullInner: number; // Detected inner bull radius (pixels)\n  bullOuter: number; // Detected outer bull radius (pixels)\n  trebleInner: number; // Detected treble inner radius (pixels)\n  trebleOuter: number; // Detected treble outer radius (pixels)\n  doubleInner: number; // Detected double inner radius (pixels)\n  doubleOuter: number; // Detected double outer radius (pixels)\n  confidence: number; // 0-100, quality of detection\n  homography: Homography | null;\n  errorPx: number | null;\n  calibrationPoints: Point[];\n  message?: string;\n}\n\n/**\n * Detect dartboard by finding concentric rings\n * Simpler, more direct approach: look for strong circular edges at the right distances\n */\nfunction findDartboardRings(\n  canvas: HTMLCanvasElement,\n): { cx: number; cy: number; r: number; confidence: number } | null {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return null;\n\n  const w = canvas.width;\n  const h = canvas.height;\n  const imageData = ctx.getImageData(0, 0, w, h);\n  const data = imageData.data;\n\n  // Step 1: Find all strong edges using Canny-like detection\n  const edges: Array<{ x: number; y: number; mag: number }> = [];\n\n  for (let y = 2; y < h - 2; y++) {\n    for (let x = 2; x < w - 2; x++) {\n      const idx = (y * w + x) * 4;\n\n      // Compute gradients\n      let gx = 0,\n        gy = 0;\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          const pidx = ((y + dy) * w + (x + dx)) * 4;\n          const gray =\n            data[pidx] * 0.299 +\n            data[pidx + 1] * 0.587 +\n            data[pidx + 2] * 0.114;\n          if (dx !== 0) gx += (dx > 0 ? 1 : -1) * gray;\n          if (dy !== 0) gy += (dy > 0 ? 1 : -1) * gray;\n        }\n      }\n\n      const mag = Math.hypot(gx, gy);\n      if (mag > 20) {\n        edges.push({ x, y, mag });\n      }\n    }\n  }\n\n  if (edges.length === 0) return null;\n\n  // Step 2: For each potential center, score how many rings we can explain\n  let bestCenter = null;\n  let bestScore = 0;\n\n  // Sample potential centers\n  for (let cy = h * 0.3; cy < h * 0.7; cy += 10) {\n    for (let cx = w * 0.3; cx < w * 0.7; cx += 10) {\n      // For this center, find rings at expected radii\n      let ringCount = 0;\n      let ringStrength = 0;\n\n      // Test for rings at known pixel radii (assuming double radius ~150px)\n      const testRadii = [15, 30, 150, 162, 180, 205];\n\n      for (const testR of testRadii) {\n        let strength = 0;\n        let pixelCount = 0;\n\n        // Count edge pixels near this radius\n        for (const edge of edges) {\n          const dist = Math.hypot(edge.x - cx, edge.y - cy);\n          if (Math.abs(dist - testR) < 3) {\n            strength += edge.mag;\n            pixelCount++;\n          }\n        }\n\n        if (pixelCount > 10 && strength > 500) {\n          ringCount++;\n          ringStrength += strength;\n        }\n      }\n\n      // Want at least 4 strong rings\n      if (ringCount >= 4 && ringStrength > bestScore) {\n        bestScore = ringStrength;\n        bestCenter = { cx, cy };\n      }\n    }\n  }\n\n  if (!bestCenter) return null;\n\n  // Step 3: Refine the center position and find double radius\n  const refinedCx = bestCenter.cx;\n  const refinedCy = bestCenter.cy;\n\n  // Find the strongest ring near where we expect the double outer (165-190 pixels for typical image)\n  let doubleR = 170;\n  let maxStrength = 0;\n\n  for (let testR = 120; testR <= 250; testR += 5) {\n    let strength = 0;\n    let pixelCount = 0;\n\n    for (const edge of edges) {\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\n      if (Math.abs(dist - testR) < 2) {\n        strength += edge.mag;\n        pixelCount++;\n      }\n    }\n\n    if (pixelCount > 20 && strength > maxStrength) {\n      maxStrength = strength;\n      doubleR = testR;\n    }\n  }\n\n  // Calculate confidence based on how many proper rings we found\n  let confidence = 0;\n  const scale = doubleR / BoardRadii.doubleOuter;\n\n  for (const knownR of [\n    BoardRadii.bullInner,\n    BoardRadii.bullOuter,\n    BoardRadii.trebleInner,\n    BoardRadii.trebleOuter,\n    BoardRadii.doubleInner,\n    BoardRadii.doubleOuter,\n  ]) {\n    const expectedPixelR = knownR * scale;\n    let found = false;\n\n    for (const edge of edges) {\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\n      if (Math.abs(dist - expectedPixelR) < 3) {\n        found = true;\n        confidence += 15;\n        break;\n      }\n    }\n  }\n\n  confidence = Math.min(100, confidence);\n\n  return {\n    cx: refinedCx,\n    cy: refinedCy,\n    r: doubleR,\n    confidence,\n  };\n}\n\n/**\n * Main board detection function\n * Uses direct ring detection approach\n */\nexport function detectBoard(canvas: HTMLCanvasElement): BoardDetectionResult {\n  try {\n    const w = canvas.width;\n    const h = canvas.height;\n    const centerX = w / 2;\n    const centerY = h / 2;\n\n    // Find dartboard rings\n    const detection = findDartboardRings(canvas);\n\n    if (!detection) {\n      return {\n        success: false,\n        cx: centerX,\n        cy: centerY,\n        bullInner: 0,\n        bullOuter: 0,\n        trebleInner: 0,\n        trebleOuter: 0,\n        doubleInner: 0,\n        doubleOuter: 0,\n        confidence: 0,\n        homography: null,\n        errorPx: null,\n        calibrationPoints: [],\n        message:\n          \"No dartboard detected. Ensure board is clearly visible with good contrast between rings and background.\",\n      };\n    }\n\n    // Scale all ring radii based on detected double radius\n    const scale = detection.r / BoardRadii.doubleOuter;\n\n    const detected = {\n      cx: detection.cx,\n      cy: detection.cy,\n      bullInner: BoardRadii.bullInner * scale,\n      bullOuter: BoardRadii.bullOuter * scale,\n      trebleInner: BoardRadii.trebleInner * scale,\n      trebleOuter: BoardRadii.trebleOuter * scale,\n      doubleInner: BoardRadii.doubleInner * scale,\n      doubleOuter: detection.r,\n    };\n\n    // Generate 4 calibration points from detected rings (TOP, RIGHT, BOTTOM, LEFT of double)\n    const calibrationPoints: Point[] = [\n      { x: detected.cx, y: detected.cy - detected.doubleOuter }, // TOP\n      { x: detected.cx + detected.doubleOuter, y: detected.cy }, // RIGHT\n      { x: detected.cx, y: detected.cy + detected.doubleOuter }, // BOTTOM\n      { x: detected.cx - detected.doubleOuter, y: detected.cy }, // LEFT\n    ];\n\n    // Compute homography from these 4 points\n    const canonicalSrc = [\n      { x: 0, y: -BoardRadii.doubleOuter },\n      { x: BoardRadii.doubleOuter, y: 0 },\n      { x: 0, y: BoardRadii.doubleOuter },\n      { x: -BoardRadii.doubleOuter, y: 0 },\n    ];\n\n    let homography: Homography | null = null;\n    let errorPx: number | null = null;\n    let confidence = detection.confidence;\n\n    try {\n      homography = computeHomographyDLT(canonicalSrc, calibrationPoints);\n      errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n      // Adjust confidence based on homography error\n      const errorConfidence = Math.max(\n        10,\n        Math.min(95, 100 - Math.max(0, errorPx - 1) * 10),\n      );\n      confidence = (confidence + errorConfidence) / 2;\n    } catch (err) {\n      confidence = Math.max(40, confidence);\n    }\n\n    const pointsValid = calibrationPoints.every(isFinitePoint);\n    const homographyValid = isFiniteHomography(homography);\n    const success = !!homographyValid && pointsValid && confidence > 50;\n\n    return {\n      success,\n      cx: detected.cx,\n      cy: detected.cy,\n      bullInner: detected.bullInner,\n      bullOuter: detected.bullOuter,\n      trebleInner: detected.trebleInner,\n      trebleOuter: detected.trebleOuter,\n      doubleInner: detected.doubleInner,\n      doubleOuter: detected.doubleOuter,\n      confidence,\n      homography: homographyValid ? homography : null,\n      errorPx: homographyValid ? errorPx : null,\n      calibrationPoints: pointsValid ? calibrationPoints : [],\n      message:\n        !pointsValid || !homographyValid\n          ? \"❌ Detection produced unstable calibration data. Adjust camera framing or calibrate manually.\"\n          : confidence > 80\n            ? \"✅ High confidence detection\"\n            : confidence > 50\n              ? \"⚠️ Detection found but could be better\"\n              : \"❌ Low confidence - try better lighting\",\n    };\n  } catch (err) {\n    return {\n      success: false,\n      cx: canvas.width / 2,\n      cy: canvas.height / 2,\n      bullInner: 0,\n      bullOuter: 0,\n      trebleInner: 0,\n      trebleOuter: 0,\n      doubleInner: 0,\n      doubleOuter: 0,\n      confidence: 0,\n      homography: null,\n      errorPx: null,\n      calibrationPoints: [],\n      message: err instanceof Error ? err.message : \"Board detection failed\",\n    };\n  }\n}\n\n/**\n * Refine detection by looking for concentric rings\n * This helps match detected circles to specific board rings\n */\nexport function refineRingDetection(\n  detected: BoardDetectionResult,\n): BoardDetectionResult {\n  // If detection already has good confidence, return as-is\n  if (detected.confidence > 70) return detected;\n\n  // Otherwise try to improve by checking ring ratios\n  // If rings don't match expected ratios, we can flag for manual refinement\n  const expectedRatios = {\n    bullInner_to_bullOuter: BoardRadii.bullInner / BoardRadii.bullOuter,\n    bullOuter_to_trebleInner: BoardRadii.bullOuter / BoardRadii.trebleInner,\n    trebleOuter_to_doubleInner: BoardRadii.trebleOuter / BoardRadii.doubleInner,\n    doubleInner_to_doubleOuter: BoardRadii.doubleInner / BoardRadii.doubleOuter,\n  };\n\n  const actualRatios = {\n    bullInner_to_bullOuter: detected.bullInner / detected.bullOuter,\n    bullOuter_to_trebleInner: detected.bullOuter / detected.trebleInner,\n    trebleOuter_to_doubleInner: detected.trebleOuter / detected.doubleInner,\n    doubleInner_to_doubleOuter: detected.doubleInner / detected.doubleOuter,\n  };\n\n  // Check ratio errors\n  let ratioError = 0;\n  let ratioCount = 0;\n  for (const [key, expected] of Object.entries(expectedRatios)) {\n    const actual = actualRatios[key as keyof typeof actualRatios];\n    const error = Math.abs(actual - expected) / expected;\n    ratioError += error;\n    ratioCount++;\n  }\n  const avgRatioError = ratioError / ratioCount;\n\n  // Adjust confidence based on ratio error\n  const adjustedConfidence = Math.max(\n    10,\n    detected.confidence - avgRatioError * 100,\n  );\n\n  return {\n    ...detected,\n    confidence: adjustedConfidence,\n    message:\n      adjustedConfidence > 70\n        ? \"✅ High confidence detection\"\n        : adjustedConfidence > 50\n          ? \"⚠️ Rings detected but ratios off - may need refinement\"\n          : \"❌ Low confidence - try repositioning camera\",\n  };\n}\n","import { detectBoard, refineRingDetection } from \"../utils/boardDetection\";\n\n// Worker receives an ImageBitmap and runs the detection on an OffscreenCanvas.\nself.onmessage = async (ev: MessageEvent) => {\n  try {\n    const { type, bitmap } = ev.data || {};\n    if (type !== \"detect\" || !bitmap) return;\n    // Create offscreen canvas of same size as bitmap\n    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      postMessage({ error: \"OffscreenCanvas context unavailable\" });\n      return;\n    }\n    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n    // Run detection\n    let detection = detectBoard(canvas as any as HTMLCanvasElement);\n    detection = refineRingDetection(detection as any);\n    // Transfer results back (serializable fields only)\n    postMessage({ type: \"result\", detection });\n  } catch (err) {\n    postMessage({\n      error: (err as any)?.message || String(err) || \"Worker error\",\n    });\n  }\n};\n\nexport {};\n"],"names":["BoardRadii","applyHomography","H","p","x","y","w","nx","ny","computeHomographyDLT","src","dst","A","B","k","X","Y","h","solveLeastSquares","b","m","n","AtA","Atb","r","i","j","gaussianSolve","M","v","row","maxRow","tmp","f","c","s","rmsError","e2","dx","dy","isFinitePoint","isFiniteHomography","findDartboardRings","canvas","ctx","data","edges","gx","gy","pidx","gray","mag","bestCenter","bestScore","cy","cx","ringCount","ringStrength","testRadii","testR","strength","pixelCount","edge","dist","refinedCx","refinedCy","doubleR","maxStrength","confidence","scale","knownR","expectedPixelR","detectBoard","centerX","centerY","detection","detected","calibrationPoints","canonicalSrc","homography","errorPx","errorConfidence","pointsValid","homographyValid","err","refineRingDetection","expectedRatios","actualRatios","ratioError","ratioCount","key","expected","actual","error","avgRatioError","adjustedConfidence","ev","type","bitmap"],"mappings":"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"}