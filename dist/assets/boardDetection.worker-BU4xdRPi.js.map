{"version":3,"file":"boardDetection.worker-BU4xdRPi.js","sources":["../src/utils/vision.ts","../src/utils/boardDetection.ts","../src/workers/boardDetection.worker.ts"],"sourcesContent":["// Vision and calibration utilities for dartboard mapping\n// Standard dartboard: 18 inches (457.2 mm) outer diameter\n// Board dimensions follow standard measurements (millimeters)\n// - Inner bull radius: 6.35 mm (12.7 mm diameter)\n// - Outer bull radius: 15.9 mm (31.8 mm diameter)\n// - Treble inner radius: 99 mm\n// - Treble outer radius: 107 mm\n// - Double inner radius: 162 mm\n// - Double outer radius: 170 mm (playing field outer edge = 340 mm diameter)\n\nexport type Point = { x: number; y: number };\nexport type Homography = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n]; // row-major 3x3\n\nexport const BoardRadii = {\n  bullInner: 6.35,\n  bullOuter: 15.9,\n  trebleInner: 99,\n  trebleOuter: 107,\n  doubleInner: 162,\n  doubleOuter: 170,\n};\n\nexport const SectorOrder = [\n  20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5,\n];\n\n// Basic 3x3 matrix operations\nfunction matMul3(a: Homography, b: Homography): Homography {\n  const r = new Array(9).fill(0);\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      for (let k = 0; k < 3; k++) {\n        r[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j];\n      }\n    }\n  }\n  return r as Homography;\n}\n\nexport function applyHomography(H: Homography, p: Point): Point {\n  const x = p.x,\n    y = p.y;\n  const w = H[6] * x + H[7] * y + H[8];\n  const nx = (H[0] * x + H[1] * y + H[2]) / w;\n  const ny = (H[3] * x + H[4] * y + H[5]) / w;\n  return { x: nx, y: ny };\n}\n\n// Scale a homography by sx, sy on the destination/image side: H' = S * H\n// Where S = diag([sx, sy, 1])\nexport function scaleHomography(\n  H: Homography,\n  sx: number,\n  sy: number,\n): Homography {\n  return [\n    sx * H[0],\n    sx * H[1],\n    sx * H[2],\n    sy * H[3],\n    sy * H[4],\n    sy * H[5],\n    H[6],\n    H[7],\n    H[8],\n  ] as Homography;\n}\n\nexport function invertHomography(H: Homography): Homography {\n  // Inverse of 3x3 matrix\n  const m = H;\n  const a = m[0],\n    b = m[1],\n    c = m[2],\n    d = m[3],\n    e = m[4],\n    f = m[5],\n    g = m[6],\n    h = m[7],\n    i = m[8];\n  const A = e * i - f * h;\n  const B = c * h - b * i;\n  const C = b * f - c * e;\n  const D = f * g - d * i;\n  const E = a * i - c * g;\n  const F = c * d - a * f;\n  const G = d * h - e * g;\n  const Hh = b * g - a * h;\n  const I = a * e - b * d;\n  const det = a * A + b * D + c * G;\n  if (Math.abs(det) < 1e-12) throw new Error(\"Singular homography\");\n  const inv = [\n    A / det,\n    B / det,\n    C / det,\n    D / det,\n    E / det,\n    F / det,\n    G / det,\n    Hh / det,\n    I / det,\n  ] as Homography;\n  return inv;\n}\n\n// Compute homography H that maps src (board space) -> dst (image space)\n// Using N correspondences via DLT (solved by Gaussian elimination) with least-squares fit\n// Supports overdetermined systems (N > 4) for improved accuracy\nexport function computeHomographyDLT(src: Point[], dst: Point[]): Homography {\n  if (src.length < 4 || dst.length < 4)\n    throw new Error(\"Need at least 4 correspondences\");\n  if (src.length !== dst.length)\n    throw new Error(\"Correspondences must have equal length\");\n  // Build A * h = b where h = [h11 h12 h13 h21 h22 h23 h31 h32]^T and h33 = 1\n  const A: number[][] = [];\n  const B: number[] = [];\n  for (let k = 0; k < src.length; k++) {\n    const { x: X, y: Y } = src[k];\n    const { x: x, y: y } = dst[k];\n    // x = (h11 X + h12 Y + h13) / (h31 X + h32 Y + 1)\n    // y = (h21 X + h22 Y + h23) / (h31 X + h32 Y + 1)\n    // => x*(h31 X + h32 Y + 1) = h11 X + h12 Y + h13\n    // => y*(h31 X + h32 Y + 1) = h21 X + h22 Y + h23\n    A.push([X, Y, 1, 0, 0, 0, -x * X, -x * Y]);\n    B.push(x);\n    A.push([0, 0, 0, X, Y, 1, -y * X, -y * Y]);\n    B.push(y);\n  }\n  const h = solveLeastSquares(A, B); // length 8\n  const H: Homography = [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1];\n  return H;\n}\n\n// Solve A x = b in least squares sense using Gaussian elimination with partial pivoting\nfunction solveLeastSquares(A: number[][], b: number[]): number[] {\n  // Normal equations: (A^T A) x = A^T b\n  const m = A.length,\n    n = A[0].length;\n  const AtA: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));\n  const Atb: number[] = new Array(n).fill(0);\n  for (let r = 0; r < m; r++) {\n    for (let i = 0; i < n; i++) {\n      Atb[i] += A[r][i] * b[r];\n      for (let j = 0; j < n; j++) {\n        AtA[i][j] += A[r][i] * A[r][j];\n      }\n    }\n  }\n  return gaussianSolve(AtA, Atb);\n}\n\nfunction gaussianSolve(M: number[][], v: number[]): number[] {\n  const n = v.length;\n  // Augment matrix\n  const A = M.map((row, i) => row.concat([v[i]]));\n  for (let i = 0; i < n; i++) {\n    // Pivot\n    let maxRow = i;\n    for (let r = i + 1; r < n; r++) {\n      if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;\n    }\n    if (Math.abs(A[maxRow][i]) < 1e-12) throw new Error(\"Singular matrix\");\n    if (maxRow !== i) {\n      const tmp = A[i];\n      A[i] = A[maxRow];\n      A[maxRow] = tmp;\n    }\n    // Eliminate\n    for (let r = i + 1; r < n; r++) {\n      const f = A[r][i] / A[i][i];\n      for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c];\n    }\n  }\n  // Back substitution\n  const x = new Array(n).fill(0);\n  for (let i = n - 1; i >= 0; i--) {\n    let s = A[i][n];\n    for (let c = i + 1; c < n; c++) s -= A[i][c] * x[c];\n    x[i] = s / A[i][i];\n  }\n  return x;\n}\n\n// Canonical calibration targets in board space (mm)\n// We now anchor the homography with four evenly spaced double-ring sectors:\n// D20 (top), D6 (right), D3 (bottom), and D11 (left).\nexport function canonicalRimTargets(): Point[] {\n  const doubleR = BoardRadii.doubleOuter;\n  const targetSectors = [20, 6, 3, 11] as const;\n  return targetSectors.map((sector) => {\n    const idx = SectorOrder.indexOf(sector);\n    const angle = (idx / SectorOrder.length) * Math.PI * 2 - Math.PI / 2;\n    const x = doubleR * Math.cos(angle);\n    const y = doubleR * Math.sin(angle);\n    return {\n      x: Math.abs(x) < 1e-9 ? 0 : x,\n      y: Math.abs(y) < 1e-9 ? 0 : y,\n    };\n  });\n}\n\n// Given a homography mapping board->image, produce polylines for overlay rings (in image px)\nexport function sampleRing(\n  H: Homography,\n  radius: number,\n  steps = 256,\n): Point[] {\n  const pts: Point[] = [];\n  for (let k = 0; k < steps; k++) {\n    const theta = (k / steps) * Math.PI * 2;\n    const p = applyHomography(H, {\n      x: radius * Math.cos(theta),\n      y: radius * Math.sin(theta),\n    });\n    pts.push(p);\n  }\n  return pts;\n}\n\nexport function rmsError(H: Homography, src: Point[], dst: Point[]): number {\n  let e2 = 0;\n  for (let i = 0; i < src.length; i++) {\n    const p = applyHomography(H, src[i]);\n    const dx = p.x - dst[i].x;\n    const dy = p.y - dst[i].y;\n    e2 += dx * dx + dy * dy;\n  }\n  return Math.sqrt(e2 / src.length);\n}\n\n// Map an image point to board coordinates using inverse homography (image->board)\nexport function imageToBoard(H_boardToImage: Homography, pImg: Point): Point {\n  const inv = invertHomography(H_boardToImage);\n  return applyHomography(inv as Homography, pImg);\n}\n\n// Compute score for a board coordinate (mm)\nexport function scoreAtBoardPoint(p: Point): {\n  base: number;\n  ring: \"MISS\" | \"SINGLE\" | \"DOUBLE\" | \"TRIPLE\" | \"BULL\" | \"INNER_BULL\";\n  sector: number | null;\n  mult: 0 | 1 | 2 | 3;\n} {\n  const r = Math.hypot(p.x, p.y);\n  const ang = Math.atan2(p.y, p.x); // 0 rad at +X, increasing CCW\n  // Rotate so that sector 20 is at the top (negative Y). Top corresponds to -90 degrees (or 270)\n  let deg = (ang * 180) / Math.PI;\n  deg = (deg + 360 + 90) % 360; // shift so 0 deg is at top\n  const sector = SectorOrder[Math.floor(((360 - deg) % 360) / 18)]; // clockwise ordering\n\n  if (r <= BoardRadii.bullInner)\n    return { base: 50, ring: \"INNER_BULL\", sector: 25, mult: 2 };\n  if (r <= BoardRadii.bullOuter)\n    return { base: 25, ring: \"BULL\", sector: 25, mult: 1 };\n  if (r >= BoardRadii.doubleOuter)\n    return { base: 0, ring: \"MISS\", sector: null, mult: 0 };\n  if (r >= BoardRadii.doubleInner)\n    return { base: sector * 2, ring: \"DOUBLE\", sector, mult: 2 };\n  if (r >= BoardRadii.trebleOuter)\n    return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\n  if (r >= BoardRadii.trebleInner)\n    return { base: sector * 3, ring: \"TRIPLE\", sector, mult: 3 };\n  return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\n}\n\nexport function drawPolyline(\n  ctx: CanvasRenderingContext2D,\n  pts: Point[],\n  color = \"#10b981\",\n  width = 2,\n) {\n  if (!pts.length) return;\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = width;\n  ctx.beginPath();\n  ctx.moveTo(pts[0].x, pts[0].y);\n  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nexport function drawCross(\n  ctx: CanvasRenderingContext2D,\n  p: Point,\n  color = \"#f59e0b\",\n) {\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(p.x - 8, p.y);\n  ctx.lineTo(p.x + 8, p.y);\n  ctx.moveTo(p.x, p.y - 8);\n  ctx.lineTo(p.x, p.y + 8);\n  ctx.stroke();\n  ctx.restore();\n}\n\n// --- Point refinement using Sobel gradient ---\nfunction clamp(v: number, lo: number, hi: number) {\n  return Math.max(lo, Math.min(hi, v));\n}\n\nfunction sobelAtGray(img: ImageData, x: number, y: number): number {\n  const { width, data } = img;\n  // Sobel kernels\n  const gx = [\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1],\n  ];\n  const gy = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [1, 2, 1],\n  ];\n  let sx = 0,\n    sy = 0;\n  for (let j = -1; j <= 1; j++) {\n    for (let i = -1; i <= 1; i++) {\n      const xi = clamp(x + i, 0, width - 1);\n      const yi = clamp(y + j, 0, img.height - 1);\n      const idx = (yi * width + xi) * 4;\n      const r = data[idx],\n        g = data[idx + 1],\n        b = data[idx + 2];\n      const gray = 0.299 * r + 0.587 * g + 0.114 * b;\n      sx += gray * gx[j + 1][i + 1];\n      sy += gray * gy[j + 1][i + 1];\n    }\n  }\n  return Math.hypot(sx, sy);\n}\n\nexport function refinePointSobel(\n  canvas: HTMLCanvasElement,\n  p: Point,\n  radius = 6,\n): Point {\n  const ctx = canvas.getContext(\"2d\")!;\n  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const cx = clamp(Math.round(p.x), 1, canvas.width - 2);\n  const cy = clamp(Math.round(p.y), 1, canvas.height - 2);\n  let best = { x: cx, y: cy, mag: -1 };\n  for (let y = cy - radius; y <= cy + radius; y++) {\n    for (let x = cx - radius; x <= cx + radius; x++) {\n      if (x <= 0 || y <= 0 || x >= canvas.width - 1 || y >= canvas.height - 1)\n        continue;\n      const mag = sobelAtGray(img, x, y);\n      if (mag > best.mag) best = { x, y, mag };\n    }\n  }\n  return { x: best.x, y: best.y };\n}\n\nexport function refinePointsSobel(\n  canvas: HTMLCanvasElement,\n  pts: Point[],\n  radius = 6,\n): Point[] {\n  return pts.map((p) => refinePointSobel(canvas, p, radius));\n}\n","/**\n * Advanced Dartboard Auto-Calibration\n *\n * Detects dartboard features automatically without markers or manual clicking:\n * 1. Detects bull (inner & outer rings) using circle detection\n * 2. Detects treble and double rings using edge/circle detection\n * 3. Computes board center and orientation\n * 4. Generates calibration points from detected rings\n * 5. Computes homography without user interaction\n */\n\nimport {\n  BoardRadii,\n  computeHomographyDLT,\n  rmsError,\n  type Homography,\n  type Point,\n} from \"./vision\";\n\nconst isFinitePoint = (p: Point | undefined): p is Point =>\n  !!p && Number.isFinite(p.x) && Number.isFinite(p.y);\nconst isFiniteHomography = (\n  H: Homography | null | undefined,\n): H is Homography =>\n  Array.isArray(H) && H.length === 9 && H.every(Number.isFinite);\n\nexport interface BoardDetectionResult {\n  success: boolean;\n  cx: number; // Board center X in image\n  cy: number; // Board center Y in image\n  bullInner: number; // Detected inner bull radius (pixels)\n  bullOuter: number; // Detected outer bull radius (pixels)\n  trebleInner: number; // Detected treble inner radius (pixels)\n  trebleOuter: number; // Detected treble outer radius (pixels)\n  doubleInner: number; // Detected double inner radius (pixels)\n  doubleOuter: number; // Detected double outer radius (pixels)\n  confidence: number; // 0-100, quality of detection\n  homography: Homography | null;\n  errorPx: number | null;\n  calibrationPoints: Point[];\n  message?: string;\n}\n\n/**\n * Detect dartboard by finding concentric rings\n * Simpler, more direct approach: look for strong circular edges at the right distances\n */\nfunction findDartboardRings(\n  canvas: HTMLCanvasElement,\n): { cx: number; cy: number; r: number; confidence: number; ringCount?: number; ringStrength?: number } | null {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return null;\n\n  const w = canvas.width;\n  const h = canvas.height;\n  const imageData = ctx.getImageData(0, 0, w, h);\n  const data = imageData.data;\n\n  // Step 1: Find all strong edges using Canny-like detection\n  const edges: Array<{ x: number; y: number; mag: number }> = [];\n\n  // dynamic gradient threshold based on image size (lower-res -> lower threshold)\n  const baseEdgeThreshold = Math.round(Math.max(8, Math.min(32, (w + h) / 120)));\n\n  // Precompute grayscale and apply a small blur to reduce high-frequency noise\n  const gray = new Float32Array(w * h);\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      const idx = (y * w + x) * 4;\n      gray[y * w + x] = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;\n    }\n  }\n  // 3x3 box blur into blurred array\n  const blurred = new Float32Array(w * h);\n  for (let y = 1; y < h - 1; y++) {\n    for (let x = 1; x < w - 1; x++) {\n      let sum = 0;\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          sum += gray[(y + dy) * w + (x + dx)];\n        }\n      }\n      blurred[y * w + x] = sum / 9;\n    }\n  }\n  // Compute gradients using blurred values\n  for (let y = 2; y < h - 2; y++) {\n    for (let x = 2; x < w - 2; x++) {\n      let gx = 0,\n        gy = 0;\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          const grayVal = blurred[(y + dy) * w + (x + dx)];\n          if (dx !== 0) gx += (dx > 0 ? 1 : -1) * grayVal;\n          if (dy !== 0) gy += (dy > 0 ? 1 : -1) * grayVal;\n        }\n      }\n      const mag = Math.hypot(gx, gy);\n      if (mag > baseEdgeThreshold) {\n        edges.push({ x, y, mag });\n      }\n    }\n  }\n\n  if (edges.length === 0) return null;\n\n  // global thresholds scaled by image resolution\n  const minPixelCount = Math.max(3, Math.round((w * h) / (640 * 480) * 10));\n  const minStrength = Math.max(80, Math.round((w * h) / (640 * 480) * 500));\n\n  // Step 2: For each potential center, score how many rings we can explain\n  let bestCenter = null;\n  let bestScore = 0;\n  let bestRingCount = 0;\n\n  // Sample potential centers\n  // Use a dynamic sampling stride based on image size\n  const stride = Math.max(6, Math.round(Math.min(w, h) / 40));\n  for (let cy = Math.round(h * 0.3); cy < Math.round(h * 0.7); cy += stride) {\n    for (let cx = Math.round(w * 0.3); cx < Math.round(w * 0.7); cx += stride) {\n      // For this center, find rings at expected radii\n      let ringCount = 0;\n      let ringStrength = 0;\n\n      // Estimate scale for pixels-per-mm by assuming the board double diameter occupies ~45% of min dimension\n      const approxDoublePixels = Math.min(w, h) * 0.45; // expected double radius in px\n      const scalePxPerMm = approxDoublePixels / BoardRadii.doubleOuter;\n      const testRadii = [\n        BoardRadii.bullInner * scalePxPerMm,\n        BoardRadii.bullOuter * scalePxPerMm,\n        BoardRadii.trebleInner * scalePxPerMm,\n        BoardRadii.trebleOuter * scalePxPerMm,\n        BoardRadii.doubleInner * scalePxPerMm,\n        BoardRadii.doubleOuter * scalePxPerMm,\n      ];\n\n      // Build radial histogram (bins) of edge magnitudes per radius for this center\n      const maxR = Math.round(Math.min(\n        Math.min(cx, w - cx),\n        Math.min(cy, h - cy),\n      ));\n      const bins = new Float32Array(maxR + 1);\n      let maxBin = 0;\n      for (const edge of edges) {\n        const dist = Math.round(Math.hypot(edge.x - cx, edge.y - cy));\n        if (dist <= 0 || dist > maxR) continue;\n        bins[dist] += edge.mag;\n        if (bins[dist] > maxBin) maxBin = bins[dist];\n      }\n\n      // Find significant peaks in histogram\n      const peakRadius: number[] = [];\n      const peakThreshold = Math.max(12, maxBin * 0.08);\n      for (let r = 2; r < maxR - 2; r++) {\n        const v = bins[r];\n        if (v <= peakThreshold) continue;\n        // local maxima\n        if (v > bins[r - 1] && v >= bins[r + 1]) {\n          peakRadius.push(r);\n        }\n      }\n\n      // Match expected radii against peaks\n      for (const testR of testRadii) {\n        // compute tolerance based on expected radius\n        const tol = Math.max(3, Math.round(testR * 0.02));\n        // find the peak nearest to testR\n        let bestPeak = -1;\n        let bestDist = Infinity;\n        for (const pr of peakRadius) {\n          const d = Math.abs(pr - testR);\n          if (d < bestDist) {\n            bestDist = d;\n            bestPeak = pr;\n          }\n        }\n        if (bestPeak >= 0 && bestDist <= tol) {\n          // ring strength is bin magnitude at that peak\n          ringCount++;\n          ringStrength += bins[bestPeak] || 0;\n        }\n      }\n\n      // Want at least 3 strong rings (loosened for small/partial crops)\n      if (ringCount >= 3 && ringStrength > bestScore) {\n        bestScore = ringStrength;\n        bestCenter = { cx, cy };\n        bestRingCount = ringCount;\n      }\n    }\n  }\n\n  if (!bestCenter) return null;\n\n  // Step 3: Refine the center position and find double radius\n  const refinedCx = bestCenter.cx;\n  const refinedCy = bestCenter.cy;\n\n  // Find the strongest ring near where we expect the double outer\n  // Use an adaptive scan range based on image size\n  const approxDoublePixels = Math.min(w, h) * 0.45;\n  const minScan = Math.max(6, Math.round(approxDoublePixels * 0.5));\n  const maxScan = Math.min(Math.round(Math.max(w, h) - 4), Math.round(approxDoublePixels * 1.5));\n  let doubleR = Math.round(approxDoublePixels);\n  let maxStrength = 0;\n\n  for (let testR = minScan; testR <= maxScan; testR += Math.max(2, Math.round((maxScan - minScan) / 60))) {\n    let strength = 0;\n    let pixelCount = 0;\n\n    for (const edge of edges) {\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\n      const tol = Math.max(2, Math.round(testR * 0.01));\n      if (Math.abs(dist - testR) < tol) {\n        strength += edge.mag;\n        pixelCount++;\n      }\n    }\n\n    if (pixelCount > Math.max(6, Math.round(minPixelCount * 0.6)) && strength > maxStrength) {\n      maxStrength = strength;\n      doubleR = testR;\n    }\n  }\n\n  // Calculate confidence based on how many proper rings we found\n  let confidence = 0;\n  const scale = doubleR / BoardRadii.doubleOuter;\n\n  for (const knownR of [\n    BoardRadii.bullInner,\n    BoardRadii.bullOuter,\n    BoardRadii.trebleInner,\n    BoardRadii.trebleOuter,\n    BoardRadii.doubleInner,\n    BoardRadii.doubleOuter,\n  ]) {\n    const expectedPixelR = knownR * scale;\n    let found = false;\n\n    for (const edge of edges) {\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\n      const tol = Math.max(3, Math.round(expectedPixelR * 0.02));\n      if (Math.abs(dist - expectedPixelR) < tol) {\n        found = true;\n        confidence += 15;\n        break;\n      }\n    }\n  }\n\n  confidence = Math.min(100, confidence);\n\n  return {\n    cx: refinedCx,\n    cy: refinedCy,\n    r: doubleR,\n    confidence,\n    ringCount: bestRingCount,\n    ringStrength: Math.round(bestScore),\n  };\n}\n\n/**\n * Main board detection function\n * Uses direct ring detection approach\n */\nexport function detectBoard(canvas: HTMLCanvasElement): BoardDetectionResult {\n  try {\n    const w = canvas.width;\n    const h = canvas.height;\n    const centerX = w / 2;\n    const centerY = h / 2;\n\n    // Find dartboard rings\n    const detection = findDartboardRings(canvas);\n\n    if (!detection) {\n      return {\n        success: false,\n        cx: centerX,\n        cy: centerY,\n        bullInner: 0,\n        bullOuter: 0,\n        trebleInner: 0,\n        trebleOuter: 0,\n        doubleInner: 0,\n        doubleOuter: 0,\n        confidence: 0,\n        homography: null,\n        errorPx: null,\n        calibrationPoints: [],\n        message:\n          \"No dartboard detected. Ensure board is clearly visible with good contrast between rings and background.\",\n      };\n    }\n\n    // Scale all ring radii based on detected double radius\n    const scale = detection.r / BoardRadii.doubleOuter;\n\n    const detected = {\n      cx: detection.cx,\n      cy: detection.cy,\n      bullInner: BoardRadii.bullInner * scale,\n      bullOuter: BoardRadii.bullOuter * scale,\n      trebleInner: BoardRadii.trebleInner * scale,\n      trebleOuter: BoardRadii.trebleOuter * scale,\n      doubleInner: BoardRadii.doubleInner * scale,\n      doubleOuter: detection.r,\n    };\n\n    // Generate 4 calibration points from detected rings (TOP, RIGHT, BOTTOM, LEFT of double)\n    const calibrationPoints: Point[] = [\n      { x: detected.cx, y: detected.cy - detected.doubleOuter }, // TOP\n      { x: detected.cx + detected.doubleOuter, y: detected.cy }, // RIGHT\n      { x: detected.cx, y: detected.cy + detected.doubleOuter }, // BOTTOM\n      { x: detected.cx - detected.doubleOuter, y: detected.cy }, // LEFT\n    ];\n\n    // Compute homography from these 4 points\n    const canonicalSrc = [\n      { x: 0, y: -BoardRadii.doubleOuter },\n      { x: BoardRadii.doubleOuter, y: 0 },\n      { x: 0, y: BoardRadii.doubleOuter },\n      { x: -BoardRadii.doubleOuter, y: 0 },\n    ];\n\n  let homography: Homography | null = null;\n    let errorPx: number | null = null;\n    let confidence = detection.confidence;\n\n    try {\n      homography = computeHomographyDLT(canonicalSrc, calibrationPoints);\n      errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\n      // Adjust confidence based on homography error\n      const errorConfidence = Math.max(\n        10,\n        Math.min(95, 100 - Math.max(0, errorPx - 1) * 10),\n      );\n      confidence = (confidence + errorConfidence) / 2;\n    } catch (err) {\n      confidence = Math.max(40, confidence);\n    }\n\n  const pointsValid = calibrationPoints.every(isFinitePoint);\n    const homographyValid = isFiniteHomography(homography);\n    const success = !!homographyValid && pointsValid && confidence > 50;\n  const detRingCount = detection.ringCount ?? 0;\n  const detRingStrength = detection.ringStrength ?? 0;\n\n    return {\n      success,\n      cx: detected.cx,\n      cy: detected.cy,\n      bullInner: detected.bullInner,\n      bullOuter: detected.bullOuter,\n      trebleInner: detected.trebleInner,\n      trebleOuter: detected.trebleOuter,\n      doubleInner: detected.doubleInner,\n      doubleOuter: detected.doubleOuter,\n      confidence,\n      homography: homographyValid ? homography : null,\n      errorPx: homographyValid ? errorPx : null,\n      calibrationPoints: pointsValid ? calibrationPoints : [],\n      message:\n        !pointsValid || !homographyValid\n          ? `❌ Detection produced unstable calibration data. Adjust camera framing or calibrate manually. (rings: ${detRingCount}, r:${Math.round(detection.r)})`\n          : confidence > 80\n          ? `✅ High confidence detection (rings: ${detRingCount}, r:${Math.round(detection.r)})`\n          : confidence > 50\n          ? `⚠️ Detection found but could be better (rings: ${detRingCount}, r:${Math.round(detection.r)})`\n          : `❌ Low confidence - try better lighting (rings: ${detRingCount}, r:${Math.round(detection.r)})`,\n    };\n  } catch (err) {\n    return {\n      success: false,\n      cx: canvas.width / 2,\n      cy: canvas.height / 2,\n      bullInner: 0,\n      bullOuter: 0,\n      trebleInner: 0,\n      trebleOuter: 0,\n      doubleInner: 0,\n      doubleOuter: 0,\n      confidence: 0,\n      homography: null,\n      errorPx: null,\n      calibrationPoints: [],\n      message: err instanceof Error ? err.message : \"Board detection failed\",\n    };\n  }\n}\n\n/**\n * Refine detection by looking for concentric rings\n * This helps match detected circles to specific board rings\n */\nexport function refineRingDetection(\n  detected: BoardDetectionResult,\n): BoardDetectionResult {\n  // If detection already has good confidence, return as-is\n  if (detected.confidence > 70) return detected;\n\n  // Otherwise try to improve by checking ring ratios\n  // If rings don't match expected ratios, we can flag for manual refinement\n  const expectedRatios = {\n    bullInner_to_bullOuter: BoardRadii.bullInner / BoardRadii.bullOuter,\n    bullOuter_to_trebleInner: BoardRadii.bullOuter / BoardRadii.trebleInner,\n    trebleOuter_to_doubleInner: BoardRadii.trebleOuter / BoardRadii.doubleInner,\n    doubleInner_to_doubleOuter: BoardRadii.doubleInner / BoardRadii.doubleOuter,\n  };\n\n  const actualRatios = {\n    bullInner_to_bullOuter: detected.bullInner / detected.bullOuter,\n    bullOuter_to_trebleInner: detected.bullOuter / detected.trebleInner,\n    trebleOuter_to_doubleInner: detected.trebleOuter / detected.doubleInner,\n    doubleInner_to_doubleOuter: detected.doubleInner / detected.doubleOuter,\n  };\n\n  // Check ratio errors\n  let ratioError = 0;\n  let ratioCount = 0;\n  for (const [key, expected] of Object.entries(expectedRatios)) {\n    const actual = actualRatios[key as keyof typeof actualRatios];\n    const error = Math.abs(actual - expected) / expected;\n    ratioError += error;\n    ratioCount++;\n  }\n  const avgRatioError = ratioError / ratioCount;\n\n  // Adjust confidence based on ratio error\n  const adjustedConfidence = Math.max(\n    10,\n    detected.confidence - avgRatioError * 100,\n  );\n\n  return {\n    ...detected,\n    confidence: adjustedConfidence,\n    message:\n      adjustedConfidence > 70\n        ? \"✅ High confidence detection\"\n        : adjustedConfidence > 50\n          ? \"⚠️ Rings detected but ratios off - may need refinement\"\n          : \"❌ Low confidence - try repositioning camera\",\n  };\n}\n","import { detectBoard, refineRingDetection } from \"../utils/boardDetection\";\n\n// Worker receives an ImageBitmap and runs the detection on an OffscreenCanvas.\nself.onmessage = async (ev: MessageEvent) => {\n  try {\n    const { type, bitmap } = ev.data || {};\n    if (type !== \"detect\" || !bitmap) return;\n    // Create offscreen canvas of same size as bitmap\n    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      postMessage({ error: \"OffscreenCanvas context unavailable\" });\n      return;\n    }\n    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n    // Run detection\n    let detection = detectBoard(canvas as any as HTMLCanvasElement);\n    detection = refineRingDetection(detection as any);\n    // Transfer results back (serializable fields only)\n    postMessage({ type: \"result\", detection });\n  } catch (err) {\n    postMessage({\n      error: (err as any)?.message || String(err) || \"Worker error\",\n    });\n  }\n};\n\nexport {};\n"],"names":["BoardRadii","applyHomography","H","p","x","y","w","nx","ny","computeHomographyDLT","src","dst","A","B","k","X","Y","h","solveLeastSquares","b","m","AtA","Atb","r","i","j","gaussianSolve","M","v","n","row","maxRow","tmp","f","c","s","rmsError","e2","dx","dy","isFinitePoint","isFiniteHomography","findDartboardRings","canvas","ctx","data","edges","baseEdgeThreshold","gray","idx","blurred","sum","gx","gy","grayVal","mag","minPixelCount","bestCenter","bestScore","bestRingCount","stride","cy","cx","ringCount","ringStrength","scalePxPerMm","testRadii","maxR","bins","maxBin","edge","dist","peakRadius","peakThreshold","testR","tol","bestPeak","bestDist","pr","d","refinedCx","refinedCy","approxDoublePixels","minScan","maxScan","doubleR","maxStrength","strength","pixelCount","confidence","scale","knownR","expectedPixelR","detectBoard","centerX","centerY","detection","detected","calibrationPoints","canonicalSrc","homography","errorPx","errorConfidence","pointsValid","homographyValid","success","detRingCount","detRingStrength","err","refineRingDetection","expectedRatios","actualRatios","ratioError","ratioCount","key","expected","actual","error","avgRatioError","adjustedConfidence","ev","type","bitmap"],"mappings":"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"}