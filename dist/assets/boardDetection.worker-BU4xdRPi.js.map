{"version":3,"file":"boardDetection.worker-BU4xdRPi.js","sources":["../src/utils/vision.ts","../src/utils/boardDetection.ts","../src/workers/boardDetection.worker.ts"],"sourcesContent":["// Vision and calibration utilities for dartboard mapping\r\n// Standard dartboard: 18 inches (457.2 mm) outer diameter\r\n// Board dimensions follow standard measurements (millimeters)\r\n// - Inner bull radius: 6.35 mm (12.7 mm diameter)\r\n// - Outer bull radius: 15.9 mm (31.8 mm diameter)\r\n// - Treble inner radius: 99 mm\r\n// - Treble outer radius: 107 mm\r\n// - Double inner radius: 162 mm\r\n// - Double outer radius: 170 mm (playing field outer edge = 340 mm diameter)\r\n\r\nexport type Point = { x: number; y: number };\r\nexport type Homography = [\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n  number,\r\n]; // row-major 3x3\r\n\r\nexport const BoardRadii = {\r\n  bullInner: 6.35,\r\n  bullOuter: 15.9,\r\n  trebleInner: 99,\r\n  trebleOuter: 107,\r\n  doubleInner: 162,\r\n  doubleOuter: 170,\r\n};\r\n\r\nexport const SectorOrder = [\r\n  20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5,\r\n];\r\n\r\n// Basic 3x3 matrix operations\r\nfunction matMul3(a: Homography, b: Homography): Homography {\r\n  const r = new Array(9).fill(0);\r\n  for (let i = 0; i < 3; i++) {\r\n    for (let j = 0; j < 3; j++) {\r\n      for (let k = 0; k < 3; k++) {\r\n        r[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j];\r\n      }\r\n    }\r\n  }\r\n  return r as Homography;\r\n}\r\n\r\nexport function applyHomography(H: Homography, p: Point): Point {\r\n  const x = p.x,\r\n    y = p.y;\r\n  const w = H[6] * x + H[7] * y + H[8];\r\n  const nx = (H[0] * x + H[1] * y + H[2]) / w;\r\n  const ny = (H[3] * x + H[4] * y + H[5]) / w;\r\n  return { x: nx, y: ny };\r\n}\r\n\r\n// Scale a homography by sx, sy on the destination/image side: H' = S * H\r\n// Where S = diag([sx, sy, 1])\r\nexport function scaleHomography(\r\n  H: Homography,\r\n  sx: number,\r\n  sy: number,\r\n): Homography {\r\n  return [\r\n    sx * H[0],\r\n    sx * H[1],\r\n    sx * H[2],\r\n    sy * H[3],\r\n    sy * H[4],\r\n    sy * H[5],\r\n    H[6],\r\n    H[7],\r\n    H[8],\r\n  ] as Homography;\r\n}\r\n\r\nexport function invertHomography(H: Homography): Homography {\r\n  // Inverse of 3x3 matrix\r\n  const m = H;\r\n  const a = m[0],\r\n    b = m[1],\r\n    c = m[2],\r\n    d = m[3],\r\n    e = m[4],\r\n    f = m[5],\r\n    g = m[6],\r\n    h = m[7],\r\n    i = m[8];\r\n  const A = e * i - f * h;\r\n  const B = c * h - b * i;\r\n  const C = b * f - c * e;\r\n  const D = f * g - d * i;\r\n  const E = a * i - c * g;\r\n  const F = c * d - a * f;\r\n  const G = d * h - e * g;\r\n  const Hh = b * g - a * h;\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * D + c * G;\r\n  if (Math.abs(det) < 1e-12) throw new Error(\"Singular homography\");\r\n  const inv = [\r\n    A / det,\r\n    B / det,\r\n    C / det,\r\n    D / det,\r\n    E / det,\r\n    F / det,\r\n    G / det,\r\n    Hh / det,\r\n    I / det,\r\n  ] as Homography;\r\n  return inv;\r\n}\r\n\r\n// Compute homography H that maps src (board space) -> dst (image space)\r\n// Using N correspondences via DLT (solved by Gaussian elimination) with least-squares fit\r\n// Supports overdetermined systems (N > 4) for improved accuracy\r\nexport function computeHomographyDLT(src: Point[], dst: Point[]): Homography {\r\n  if (src.length < 4 || dst.length < 4)\r\n    throw new Error(\"Need at least 4 correspondences\");\r\n  if (src.length !== dst.length)\r\n    throw new Error(\"Correspondences must have equal length\");\r\n  // Build A * h = b where h = [h11 h12 h13 h21 h22 h23 h31 h32]^T and h33 = 1\r\n  const A: number[][] = [];\r\n  const B: number[] = [];\r\n  for (let k = 0; k < src.length; k++) {\r\n    const { x: X, y: Y } = src[k];\r\n    const { x: x, y: y } = dst[k];\r\n    // x = (h11 X + h12 Y + h13) / (h31 X + h32 Y + 1)\r\n    // y = (h21 X + h22 Y + h23) / (h31 X + h32 Y + 1)\r\n    // => x*(h31 X + h32 Y + 1) = h11 X + h12 Y + h13\r\n    // => y*(h31 X + h32 Y + 1) = h21 X + h22 Y + h23\r\n    A.push([X, Y, 1, 0, 0, 0, -x * X, -x * Y]);\r\n    B.push(x);\r\n    A.push([0, 0, 0, X, Y, 1, -y * X, -y * Y]);\r\n    B.push(y);\r\n  }\r\n  const h = solveLeastSquares(A, B); // length 8\r\n  const H: Homography = [h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], 1];\r\n  return H;\r\n}\r\n\r\n// Solve A x = b in least squares sense using Gaussian elimination with partial pivoting\r\nfunction solveLeastSquares(A: number[][], b: number[]): number[] {\r\n  // Normal equations: (A^T A) x = A^T b\r\n  const m = A.length,\r\n    n = A[0].length;\r\n  const AtA: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));\r\n  const Atb: number[] = new Array(n).fill(0);\r\n  for (let r = 0; r < m; r++) {\r\n    for (let i = 0; i < n; i++) {\r\n      Atb[i] += A[r][i] * b[r];\r\n      for (let j = 0; j < n; j++) {\r\n        AtA[i][j] += A[r][i] * A[r][j];\r\n      }\r\n    }\r\n  }\r\n  return gaussianSolve(AtA, Atb);\r\n}\r\n\r\nfunction gaussianSolve(M: number[][], v: number[]): number[] {\r\n  const n = v.length;\r\n  // Augment matrix\r\n  const A = M.map((row, i) => row.concat([v[i]]));\r\n  for (let i = 0; i < n; i++) {\r\n    // Pivot\r\n    let maxRow = i;\r\n    for (let r = i + 1; r < n; r++) {\r\n      if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;\r\n    }\r\n    if (Math.abs(A[maxRow][i]) < 1e-12) throw new Error(\"Singular matrix\");\r\n    if (maxRow !== i) {\r\n      const tmp = A[i];\r\n      A[i] = A[maxRow];\r\n      A[maxRow] = tmp;\r\n    }\r\n    // Eliminate\r\n    for (let r = i + 1; r < n; r++) {\r\n      const f = A[r][i] / A[i][i];\r\n      for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c];\r\n    }\r\n  }\r\n  // Back substitution\r\n  const x = new Array(n).fill(0);\r\n  for (let i = n - 1; i >= 0; i--) {\r\n    let s = A[i][n];\r\n    for (let c = i + 1; c < n; c++) s -= A[i][c] * x[c];\r\n    x[i] = s / A[i][i];\r\n  }\r\n  return x;\r\n}\r\n\r\n// Canonical calibration targets in board space (mm)\r\n// We now anchor the homography with four evenly spaced double-ring sectors:\r\n// D20 (top), D6 (right), D3 (bottom), and D11 (left).\r\nexport function canonicalRimTargets(): Point[] {\r\n  const doubleR = BoardRadii.doubleOuter;\r\n  const targetSectors = [20, 6, 3, 11] as const;\r\n  return targetSectors.map((sector) => {\r\n    const idx = SectorOrder.indexOf(sector);\r\n    const angle = (idx / SectorOrder.length) * Math.PI * 2 - Math.PI / 2;\r\n    const x = doubleR * Math.cos(angle);\r\n    const y = doubleR * Math.sin(angle);\r\n    return {\r\n      x: Math.abs(x) < 1e-9 ? 0 : x,\r\n      y: Math.abs(y) < 1e-9 ? 0 : y,\r\n    };\r\n  });\r\n}\r\n\r\n// Given a homography mapping board->image, produce polylines for overlay rings (in image px)\r\nexport function sampleRing(\r\n  H: Homography,\r\n  radius: number,\r\n  steps = 256,\r\n): Point[] {\r\n  const pts: Point[] = [];\r\n  for (let k = 0; k < steps; k++) {\r\n    const theta = (k / steps) * Math.PI * 2;\r\n    const p = applyHomography(H, {\r\n      x: radius * Math.cos(theta),\r\n      y: radius * Math.sin(theta),\r\n    });\r\n    pts.push(p);\r\n  }\r\n  return pts;\r\n}\r\n\r\nexport function rmsError(H: Homography, src: Point[], dst: Point[]): number {\r\n  let e2 = 0;\r\n  for (let i = 0; i < src.length; i++) {\r\n    const p = applyHomography(H, src[i]);\r\n    const dx = p.x - dst[i].x;\r\n    const dy = p.y - dst[i].y;\r\n    e2 += dx * dx + dy * dy;\r\n  }\r\n  return Math.sqrt(e2 / src.length);\r\n}\r\n\r\n// Map an image point to board coordinates using inverse homography (image->board)\r\nexport function imageToBoard(H_boardToImage: Homography, pImg: Point): Point {\r\n  const inv = invertHomography(H_boardToImage);\r\n  return applyHomography(inv as Homography, pImg);\r\n}\r\n\r\n// Compute score for a board coordinate (mm)\r\nexport function scoreAtBoardPoint(p: Point): {\r\n  base: number;\r\n  ring: \"MISS\" | \"SINGLE\" | \"DOUBLE\" | \"TRIPLE\" | \"BULL\" | \"INNER_BULL\";\r\n  sector: number | null;\r\n  mult: 0 | 1 | 2 | 3;\r\n} {\r\n  const r = Math.hypot(p.x, p.y);\r\n  const ang = Math.atan2(p.y, p.x); // 0 rad at +X, increasing CCW\r\n  // Rotate so that sector 20 is at the top (negative Y). Top corresponds to -90 degrees (or 270)\r\n  let deg = (ang * 180) / Math.PI;\r\n  deg = (deg + 360 + 90) % 360; // shift so 0 deg is at top\r\n  const sector = SectorOrder[Math.floor(deg / 18)]; // deg now ranges 0..360 with 0 at top (clockwise ordering using array)\r\n\r\n  if (r <= BoardRadii.bullInner)\r\n    return { base: 50, ring: \"INNER_BULL\", sector: 25, mult: 2 };\r\n  if (r <= BoardRadii.bullOuter)\r\n    return { base: 25, ring: \"BULL\", sector: 25, mult: 1 };\r\n  if (r >= BoardRadii.doubleOuter)\r\n    return { base: 0, ring: \"MISS\", sector: null, mult: 0 };\r\n  if (r >= BoardRadii.doubleInner)\r\n    return { base: sector * 2, ring: \"DOUBLE\", sector, mult: 2 };\r\n  if (r >= BoardRadii.trebleOuter)\r\n    return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\r\n  if (r >= BoardRadii.trebleInner)\r\n    return { base: sector * 3, ring: \"TRIPLE\", sector, mult: 3 };\r\n  return { base: sector, ring: \"SINGLE\", sector, mult: 1 };\r\n}\r\n\r\nexport function drawPolyline(\r\n  ctx: CanvasRenderingContext2D,\r\n  pts: Point[],\r\n  color = \"#10b981\",\r\n  width = 2,\r\n) {\r\n  if (!pts.length) return;\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = width;\r\n  ctx.beginPath();\r\n  ctx.moveTo(pts[0].x, pts[0].y);\r\n  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nexport function drawCross(\r\n  ctx: CanvasRenderingContext2D,\r\n  p: Point,\r\n  color = \"#f59e0b\",\r\n) {\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = 2;\r\n  ctx.beginPath();\r\n  ctx.moveTo(p.x - 8, p.y);\r\n  ctx.lineTo(p.x + 8, p.y);\r\n  ctx.moveTo(p.x, p.y - 8);\r\n  ctx.lineTo(p.x, p.y + 8);\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\n// --- Point refinement using Sobel gradient ---\r\nfunction clamp(v: number, lo: number, hi: number) {\r\n  return Math.max(lo, Math.min(hi, v));\r\n}\r\n\r\nfunction sobelAtGray(img: ImageData, x: number, y: number): number {\r\n  const { width, data } = img;\r\n  // Sobel kernels\r\n  const gx = [\r\n    [-1, 0, 1],\r\n    [-2, 0, 2],\r\n    [-1, 0, 1],\r\n  ];\r\n  const gy = [\r\n    [-1, -2, -1],\r\n    [0, 0, 0],\r\n    [1, 2, 1],\r\n  ];\r\n  let sx = 0,\r\n    sy = 0;\r\n  for (let j = -1; j <= 1; j++) {\r\n    for (let i = -1; i <= 1; i++) {\r\n      const xi = clamp(x + i, 0, width - 1);\r\n      const yi = clamp(y + j, 0, img.height - 1);\r\n      const idx = (yi * width + xi) * 4;\r\n      const r = data[idx],\r\n        g = data[idx + 1],\r\n        b = data[idx + 2];\r\n      const gray = 0.299 * r + 0.587 * g + 0.114 * b;\r\n      sx += gray * gx[j + 1][i + 1];\r\n      sy += gray * gy[j + 1][i + 1];\r\n    }\r\n  }\r\n  return Math.hypot(sx, sy);\r\n}\r\n\r\nexport function refinePointSobel(\r\n  canvas: HTMLCanvasElement,\r\n  p: Point,\r\n  radius = 6,\r\n): Point {\r\n  const ctx = canvas.getContext(\"2d\")!;\r\n  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n  const cx = clamp(Math.round(p.x), 1, canvas.width - 2);\r\n  const cy = clamp(Math.round(p.y), 1, canvas.height - 2);\r\n  let best = { x: cx, y: cy, mag: -1 };\r\n  for (let y = cy - radius; y <= cy + radius; y++) {\r\n    for (let x = cx - radius; x <= cx + radius; x++) {\r\n      if (x <= 0 || y <= 0 || x >= canvas.width - 1 || y >= canvas.height - 1)\r\n        continue;\r\n      const mag = sobelAtGray(img, x, y);\r\n      if (mag > best.mag) best = { x, y, mag };\r\n    }\r\n  }\r\n  return { x: best.x, y: best.y };\r\n}\r\n\r\nexport function refinePointsSobel(\r\n  canvas: HTMLCanvasElement,\r\n  pts: Point[],\r\n  radius = 6,\r\n): Point[] {\r\n  return pts.map((p) => refinePointSobel(canvas, p, radius));\r\n}\r\n","/**\r\n * Advanced Dartboard Auto-Calibration\r\n *\r\n * Detects dartboard features automatically without markers or manual clicking:\r\n * 1. Detects bull (inner & outer rings) using circle detection\r\n * 2. Detects treble and double rings using edge/circle detection\r\n * 3. Computes board center and orientation\r\n * 4. Generates calibration points from detected rings\r\n * 5. Computes homography without user interaction\r\n */\r\n\r\nimport {\r\n  BoardRadii,\r\n  computeHomographyDLT,\r\n  rmsError,\r\n  type Homography,\r\n  type Point,\r\n} from \"./vision\";\r\n\r\nconst isFinitePoint = (p: Point | undefined): p is Point =>\r\n  !!p && Number.isFinite(p.x) && Number.isFinite(p.y);\r\nconst isFiniteHomography = (\r\n  H: Homography | null | undefined,\r\n): H is Homography =>\r\n  Array.isArray(H) && H.length === 9 && H.every(Number.isFinite);\r\n\r\nexport interface BoardDetectionResult {\r\n  success: boolean;\r\n  cx: number; // Board center X in image\r\n  cy: number; // Board center Y in image\r\n  bullInner: number; // Detected inner bull radius (pixels)\r\n  bullOuter: number; // Detected outer bull radius (pixels)\r\n  trebleInner: number; // Detected treble inner radius (pixels)\r\n  trebleOuter: number; // Detected treble outer radius (pixels)\r\n  doubleInner: number; // Detected double inner radius (pixels)\r\n  doubleOuter: number; // Detected double outer radius (pixels)\r\n  confidence: number; // 0-100, quality of detection\r\n  homography: Homography | null;\r\n  errorPx: number | null;\r\n  calibrationPoints: Point[];\r\n  message?: string;\r\n}\r\n\r\n/**\r\n * Detect dartboard by finding concentric rings\r\n * Simpler, more direct approach: look for strong circular edges at the right distances\r\n */\r\nfunction findDartboardRings(\r\n  canvas: HTMLCanvasElement,\r\n): { cx: number; cy: number; r: number; confidence: number; ringCount?: number; ringStrength?: number } | null {\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return null;\r\n\r\n  const w = canvas.width;\r\n  const h = canvas.height;\r\n  const imageData = ctx.getImageData(0, 0, w, h);\r\n  const data = imageData.data;\r\n\r\n  // Step 1: Find all strong edges using Canny-like detection\r\n  const edges: Array<{ x: number; y: number; mag: number }> = [];\r\n\r\n  // dynamic gradient threshold based on image size (lower-res -> lower threshold)\r\n  const baseEdgeThreshold = Math.round(Math.max(8, Math.min(32, (w + h) / 120)));\r\n\r\n  // Precompute grayscale and apply a small blur to reduce high-frequency noise\r\n  const gray = new Float32Array(w * h);\r\n  for (let y = 0; y < h; y++) {\r\n    for (let x = 0; x < w; x++) {\r\n      const idx = (y * w + x) * 4;\r\n      gray[y * w + x] = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;\r\n    }\r\n  }\r\n  // 3x3 box blur into blurred array\r\n  const blurred = new Float32Array(w * h);\r\n  for (let y = 1; y < h - 1; y++) {\r\n    for (let x = 1; x < w - 1; x++) {\r\n      let sum = 0;\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n          sum += gray[(y + dy) * w + (x + dx)];\r\n        }\r\n      }\r\n      blurred[y * w + x] = sum / 9;\r\n    }\r\n  }\r\n  // Compute gradients using blurred values\r\n  for (let y = 2; y < h - 2; y++) {\r\n    for (let x = 2; x < w - 2; x++) {\r\n      let gx = 0,\r\n        gy = 0;\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n          const grayVal = blurred[(y + dy) * w + (x + dx)];\r\n          if (dx !== 0) gx += (dx > 0 ? 1 : -1) * grayVal;\r\n          if (dy !== 0) gy += (dy > 0 ? 1 : -1) * grayVal;\r\n        }\r\n      }\r\n      const mag = Math.hypot(gx, gy);\r\n      if (mag > baseEdgeThreshold) {\r\n        edges.push({ x, y, mag });\r\n      }\r\n    }\r\n  }\r\n\r\n  if (edges.length === 0) return null;\r\n\r\n  // global thresholds scaled by image resolution\r\n  const minPixelCount = Math.max(3, Math.round((w * h) / (640 * 480) * 10));\r\n  const minStrength = Math.max(80, Math.round((w * h) / (640 * 480) * 500));\r\n\r\n  // Step 2: For each potential center, score how many rings we can explain\r\n  let bestCenter = null;\r\n  let bestScore = 0;\r\n  let bestRingCount = 0;\r\n\r\n  // Sample potential centers\r\n  // Use a dynamic sampling stride based on image size\r\n  const stride = Math.max(6, Math.round(Math.min(w, h) / 40));\r\n  for (let cy = Math.round(h * 0.3); cy < Math.round(h * 0.7); cy += stride) {\r\n    for (let cx = Math.round(w * 0.3); cx < Math.round(w * 0.7); cx += stride) {\r\n      // For this center, find rings at expected radii\r\n      let ringCount = 0;\r\n      let ringStrength = 0;\r\n\r\n      // Estimate scale for pixels-per-mm by assuming the board double diameter occupies ~45% of min dimension\r\n      const approxDoublePixels = Math.min(w, h) * 0.45; // expected double radius in px\r\n      const scalePxPerMm = approxDoublePixels / BoardRadii.doubleOuter;\r\n      const testRadii = [\r\n        BoardRadii.bullInner * scalePxPerMm,\r\n        BoardRadii.bullOuter * scalePxPerMm,\r\n        BoardRadii.trebleInner * scalePxPerMm,\r\n        BoardRadii.trebleOuter * scalePxPerMm,\r\n        BoardRadii.doubleInner * scalePxPerMm,\r\n        BoardRadii.doubleOuter * scalePxPerMm,\r\n      ];\r\n\r\n      // Build radial histogram (bins) of edge magnitudes per radius for this center\r\n      const maxR = Math.round(Math.min(\r\n        Math.min(cx, w - cx),\r\n        Math.min(cy, h - cy),\r\n      ));\r\n      const bins = new Float32Array(maxR + 1);\r\n      let maxBin = 0;\r\n      for (const edge of edges) {\r\n        const dist = Math.round(Math.hypot(edge.x - cx, edge.y - cy));\r\n        if (dist <= 0 || dist > maxR) continue;\r\n        bins[dist] += edge.mag;\r\n        if (bins[dist] > maxBin) maxBin = bins[dist];\r\n      }\r\n\r\n      // Find significant peaks in histogram\r\n      const peakRadius: number[] = [];\r\n      const peakThreshold = Math.max(12, maxBin * 0.08);\r\n      for (let r = 2; r < maxR - 2; r++) {\r\n        const v = bins[r];\r\n        if (v <= peakThreshold) continue;\r\n        // local maxima\r\n        if (v > bins[r - 1] && v >= bins[r + 1]) {\r\n          peakRadius.push(r);\r\n        }\r\n      }\r\n\r\n      // Match expected radii against peaks\r\n      for (const testR of testRadii) {\r\n        // compute tolerance based on expected radius\r\n        const tol = Math.max(3, Math.round(testR * 0.02));\r\n        // find the peak nearest to testR\r\n        let bestPeak = -1;\r\n        let bestDist = Infinity;\r\n        for (const pr of peakRadius) {\r\n          const d = Math.abs(pr - testR);\r\n          if (d < bestDist) {\r\n            bestDist = d;\r\n            bestPeak = pr;\r\n          }\r\n        }\r\n        if (bestPeak >= 0 && bestDist <= tol) {\r\n          // ring strength is bin magnitude at that peak\r\n          ringCount++;\r\n          ringStrength += bins[bestPeak] || 0;\r\n        }\r\n      }\r\n\r\n      // Want at least 3 strong rings (loosened for small/partial crops)\r\n      if (ringCount >= 3 && ringStrength > bestScore) {\r\n        bestScore = ringStrength;\r\n        bestCenter = { cx, cy };\r\n        bestRingCount = ringCount;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!bestCenter) return null;\r\n\r\n  // Step 3: Refine the center position and find double radius\r\n  const refinedCx = bestCenter.cx;\r\n  const refinedCy = bestCenter.cy;\r\n\r\n  // Find the strongest ring near where we expect the double outer\r\n  // Use an adaptive scan range based on image size\r\n  const approxDoublePixels = Math.min(w, h) * 0.45;\r\n  const minScan = Math.max(6, Math.round(approxDoublePixels * 0.5));\r\n  const maxScan = Math.min(Math.round(Math.max(w, h) - 4), Math.round(approxDoublePixels * 1.5));\r\n  let doubleR = Math.round(approxDoublePixels);\r\n  let maxStrength = 0;\r\n\r\n  for (let testR = minScan; testR <= maxScan; testR += Math.max(2, Math.round((maxScan - minScan) / 60))) {\r\n    let strength = 0;\r\n    let pixelCount = 0;\r\n\r\n    for (const edge of edges) {\r\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\r\n      const tol = Math.max(2, Math.round(testR * 0.01));\r\n      if (Math.abs(dist - testR) < tol) {\r\n        strength += edge.mag;\r\n        pixelCount++;\r\n      }\r\n    }\r\n\r\n    if (pixelCount > Math.max(6, Math.round(minPixelCount * 0.6)) && strength > maxStrength) {\r\n      maxStrength = strength;\r\n      doubleR = testR;\r\n    }\r\n  }\r\n\r\n  // Calculate confidence based on how many proper rings we found\r\n  let confidence = 0;\r\n  const scale = doubleR / BoardRadii.doubleOuter;\r\n\r\n  for (const knownR of [\r\n    BoardRadii.bullInner,\r\n    BoardRadii.bullOuter,\r\n    BoardRadii.trebleInner,\r\n    BoardRadii.trebleOuter,\r\n    BoardRadii.doubleInner,\r\n    BoardRadii.doubleOuter,\r\n  ]) {\r\n    const expectedPixelR = knownR * scale;\r\n    let found = false;\r\n\r\n    for (const edge of edges) {\r\n      const dist = Math.hypot(edge.x - refinedCx, edge.y - refinedCy);\r\n      const tol = Math.max(3, Math.round(expectedPixelR * 0.02));\r\n      if (Math.abs(dist - expectedPixelR) < tol) {\r\n        found = true;\r\n        confidence += 15;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  confidence = Math.min(100, confidence);\r\n\r\n  return {\r\n    cx: refinedCx,\r\n    cy: refinedCy,\r\n    r: doubleR,\r\n    confidence,\r\n    ringCount: bestRingCount,\r\n    ringStrength: Math.round(bestScore),\r\n  };\r\n}\r\n\r\n/**\r\n * Main board detection function\r\n * Uses direct ring detection approach\r\n */\r\nexport function detectBoard(canvas: HTMLCanvasElement): BoardDetectionResult {\r\n  try {\r\n    const w = canvas.width;\r\n    const h = canvas.height;\r\n    const centerX = w / 2;\r\n    const centerY = h / 2;\r\n\r\n    // Find dartboard rings\r\n    const detection = findDartboardRings(canvas);\r\n\r\n    if (!detection) {\r\n      return {\r\n        success: false,\r\n        cx: centerX,\r\n        cy: centerY,\r\n        bullInner: 0,\r\n        bullOuter: 0,\r\n        trebleInner: 0,\r\n        trebleOuter: 0,\r\n        doubleInner: 0,\r\n        doubleOuter: 0,\r\n        confidence: 0,\r\n        homography: null,\r\n        errorPx: null,\r\n        calibrationPoints: [],\r\n        message:\r\n          \"No dartboard detected. Ensure board is clearly visible with good contrast between rings and background.\",\r\n      };\r\n    }\r\n\r\n    // Scale all ring radii based on detected double radius\r\n    const scale = detection.r / BoardRadii.doubleOuter;\r\n\r\n    const detected = {\r\n      cx: detection.cx,\r\n      cy: detection.cy,\r\n      bullInner: BoardRadii.bullInner * scale,\r\n      bullOuter: BoardRadii.bullOuter * scale,\r\n      trebleInner: BoardRadii.trebleInner * scale,\r\n      trebleOuter: BoardRadii.trebleOuter * scale,\r\n      doubleInner: BoardRadii.doubleInner * scale,\r\n      doubleOuter: detection.r,\r\n    };\r\n\r\n    // Generate 4 calibration points from detected rings (TOP, RIGHT, BOTTOM, LEFT of double)\r\n    const calibrationPoints: Point[] = [\r\n      { x: detected.cx, y: detected.cy - detected.doubleOuter }, // TOP\r\n      { x: detected.cx + detected.doubleOuter, y: detected.cy }, // RIGHT\r\n      { x: detected.cx, y: detected.cy + detected.doubleOuter }, // BOTTOM\r\n      { x: detected.cx - detected.doubleOuter, y: detected.cy }, // LEFT\r\n    ];\r\n\r\n    // Compute homography from these 4 points\r\n    const canonicalSrc = [\r\n      { x: 0, y: -BoardRadii.doubleOuter },\r\n      { x: BoardRadii.doubleOuter, y: 0 },\r\n      { x: 0, y: BoardRadii.doubleOuter },\r\n      { x: -BoardRadii.doubleOuter, y: 0 },\r\n    ];\r\n\r\n  let homography: Homography | null = null;\r\n    let errorPx: number | null = null;\r\n    let confidence = detection.confidence;\r\n\r\n    try {\r\n      homography = computeHomographyDLT(canonicalSrc, calibrationPoints);\r\n      errorPx = rmsError(homography, canonicalSrc, calibrationPoints);\r\n      // Adjust confidence based on homography error\r\n      const errorConfidence = Math.max(\r\n        10,\r\n        Math.min(95, 100 - Math.max(0, errorPx - 1) * 10),\r\n      );\r\n      confidence = (confidence + errorConfidence) / 2;\r\n    } catch (err) {\r\n      confidence = Math.max(40, confidence);\r\n    }\r\n\r\n  const pointsValid = calibrationPoints.every(isFinitePoint);\r\n    const homographyValid = isFiniteHomography(homography);\r\n    const success = !!homographyValid && pointsValid && confidence > 50;\r\n  const detRingCount = detection.ringCount ?? 0;\r\n  const detRingStrength = detection.ringStrength ?? 0;\r\n\r\n    return {\r\n      success,\r\n      cx: detected.cx,\r\n      cy: detected.cy,\r\n      bullInner: detected.bullInner,\r\n      bullOuter: detected.bullOuter,\r\n      trebleInner: detected.trebleInner,\r\n      trebleOuter: detected.trebleOuter,\r\n      doubleInner: detected.doubleInner,\r\n      doubleOuter: detected.doubleOuter,\r\n      confidence,\r\n      homography: homographyValid ? homography : null,\r\n      errorPx: homographyValid ? errorPx : null,\r\n      calibrationPoints: pointsValid ? calibrationPoints : [],\r\n      message:\r\n        !pointsValid || !homographyValid\r\n          ? `❌ Detection produced unstable calibration data. Adjust camera framing or calibrate manually. (rings: ${detRingCount}, r:${Math.round(detection.r)})`\r\n          : confidence > 80\r\n          ? `✅ High confidence detection (rings: ${detRingCount}, r:${Math.round(detection.r)})`\r\n          : confidence > 50\r\n          ? `⚠️ Detection found but could be better (rings: ${detRingCount}, r:${Math.round(detection.r)})`\r\n          : `❌ Low confidence - try better lighting (rings: ${detRingCount}, r:${Math.round(detection.r)})`,\r\n    };\r\n  } catch (err) {\r\n    return {\r\n      success: false,\r\n      cx: canvas.width / 2,\r\n      cy: canvas.height / 2,\r\n      bullInner: 0,\r\n      bullOuter: 0,\r\n      trebleInner: 0,\r\n      trebleOuter: 0,\r\n      doubleInner: 0,\r\n      doubleOuter: 0,\r\n      confidence: 0,\r\n      homography: null,\r\n      errorPx: null,\r\n      calibrationPoints: [],\r\n      message: err instanceof Error ? err.message : \"Board detection failed\",\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Refine detection by looking for concentric rings\r\n * This helps match detected circles to specific board rings\r\n */\r\nexport function refineRingDetection(\r\n  detected: BoardDetectionResult,\r\n): BoardDetectionResult {\r\n  // If detection already has good confidence, return as-is\r\n  if (detected.confidence > 70) return detected;\r\n\r\n  // Otherwise try to improve by checking ring ratios\r\n  // If rings don't match expected ratios, we can flag for manual refinement\r\n  const expectedRatios = {\r\n    bullInner_to_bullOuter: BoardRadii.bullInner / BoardRadii.bullOuter,\r\n    bullOuter_to_trebleInner: BoardRadii.bullOuter / BoardRadii.trebleInner,\r\n    trebleOuter_to_doubleInner: BoardRadii.trebleOuter / BoardRadii.doubleInner,\r\n    doubleInner_to_doubleOuter: BoardRadii.doubleInner / BoardRadii.doubleOuter,\r\n  };\r\n\r\n  const actualRatios = {\r\n    bullInner_to_bullOuter: detected.bullInner / detected.bullOuter,\r\n    bullOuter_to_trebleInner: detected.bullOuter / detected.trebleInner,\r\n    trebleOuter_to_doubleInner: detected.trebleOuter / detected.doubleInner,\r\n    doubleInner_to_doubleOuter: detected.doubleInner / detected.doubleOuter,\r\n  };\r\n\r\n  // Check ratio errors\r\n  let ratioError = 0;\r\n  let ratioCount = 0;\r\n  for (const [key, expected] of Object.entries(expectedRatios)) {\r\n    const actual = actualRatios[key as keyof typeof actualRatios];\r\n    const error = Math.abs(actual - expected) / expected;\r\n    ratioError += error;\r\n    ratioCount++;\r\n  }\r\n  const avgRatioError = ratioError / ratioCount;\r\n\r\n  // Adjust confidence based on ratio error\r\n  const adjustedConfidence = Math.max(\r\n    10,\r\n    detected.confidence - avgRatioError * 100,\r\n  );\r\n\r\n  return {\r\n    ...detected,\r\n    confidence: adjustedConfidence,\r\n    message:\r\n      adjustedConfidence > 70\r\n        ? \"✅ High confidence detection\"\r\n        : adjustedConfidence > 50\r\n          ? \"⚠️ Rings detected but ratios off - may need refinement\"\r\n          : \"❌ Low confidence - try repositioning camera\",\r\n  };\r\n}\r\n","import { detectBoard, refineRingDetection } from \"../utils/boardDetection\";\r\n\r\n// Worker receives an ImageBitmap and runs the detection on an OffscreenCanvas.\r\nself.onmessage = async (ev: MessageEvent) => {\r\n  try {\r\n    const { type, bitmap } = ev.data || {};\r\n    if (type !== \"detect\" || !bitmap) return;\r\n    // Create offscreen canvas of same size as bitmap\r\n    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n      postMessage({ error: \"OffscreenCanvas context unavailable\" });\r\n      return;\r\n    }\r\n    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\r\n    // Run detection\r\n    let detection = detectBoard(canvas as any as HTMLCanvasElement);\r\n    detection = refineRingDetection(detection as any);\r\n    // Transfer results back (serializable fields only)\r\n    postMessage({ type: \"result\", detection });\r\n  } catch (err) {\r\n    postMessage({\r\n      error: (err as any)?.message || String(err) || \"Worker error\",\r\n    });\r\n  }\r\n};\r\n\r\nexport {};\r\n"],"names":["BoardRadii","applyHomography","H","p","x","y","w","nx","ny","computeHomographyDLT","src","dst","A","B","k","X","Y","h","solveLeastSquares","b","m","AtA","Atb","r","i","j","gaussianSolve","M","v","n","row","maxRow","tmp","f","c","s","rmsError","e2","dx","dy","isFinitePoint","isFiniteHomography","findDartboardRings","canvas","ctx","data","edges","baseEdgeThreshold","gray","idx","blurred","sum","gx","gy","grayVal","mag","minPixelCount","bestCenter","bestScore","bestRingCount","stride","cy","cx","ringCount","ringStrength","scalePxPerMm","testRadii","maxR","bins","maxBin","edge","dist","peakRadius","peakThreshold","testR","tol","bestPeak","bestDist","pr","d","refinedCx","refinedCy","approxDoublePixels","minScan","maxScan","doubleR","maxStrength","strength","pixelCount","confidence","scale","knownR","expectedPixelR","detectBoard","centerX","centerY","detection","detected","calibrationPoints","canonicalSrc","homography","errorPx","errorConfidence","pointsValid","homographyValid","success","detRingCount","detRingStrength","err","refineRingDetection","expectedRatios","actualRatios","ratioError","ratioCount","key","expected","actual","error","avgRatioError","adjustedConfidence","ev","type","bitmap"],"mappings":"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"}