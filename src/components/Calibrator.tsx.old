import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import DartLoader from "./DartLoader";
import { DartDetector } from "../utils/dartDetector";

import { useCalibration } from "../store/calibration";
import { useCameraSession } from "../store/cameraSession";
import {
  BoardRadii,
  CalibrationGuideRadii,
  canonicalRimTargets,
  computeHomographyDLT,
  drawCross,
  drawPolyline,
  rmsError,
  sampleRing,
  refinePointsSobel,
  applyHomography,
  imageToBoard,
  scoreAtBoardPoint,
  scoreAtBoardPointTheta,
  scaleHomography,
  rotateHomography,
  matMul3,
  SectorOrder,
  estimateSectorOffsetFromHomography,
  type Homography,
  type Point,
} from "../utils/vision";
import {
  detectMarkersFromCanvas,
  MARKER_TARGETS,
  markerIdToMatrix,
  type MarkerDetection,
} from "../utils/markerCalibration";
import {
  detectBoard,
  refineRingDetection,
  type BoardDetectionResult,
} from "../utils/boardDetection";
import { useUserSettings } from "../store/userSettings";
import {
  discoverNetworkDevices,
  connectToNetworkDevice,
  type NetworkDevice,
} from "../utils/networkDevices";
import { apiFetch } from "../utils/api";
import { useMatch } from "../store/match";
import { useWS } from "./WSProvider";

declare const DROPDOWN_DEBUG: boolean | undefined;
const isTestEnv =
  process.env.NODE_ENV === "test" ||
  (typeof import.meta !== "undefined" && import.meta.env?.MODE === "test");

type Phase = "idle" | "camera" | "capture" | "select" | "verify" | "computed";
type CamMode = "local" | "phone" | "wifi";

type DevicePickerProps = {
  videoDevices: Array<{ deviceId: string; label: string }>;
  streaming: boolean;
  refreshVideoDevices: () => Promise<void>;
  testCamera: (deviceId?: string) => Promise<void>;
  onSelectPhoneCamera: () => void;
  lastDetectedLabel: string | null;
  autoCommitTestMode: boolean;
  doCommit: () => void;
  lastDetectedValue: number | null;
  calibrationValid: boolean;
  sectorOffset: number | null;
  onNudgeSectorOffset: (delta: number) => void;
  onResetSectorOffset: () => void;
};

const DevicePicker: React.FC<DevicePickerProps> = ({
  videoDevices,
  streaming,
  refreshVideoDevices,
  testCamera,
  onSelectPhoneCamera,
  lastDetectedLabel,
  autoCommitTestMode,
  doCommit,
  lastDetectedValue,
  calibrationValid,
  sectorOffset,
  onNudgeSectorOffset,
  onResetSectorOffset,
}) => {
  const {
    preferredCameraId,
    preferredCameraLabel,
    setPreferredCamera,
    cameraEnabled,
    setCameraEnabled,
    preferredCameraLocked,
    setPreferredCameraLocked,
  } = useUserSettings();

  const [err, setErr] = useState<string>("");
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement | null>(null);

  const handleRefreshDevices = useCallback(async () => {
    setErr("");
    try {
      await refreshVideoDevices();
    } catch (e) {
      console.warn("[DevicePicker] refresh failed", e);
      setErr("Unable to list cameras. Grant camera permission in your browser.");
    }
  }, [refreshVideoDevices]);

  useEffect(() => {
    if (isTestEnv) return;
    void handleRefreshDevices();
  }, [handleRefreshDevices]);

  useEffect(() => {
    if (!dropdownOpen) return;
    function handleClickOutside(event: MouseEvent) {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        console.debug('[DevicePicker] document.mousedown -> closing dropdown (outside both main+portal)', Date.now());
        setDropdownOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [dropdownOpen]);

  const selectedDevice = videoDevices.find(
    (d) => d.deviceId === preferredCameraId,
  );
  const selectedLabel = selectedDevice
    ? `${selectedDevice.label || "Camera"}`
    : preferredCameraId
      ? "Camera (unavailable)"
      : "Auto (browser default)";
  const preferredCameraUnavailable = Boolean(
    preferredCameraId && !selectedDevice,
  );

  const handleSelectCamera = useCallback(
    (deviceId: string | undefined, label = "") => {
      try {
        setPreferredCamera(deviceId, label, true);
      } catch (err) {
        console.warn("[DevicePicker] setPreferredCamera failed", err);
      }
      setDropdownOpen(false);
    },
    [setPreferredCamera],
  );

  const handlePhoneCamera = useCallback(() => {
    handleSelectCamera(undefined, "Phone Camera");
    onSelectPhoneCamera();
  }, [handleSelectCamera, onSelectPhoneCamera]);

  const handleLockToggle = useCallback(() => {
    setPreferredCameraLocked(!preferredCameraLocked);
  }, [preferredCameraLocked, setPreferredCameraLocked]);

  return (
    <div
      ref={dropdownRef}
      className="mt-3 rounded-lg border border-indigo-500/30 bg-indigo-500/5 p-3"
      data-testid="device-picker-root"
    >
      <div className="mb-2 font-semibold">Select camera device</div>
      {err && <div className="mb-2 text-sm text-rose-400">{err}</div>}
      {videoDevices.length === 0 && !err && (
        <div className="mb-2 text-xs text-slate-400">
          Detecting devices... (click "Rescan" if this hangs)
        </div>
      )}
      {preferredCameraUnavailable && (
        <div className="mb-2 text-sm text-amber-400">
          Selected camera is no longer available.
          <button
            className="ml-1 underline"
            onClick={() => handleSelectCamera(undefined, "")}
            disabled={streaming}
          >
            Use auto-selection
          </button>
        </div>
      )}
      <div className="mb-2 flex items-center gap-2">
        {preferredCameraLocked ? (
          <div className="text-xs text-emerald-400">ðŸ”’ Camera selection locked</div>
        ) : (
          <div className="text-xs text-slate-400">Camera selection unlocked</div>
        )}
        <button
          data-testid="cam-lock-toggle"
          className="btn btn--ghost ml-2 px-2 py-0.5 text-xs"
          onClick={handleLockToggle}
        >
          {preferredCameraLocked ? "Unlock" : "Lock"}
        </button>
      </div>
      <div className="mb-3 flex items-center gap-3">
        <input
          type="checkbox"
          id="cameraEnabled-calibrator"
          checked={cameraEnabled}
          onChange={(e) => setCameraEnabled(e.target.checked)}
          className="h-4 w-4"
          disabled={streaming}
        />
        <label htmlFor="cameraEnabled-calibrator" className="text-sm">
          Enable camera for scoring
        </label>
      </div>
      <div className="grid grid-cols-3 items-center gap-2 text-sm">
        <div className="relative col-span-2">
          <button
            className="input flex w-full items-center justify-between text-left"
            data-testid="device-picker-toggle"
            onClick={() => setDropdownOpen(true)}
            onPointerDown={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <span>{selectedLabel}</span>
            <span
              className={`transition-transform ${
                dropdownOpen ? "rotate-180" : ""
              }`}
            >
              â–¼
            </span>
          </button>
          {dropdownOpen && (
            <div className="absolute left-0 right-0 top-full z-50 mt-1 rounded border border-slate-600 bg-slate-800 shadow-lg">
              <div className="max-h-48 overflow-y-auto">
                <button
                  data-testid="device-option-auto"
                  className="w-full px-3 py-2 text-left text-sm hover:bg-slate-700"
                  onClick={() => handleSelectCamera(undefined, "")}
                  onPointerDown={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  Auto (browser default)
                </button>
                {videoDevices.map((device) => (
                  <button
                    key={device.deviceId}
                    className="w-full px-3 py-2 text-left text-sm hover:bg-slate-700"
                    onClick={() =>
                      handleSelectCamera(device.deviceId, device.label || "")
                    }
                    onPointerDown={(e) => e.stopPropagation()}
                    onMouseDown={(e) => e.stopPropagation()}
                  >
                    {device.label || "Camera"}
                  </button>
                ))}
                <button
                  className="w-full px-3 py-2 text-left text-sm hover:bg-slate-700"
                  onClick={handlePhoneCamera}
                  onPointerDown={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  ðŸ“± Phone Camera
                </button>
              </div>
            </div>
          )}
        </div>
        {videoDevices.length === 0 && (
          <div className="col-span-1 flex items-center justify-end gap-2">
            <button
              className="btn btn--ghost btn-sm"
              onClick={async () => {
                try {
                  await testCamera();
                  await refreshVideoDevices();
                } catch (err) {
                  console.warn("[DevicePicker] request camera permission failed", err);
                  setErr("Camera permission denied. Please allow access in your browser.");
                }
              }}
            >
              Enable local camera
            </button>
            <button
              className="btn btn--ghost btn-sm"
              onClick={() => void handleRefreshDevices()}
            >
              Rescan
            </button>
          </div>
        )}
        <div className="col-span-3 text-right">
          <button
            className="btn px-2 py-1"
            onClick={() => {
              void testCamera(preferredCameraId || undefined);
            }}
            disabled={streaming}
          >
            Test
          </button>
          <div className="mt-2 flex items-center justify-end gap-2 text-xs">
            <span>Sector offset: {sectorOffset ?? 0}</span>
            <button className="btn btn--ghost btn-sm" onClick={() => onNudgeSectorOffset(-1)}>-1</button>
            <button className="btn btn--ghost btn-sm" onClick={() => onNudgeSectorOffset(+1)}>+1</button>
            <button className="btn btn--ghost btn-sm" onClick={() => onResetSectorOffset()}>Reset</button>
          </div>
          <div className="mt-2 flex items-center justify-end gap-2 text-xs opacity-70">
            <span data-testid="device-picker-detected">
              {lastDetectedLabel ? `Detected: ${lastDetectedLabel}` : "No recent detection"}
            </span>
            {(lastDetectedLabel != null || autoCommitTestMode) && (
              <button
                className="btn btn--ghost btn-sm"
                onClick={() => doCommit()}
                onPointerDown={() => doCommit()}
                disabled={lastDetectedValue == null}
              >
                Commit detected
              </button>
            )}
            <span
              className={`inline-block h-2.5 w-2.5 rounded-full ${
                calibrationValid ? "bg-emerald-400" : "bg-rose-500"
              }`}
            />
            <span className="text-xs">
              {calibrationValid ? "Cal OK" : "Cal invalid"}
            </span>
          </div>
        </div>
      </div>
      {preferredCameraLabel && (
        <div className="mt-1 text-xs opacity-70">
          Selected: {preferredCameraLabel}
        </div>
      )}
      <div className="mt-1 text-xs opacity-70">
        Tip: All camera technology is supported for autoscoring needsâ€”select your camera here and then open Calibrator to align.
      </div>
    </div>
  );
};

const CALIBRATION_POINT_LABELS = ["D20", "D6", "D3", "D11", "BULL"] as const;
const REQUIRED_POINT_COUNT = CALIBRATION_POINT_LABELS.length;
type TestAutoDetectResult = {
  H: Homography;
  errorPx: number | null;
  imageSize: { w: number; h: number };
  overlaySize: { w: number; h: number };
  anchors: { src: Point[]; dst: Point[] };
  locked: boolean;
  confidence: number;
  phase?: Phase;
};

type ScoreInfo = ReturnType<typeof scoreAtBoardPoint>;

type VerificationResult = {
  label: string;
  expected: { ring: ScoreInfo["ring"]; sector: number | null };
  detected: ScoreInfo | null;
  deltaMm: number | null;
  deltaPx: number | null;
  match: boolean;
  note?: string;
};

const VERIFICATION_ANCHORS: Array<{
  idx: number;
  label: string;
  sector: number | null;
  ring: ScoreInfo["ring"];
  toleranceMm: number;
}> = [
  { idx: 0, label: "D20 (top double)", sector: 20, ring: "DOUBLE", toleranceMm: 4.5 },
  { idx: 1, label: "D6 (right double)", sector: 6, ring: "DOUBLE", toleranceMm: 4.5 },
  { idx: 2, label: "D3 (bottom double)", sector: 3, ring: "DOUBLE", toleranceMm: 4.5 },
  { idx: 3, label: "D11 (left double)", sector: 11, ring: "DOUBLE", toleranceMm: 4.5 },
  { idx: 4, label: "Bull center", sector: 25, ring: "INNER_BULL", toleranceMm: 3.5 },
];

function describeScoreTarget(ring: ScoreInfo["ring"], sector: number | null) {
  if (ring === "INNER_BULL") return "Inner Bull (50)";
  if (ring === "BULL") return "Outer Bull (25)";
  if (ring === "MISS" || sector == null) return ring === "MISS" ? "Miss" : ring;
  const prefix = ring === "DOUBLE" ? "Double" : ring === "TRIPLE" ? "Triple" : "Single";
  return `${prefix} ${sector}`;
}

function formatScoreLabel(score: ScoreInfo | null) {
  return score ? describeScoreTarget(score.ring, score.sector) : "â€”";
}

function translateHomography(H: Homography, tx: number, ty: number): Homography {
  // Compose translation matrix T = [1 0 tx; 0 1 ty; 0 0 1]
  const T: Homography = [1, 0, tx, 0, 1, ty, 0, 0, 1];
  return matMul3(H, T); // H * T - apply translation after main transform
}

// Center-logo QR helpers moved to ../utils/qr

export default function Calibrator() {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const overlayRef = useRef<HTMLCanvasElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  // Camera diagnostics state
  const [cameraPerm, setCameraPerm] = useState<
    "unknown" | "granted" | "denied" | "prompt" | "unsupported"
  >("unknown");
  const [videoDevices, setVideoDevices] = useState<
    Array<{ deviceId: string; label: string }>
  >([]);
  const [selectedDeviceId, setSelectedDeviceId] = useState<string | null>(null);
  const [streaming, setStreaming] = useState(false);
  const [videoPlayBlocked, setVideoPlayBlocked] = useState(false);
  // Default to local or last-used mode, but allow user to freely change
  const [mode, setMode] = useState<CamMode>(
    () => (localStorage.getItem("ndn:cal:mode") as CamMode) || "local",
  );
  const [dstPoints, setDstPoints] = useState<Point[]>([]); // image points clicked in order D20 (top), D6 (right), D3 (bottom), D11 (left)
  const [hasSnapshot, setHasSnapshot] = useState(false);
  const [phase, setPhase] = useState<Phase>("idle");
  const handleSelectPhoneCamera = useCallback(() => {
    setMode("phone");
    setPhase("camera");
    setStreaming(false);
    setHasSnapshot(false);
    // Persist phone camera selection globally so it is used in game modes
    try {
      useUserSettings.getState().setPreferredCamera(undefined, "Phone Camera", true);
    } catch (e) {
      console.warn("[Calibrator] Failed to persist phone camera selection", e);
    }
  }, [setMode, setPhase, setStreaming, setHasSnapshot]);
  // Track current frame (video/snapshot) size to preserve aspect ratio in the preview container
  const [frameSize, setFrameSize] = useState<{ w: number; h: number } | null>(
    null,
  );
  // Zoom for pixel-perfect point picking (0.5x â€“ 2.0x)
  // const [zoom, setZoom] = useState<number>(1);
  // Use global camera scale setting so it persists across game modes
  const zoom = useUserSettings((s) => s.cameraScale) || 1;
  const setZoom = useUserSettings((s) => s.setCameraScale);
  const [mobileLandingOverride, setMobileLandingOverride] = useState<boolean>(
    () => {
      if (typeof window === "undefined") return false;
      try {
        return window.localStorage.getItem("ndn:cal:forceDesktop") === "1";
      } catch {
        return false;
      }
    },
  );
  const [isMobileDevice, setIsMobileDevice] = useState<boolean>(() => {
    if (typeof navigator === "undefined") return false;
    return /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
  });
  const { H, setCalibration, reset, errorPx, locked, overlaySize, imageSize, anchors, theta, sectorOffset } = useCalibration();
  const ERROR_PX_MAX = 6;
  const calibrationValid = !!H && !!imageSize && (locked || (typeof errorPx === 'number' && errorPx <= ERROR_PX_MAX));
  const cameraSession = useCameraSession();
  const {
    calibrationGuide,
    setCalibrationGuide,
    preferredCameraId,
    cameraEnabled,
    setCameraEnabled,
    preferredCameraLocked,
    setPreferredCameraLocked,
    setPreferredCamera,
    preserveCalibrationOverlay,
  allowAutocommitInOnline,
  setAllowAutocommitInOnline,
  } = useUserSettings();
  // Detected ring data (from auto-detect) in image pixels
  const [detected, setDetected] = useState<null | {
    cx: number;
    cy: number;
    bullInner: number;
    bullOuter: number;
    trebleInner: number;
    trebleOuter: number;
    doubleInner: number;
    doubleOuter: number;
  }>(null);
  // Live detection and confidence state
  const [liveDetect, setLiveDetect] = useState<boolean>(false);
  const [confidence, setConfidence] = useState<number>(0);
  const [autoCalibrating, setAutoCalibrating] = useState<boolean>(false);
  const [detectionMessage, setDetectionMessage] = useState<string | null>(null);
  const [forceConfidence, setForceConfidence] = useState<boolean>(true); // Allow forcing 100% for registration reliability
  const [markerResult, setMarkerResult] = useState<MarkerDetection | null>(
    null,
  );
  const [showDartPreview, setShowDartPreview] = useState<boolean>(false);
  const [autoCommitTestMode, setAutoCommitTestMode] = useState<boolean>(false);
  const [autoCommitImmediate, setAutoCommitImmediate] = useState<boolean>(false);
  const [lastDetectedValue, setLastDetectedValue] = useState<number | null>(null);
  const [lastDetectedLabel, setLastDetectedLabel] = useState<string | null>(null);
  // Optional hint: a one-click bull can anchor the center for auto-calibration
  const [bullHint, setBullHint] = useState<Point | null>(null);
  const [toolsPopoverOpen, setToolsPopoverOpen] = useState<boolean>(false);
  const dartDetectorRef = useRef<DartDetector | null>(null);

  // Simple nudge controls for sector offset to resolve whole-sector mismatches quickly
  const nudgeSectorOffset = useCallback((delta: number) => {
    const next = ((sectorOffset ?? 0) + delta);
    setCalibration({ sectorOffset: next });
  }, [sectorOffset, setCalibration]);
  const inFlightAutoCommitRef = useRef<boolean>(false);
  const lastAutoSigRef = useRef<string | null>(null);
  const lastAutoSigAtRef = useRef<number>(0);
  const AUTO_COMMIT_COOLDOWN_MS = 300;
  // Verification results for UI: {label, expected, detected, match}
  const [verificationResults, setVerificationResults] =
    useState<VerificationResult[]>([]);
  // PASS/FAIL flash badge state
  const [flashStatus, setFlashStatus] = useState<{
    type: 'pass' | 'fail' | null;
    until: number;
  }>({ type: null, until: 0 });

  // Fine-tune correction parameters for pixel-perfect alignment
  const [correctionSx, setCorrectionSx] = useState<number>(1.0);
  const [correctionTx, setCorrectionTx] = useState<number>(0);
  const [correctionTy, setCorrectionTy] = useState<number>(0);
  // Debug overlay for detected rings
  const [showDetectedOverlay, setShowDetectedOverlay] = useState<boolean>(false);
  const [forceDetectedOnly, setForceDetectedOnly] = useState<boolean>(false);
  const [doubleOuterAdjust, setDoubleOuterAdjust] = useState<number>(1.0);
  const [trebleOuterAdjust, setTrebleOuterAdjust] = useState<number>(1.0);
  const [aligningRing, setAligningRing] = useState<null | 'double' | 'treble' | 'bull'>(null);
  function resetVisualAdjustments() {
    setDoubleOuterAdjust(1.02);
    setTrebleOuterAdjust(1.0);
    setCorrectionSx(1.0);
    setCorrectionTx(0);
    setCorrectionTy(0);
    setForceDetectedOnly(false);
    setAligningRing(null);
  }

  function triggerFlash(pass: boolean, durationMs = 1500) {
    setFlashStatus({ type: pass ? 'pass' : 'fail', until: Date.now() + durationMs });
  }

  const createMarkerDataUrl = useCallback((id: number, size = 480) => {
    if (typeof document === "undefined")
      throw new Error("Marker rendering only available in browser context");
    const matrix = markerIdToMatrix(id);
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    if (!ctx) return "";
    // white background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, size, size);

    const rows = matrix.length;
    const cols = matrix[0]?.length || rows;
    const cellW = size / cols;
    const cellH = size / rows;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const v = matrix[y][x];
        if (v) {
          ctx.fillStyle = "#000000";
          ctx.fillRect(
            Math.round(x * cellW),
            Math.round(y * cellH),
            Math.ceil(cellW),
            Math.ceil(cellH),
          );
        }
      }
    }

    return canvas.toDataURL("image/png");
  }, []);
  // Pairing / phone-camera state (some of these were accidentally removed during edits)
  const [pairCode, setPairCode] = useState<string | null>(null);
  const pairCodeRef = useRef<string | null>(null);
  const [ws, setWs] = useState<WebSocket | null>(null);
  const pcRef = useRef<RTCPeerConnection | null>(null);
  const pendingIceCandidatesRef = useRef<RTCIceCandidate[]>([]);
  const [expiresAt, setExpiresAt] = useState<number | null>(null);
  const [now, setNow] = useState<number>(Date.now());
  const [paired, setPaired] = useState<boolean>(false);

  function updatePairCode(code: string | null) {
    try {
      setPairCode(code);
      pairCodeRef.current = code;
  } catch (e) {}
  }
  const [lanHost, setLanHost] = useState<string | null>(null);
  const [httpsInfo, setHttpsInfo] = useState<{
    https: boolean;
    port: number;
  } | null>(null);
  const [showTips, setShowTips] = useState<boolean>(true);
  const [wifiDevices, setWifiDevices] = useState<NetworkDevice[]>([]);
  const [discoveringWifi, setDiscoveringWifi] = useState<boolean>(false);
  const [copyFeedback, setCopyFeedback] = useState<"link" | "code" | null>(
    null,
  );
  const copyTimeoutRef = useRef<number | null>(null);

  // Log streaming state changes for debugging
  useEffect(() => {
    if (isTestEnv) return;
    let interval: number | null = null;
    if (showDartPreview && streaming && videoRef.current && overlayRef.current) {
      // Initialize detector
      try {
        const video = videoRef.current! as HTMLVideoElement;
        const det = new DartDetector({ requireStableN: 2, thresh: 18, minArea: 40 });
        const w = video.videoWidth || (videoRef.current as any).clientWidth || 640;
        const h = video.videoHeight || (videoRef.current as any).clientHeight || 480;
        det.reset(w, h);
        // Set ROI roughly to the full board if we have detection
        if (detected) {
          const r = Math.max(detected.doubleOuter * 1.1, detected.trebleOuter * 1.1);
          det.setROI(detected.cx, detected.cy, Math.round(r));
        }
        dartDetectorRef.current = det;
        interval = window.setInterval(() => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.drawImage(video, 0, 0, w, h);
            const img = ctx.getImageData(0, 0, w, h);
            // feed background model
            det.updateBackground(img);
            const d = det.detect(img);
            const overlay = overlayRef.current! as HTMLCanvasElement;
            const octx = overlay.getContext('2d');
            if (!octx) return;
            octx.clearRect(0, 0, overlay.width, overlay.height);
            // overlay is same size as canvas/image
            if (d) {
              try {
                // Map to calibration space and extract score
                if (H && imageSize) {
                  const pImg = { x: d.tip.x, y: d.tip.y };
                  // convert canvas coords to calibration image space
                  const fallbackWidth = (overlayRef.current && overlayRef.current.width) || imageSize.w || 1;
                  const fallbackHeight = (overlayRef.current && overlayRef.current.height) || imageSize.h || 1;
                  const pCal = { x: pImg.x / ((fallbackWidth) / imageSize.w), y: pImg.y / ((fallbackHeight) / imageSize.h) };
                  const detectedBoard = imageToBoard(H as any, pCal);
                  const scoreObj = detectedBoard
                    ? scoreAtBoardPointTheta(detectedBoard, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0)
                    : { base: 0, ring: "MISS" as const, sector: null, mult: 0 as const };
                  const val = scoreObj.base;
                  const label = `${scoreObj.ring} ${val}`.trim();
                  const ERROR_PX_MAX = 6;
                  const TIP_MARGIN_PX = 3;
                  const PCAL_MARGIN_PX = 3;
                  const calibrationGood = !!H && !!imageSize && (locked || (typeof errorPx === "number" && errorPx <= ERROR_PX_MAX));
                  const tipInVideo = d.tip.x >= -TIP_MARGIN_PX && d.tip.x <= fallbackWidth + TIP_MARGIN_PX && d.tip.y >= -TIP_MARGIN_PX && d.tip.y <= fallbackHeight + TIP_MARGIN_PX;
                  const pCalInImage = pCal.x >= -PCAL_MARGIN_PX && pCal.x <= imageSize.w + PCAL_MARGIN_PX && pCal.y >= -PCAL_MARGIN_PX && pCal.y <= imageSize.h + PCAL_MARGIN_PX;
                  let onBoard = false;
                  const pBoard = imageToBoard(H as any, pCal);
                  if (pBoard) {
                    const boardR = Math.hypot(pBoard.x, pBoard.y);
                    const BOARD_MARGIN_MM = 3;
                    onBoard = boardR <= BoardRadii.doubleOuter + BOARD_MARGIN_MM;
                  }
                  if (!calibrationGood || !tipInVideo || !pCalInImage || !onBoard) {
                    // ignore ghost detection
                    console.debug("Calibrator: ignoring ghost preview detection", calibrationGood, tipInVideo, pCalInImage);
                  } else {
                    setLastDetectedValue(val);
                    setLastDetectedLabel(label);
                    try {
                      if (autoCommitTestMode && autoCommitImmediate && useMatch.getState().inProgress && useMatch.getState().roomId === "") {
                        // commit as offline match visit (3 darts) with dedupe/cooldown to avoid double commits
                        const sig = `${val}|3`;
                        const now = performance.now();
                        if (!inFlightAutoCommitRef.current && !(sig === lastAutoSigRef.current && now - lastAutoSigAtRef.current < AUTO_COMMIT_COOLDOWN_MS)) {
                          lastAutoSigRef.current = sig;
                          lastAutoSigAtRef.current = now;
                          inFlightAutoCommitRef.current = true;
                          try { useMatch.getState().addVisit(val, 3, { visitTotal: val }); } catch (e) {}
                          try { window.setTimeout(() => { inFlightAutoCommitRef.current = false; }, Math.max(120, AUTO_COMMIT_COOLDOWN_MS)); } catch (e) {}
                        }
                      }
                    } catch (e) {
                      // ignore commit errors in preview
                    }
                    // For online autocommit in test mode, send the message if allowed
                    try {
                      const isOnline = useMatch.getState().roomId !== "";
                      if (autoCommitTestMode && autoCommitImmediate && useMatch.getState().inProgress && isOnline && allowAutocommitInOnline) {
                        const pBoard = imageToBoard(H as any, pCal);
                        if (pBoard) {
                          useWS().send({ type: 'auto-visit', roomId: useMatch.getState().roomId, value: val, darts: 3, ring: scoreObj.ring, sector: scoreObj.sector, pBoard, calibrationValid: true });
                        }
                      }
                    } catch (e) {
                      // ignore online commit errors in preview
                    }
                  }
                }
              } catch (err) {
                // ignore detection mapping errors
              }
              octx.fillStyle = 'rgba(0,255,0,0.9)';
              octx.beginPath();
              octx.arc(d.tip.x, d.tip.y, 6, 0, Math.PI * 2);
              octx.fill();
              // draw axis
              octx.strokeStyle = 'rgba(0,255,0,0.8)';
              octx.lineWidth = 2;
              if (d.axis) {
                octx.beginPath();
                octx.moveTo(d.axis.x1, d.axis.y1);
                octx.lineTo(d.axis.x2, d.axis.y2);
                octx.stroke();
              }
            }
          } catch (err) {
            // ignore animation errors
          }
        }, 300);
      } catch (err) {
        console.warn('[Calibrator] failed to start dart preview', err);
      }
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
      dartDetectorRef.current = null;
    };
  }, [showDartPreview, streaming, detected]);

  useEffect(() => {
    if (isTestEnv) return;
    const h = window.location.hostname;
    if (h === "localhost" || h === "127.0.0.1") {
      apiFetch(`/api/hosts`)
        .then((r) => r.json())
        .then((j) => {
          const ip = Array.isArray(j?.hosts) && j.hosts.find((x: string) => x);
          if (ip) setLanHost(ip);
        })
        .catch(() => {});
    }
    // Try to detect if server exposes HTTPS info
    apiFetch(`/api/https-info`)
      .then((r) => r.json())
      .then((j) => {
        if (j && typeof j.https === "boolean")
          setHttpsInfo({ https: !!j.https, port: Number(j.port) || 8788 });
      })
      .catch(() => {});
  }, []);

  // Remove automatic phone pairing on mode change; only pair on explicit user action
  const mobileUrl = useMemo(() => {
    const code = pairCode || "____";
    // Prefer configured WS host (Render) when available to build the correct server origin
    const envUrl = (import.meta as any).env?.VITE_WS_URL as string | undefined;
    if (envUrl && envUrl.length > 0) {
      try {
        const u = new URL(envUrl);
        const isSecure = u.protocol === "wss:";
        const origin = `${isSecure ? "https" : "http"}://${u.host}${u.pathname.endsWith("/ws") ? "" : u.pathname}`;
        const base = origin.replace(/\/?ws$/i, "");
        return `${base}/mobile-cam.html?code=${code}`;
                    } catch (e) {}
    }
    // Local dev fallback using detected LAN or current host
    const host = lanHost || window.location.hostname;
    const useHttps = !!httpsInfo?.https;
    const port = useHttps ? httpsInfo?.port || 8788 : 8787;
    const proto = useHttps ? "https" : "http";
    return `${proto}://${host}:${port}/mobile-cam.html?code=${code}`;
  }, [pairCode, lanHost, httpsInfo]);

  const mobileLandingLink = useMemo(() => {
    if (!mobileUrl) return null;
    try {
      const url = new URL(mobileUrl);
      url.searchParams.delete("code");
      return url.toString().replace(/\?$/, "");
    } catch {
      if (typeof window !== "undefined") {
        const origin = window.location.origin.replace(/\/$/, "");
        return `${origin}/mobile-cam.html`;
      }
      return "/mobile-cam.html";
    }
  }, [mobileUrl]);

  useEffect(() => {
    localStorage.setItem("ndn:cal:mode", mode);
  }, [mode]);

  useEffect(() => {
    if (typeof window === "undefined") return;
    try {
      if (mobileLandingOverride) {
        window.localStorage.setItem("ndn:cal:forceDesktop", "1");
      } else {
        window.localStorage.removeItem("ndn:cal:forceDesktop");
      }
  } catch (e) {}
  }, [mobileLandingOverride]);

  useEffect(() => {
    if (isTestEnv || typeof window === "undefined") return;
    const coarseQuery = window.matchMedia("(pointer: coarse)");
    const detect = () => {
      const uaMobile =
        typeof navigator !== "undefined" &&
        /Android|iPhone|iPad|iPod|Mobi/i.test(navigator.userAgent);
      const coarse =
        typeof coarseQuery.matches === "boolean" ? coarseQuery.matches : false;
      const narrow = window.innerWidth <= 820;
      setIsMobileDevice(uaMobile || coarse || narrow);
    };
    detect();
    try {
      if (typeof coarseQuery.addEventListener === "function")
        coarseQuery.addEventListener("change", detect);
      else if (typeof coarseQuery.addListener === "function")
        coarseQuery.addListener(detect);
  } catch (e) {}
    window.addEventListener("resize", detect);
    return () => {
      try {
        if (typeof coarseQuery.removeEventListener === "function")
          coarseQuery.removeEventListener("change", detect);
        else if (typeof coarseQuery.removeListener === "function")
          coarseQuery.removeListener(detect);
  } catch (e) {}
      window.removeEventListener("resize", detect);
    };
  }, []);

  // Detect camera permission status where supported
  useEffect(() => {
    if (isTestEnv) return;
    if (typeof navigator === "undefined" || !(navigator as any).permissions) {
      setCameraPerm("unsupported");
      return;
    }
    let mounted = true;
    (async () => {
      try {
        const p = await (navigator as any).permissions.query({
          name: "camera",
        });
        if (!mounted) return;
        setCameraPerm(p.state || "unknown");
        p.onchange = () => {
          if (mounted) setCameraPerm(p.state);
        };
      } catch (err) {
        // Some browsers don't support 'camera' permission query
        if (mounted) setCameraPerm("unknown");
      }
    })();
    return () => {
      mounted = false;
    };
  }, []);

  async function refreshVideoDevices() {
    if (
      typeof navigator === "undefined" ||
      !navigator.mediaDevices ||
      !navigator.mediaDevices.enumerateDevices
    )
      return;
    try {
      const list = await navigator.mediaDevices.enumerateDevices();
      const vids = list
        .filter((d) => d.kind === "videoinput")
        .map((d) => ({
          deviceId: (d as any).deviceId,
          label: d.label || "Camera",
        }));
      setVideoDevices(vids);
      if (vids.length && !selectedDeviceId)
        setSelectedDeviceId(vids[0].deviceId);
    } catch (err) {
      // ignore
    }
  }

  useEffect(() => {
    if (isTestEnv) return;
    let mounted = true;
    (async () => {
      try {
        await refreshVideoDevices();
  } catch (e) {}
      try {
        if (navigator?.mediaDevices?.addEventListener) {
          navigator.mediaDevices.addEventListener('devicechange', refreshVideoDevices);
        } else {
          (navigator.mediaDevices as any).ondevicechange = refreshVideoDevices;
        }
  } catch (e) {}
    })();
    return () => {
      try {
        if (navigator?.mediaDevices?.removeEventListener)
          navigator.mediaDevices.removeEventListener('devicechange', refreshVideoDevices);
                    } catch (e) {}
    };
  }, []);

  async function testCamera(deviceId?: string) {
    if (
      typeof navigator === "undefined" ||
      !navigator.mediaDevices ||
      !navigator.mediaDevices.getUserMedia
    ) {
      alert("getUserMedia is not available in this browser");
      return;
    }
    const constraints: any = {
      video: deviceId
        ? { deviceId: { exact: deviceId } }
        : { facingMode: "environment" },
    };
    let stream: MediaStream | null = null;
    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      // Immediately stop tracks to test access
      stream.getTracks().forEach((t) => t.stop());
      setCameraPerm("granted");
      // If a deviceId was provided, set it as the preferred camera so Start Camera will use it
      try {
        if (deviceId && typeof setPreferredCamera === "function") {
          setPreferredCamera(deviceId);
        }
      } catch {}
      alert(
        "Camera access granted â€” your webcam is available and set as preferred.",
      );
    } catch (err: any) {
      console.error("[Calibrator] testCamera failed", err);
      if (
        err &&
        (err.name === "NotAllowedError" || err.name === "PermissionDeniedError")
      ) {
        setCameraPerm("denied");
        alert(
          "Camera permission denied. Please allow camera access in your browser settings and try again.",
        );
      } else if (
        err &&
        (err.name === "NotFoundError" || err.name === "DevicesNotFoundError")
      ) {
        alert(
          "No camera devices found. Ensure your USB webcam is connected and not in use by another app.",
        );
      } else {
        alert("Unable to access the camera: " + (err?.message || err));
      }
    } finally {
      if (stream) stream.getTracks().forEach((t) => t.stop());
    }
  }

  function openBrowserSiteSettings() {
    if (typeof window === "undefined") return;
    const ua = navigator.userAgent || "";
    let url: string | null = null;
    if (/Edg\//.test(ua) || /Chrome\//.test(ua) || /Chromium\//.test(ua)) {
      // Chromium-based browsers: open camera content settings
      url = "chrome://settings/content/camera";
    } else if (/Firefox\//.test(ua)) {
      url = "about:preferences#privacy";
    } else if (/Safari\//.test(ua) && !/Chrome\//.test(ua)) {
      // Safari has no direct site settings page we can open; show instructions instead
      url = null;
    }
    if (url) {
      const w = window.open(url, "_blank");
      if (!w) {
        alert(
          'Unable to open browser settings automatically. Please open your browser settings and search for "Camera" permissions for this site.',
        );
      }
    } else {
      // Fallback instructions
      alert(
        "Please open your browser settings and locate Site Settings â†’ Camera (or Permissions) and allow camera access for this site. In Safari, use Preferences â†’ Websites â†’ Camera.",
      );
    }
  }

  useEffect(() => {
    if (isTestEnv || !expiresAt) return;
    const t = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(t);
  }, [expiresAt]);
  const ttl = useMemo(
    () => (expiresAt ? Math.max(0, Math.ceil((expiresAt - now) / 1000)) : null),
    [expiresAt, now],
  );
  useEffect(() => {
    return () => {
      if (copyTimeoutRef.current) window.clearTimeout(copyTimeoutRef.current);
    };
  }, []);

  const copyValue = useCallback(
    async (value: string | null | undefined, type: "link" | "code") => {
      if (!value) return;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(value);
        } else {
          const textarea = document.createElement("textarea");
          textarea.value = value;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          document.execCommand("copy");
          try {
            document.body.removeChild(textarea);
          } catch {
            // If removal fails, element was already removed
          }
        }
        setCopyFeedback(type);
        if (copyTimeoutRef.current) window.clearTimeout(copyTimeoutRef.current);
        copyTimeoutRef.current = window.setTimeout(
          () => setCopyFeedback(null),
          1500,
        );
      } catch (err) {
        console.warn("[Calibrator] Copy failed:", err);
        setCopyFeedback(null);
      }
    },
    [],
  );
  // Removed automatic regeneration of code when ttl expires. Only regenerate on explicit user action.

  // NOTE: Removed automatic permission request on load - it was blocking camera access
  // Let startCamera() handle the permission request when user clicks "Enable camera"
  // This prevents the camera from being held by the permission test

  useEffect(() => {
    return () => {
      // DON'T call stopCamera() on unmount - we want phone camera to persist!
      // Just clean up local refs
      // The camera stream stays alive so user can see it in Online/Offline/Tournaments
    };
  }, []); // Remove automatic camera restart on preferredCameraId change to prevent flicker

  // Listen for reconnect requests from PhoneCameraOverlay
  useEffect(() => {
    if (isTestEnv) return;
    const handleReconnectRequest = (event: any) => {
      console.log(
        "[Calibrator] Received reconnect request from PhoneCameraOverlay",
      );
      // If we're in phone mode and already paired, restart the pairing
      if (mode === "phone" && paired) {
        stopCamera(false);
        // Give a moment for cleanup, then restart pairing
        setTimeout(() => {
          startPhonePairing();
        }, 500);
      }
    };

    window.addEventListener(
      "ndn:phone-camera-reconnect",
      handleReconnectRequest as EventListener,
    );
    return () => {
      window.removeEventListener(
        "ndn:phone-camera-reconnect",
        handleReconnectRequest as EventListener,
      );
    };
  }, [mode, paired]);

  // Sync video element to camera session so other components can access it
  // CRITICAL: Run whenever streaming state changes to keep videoRef synced
  useEffect(() => {
    console.log("[Calibrator] ðŸ”„ STREAMING CHANGED:", {
      streaming,
      videoRefAvailable: !!videoRef.current,
    });
    if (videoRef.current) {
      console.log(
        "[Calibrator] âœ… Syncing videoElementRef on streaming change",
      );
      cameraSession.setVideoElementRef(videoRef.current);
      // Also capture media stream when available
      if (videoRef.current.srcObject instanceof MediaStream) {
        console.log("[Calibrator] âœ… Setting mediaStream from video element");
        cameraSession.setMediaStream(videoRef.current.srcObject);
      }
    } else {
      console.warn(
        "[Calibrator] âš ï¸ videoRef.current is null on streaming change!",
      );
    }
  }, [streaming]);

  // Also sync on mount to capture initial videoRef
  useEffect(() => {
    console.log("[Calibrator] ðŸš€ MOUNT: Initial mount - syncing videoRef");
    console.log("[Calibrator] videoRef.current available:", !!videoRef.current);
    console.log(
      "[Calibrator] videoRef.current type:",
      videoRef.current?.constructor?.name,
    );

    if (videoRef.current) {
      console.log("[Calibrator] âœ… Setting videoElementRef on mount");
      console.log("[Calibrator] Video element:", {
        tagName: videoRef.current.tagName,
        srcObject: !!videoRef.current.srcObject,
        videoWidth: videoRef.current.videoWidth,
        videoHeight: videoRef.current.videoHeight,
      });
      cameraSession.setVideoElementRef(videoRef.current);
      console.log("[Calibrator] âœ… videoElementRef set successfully");
    } else {
      console.error(
        "[Calibrator] âŒ CRITICAL: videoRef.current is NULL at mount!",
      );
    }
    // Do NOT clear the videoElementRef on unmount; we want the stream to persist globally
    return () => {
      /* keep global video element ref for overlay */
    };
  }, []);

  function ensureWS() {
    // Return existing WebSocket if it's open or connecting
    if (
      ws &&
      (ws.readyState === WebSocket.OPEN ||
        ws.readyState === WebSocket.CONNECTING)
    ) {
      console.log(
        "[Calibrator] ensureWS: Reusing existing WebSocket (state:",
        ws.readyState,
        ")",
      );
      return ws;
    }
    // Prefer configured WS endpoint; normalize to include '/ws'. Fallback to same-origin '/ws'.
    const envUrl = (import.meta as any).env?.VITE_WS_URL as string | undefined;
    const normalizedEnv =
      envUrl && envUrl.length > 0
        ? envUrl.endsWith("/ws")
          ? envUrl
          : envUrl.replace(/\/$/, "") + "/ws"
        : undefined;
    const proto = window.location.protocol === "https:" ? "wss" : "ws";
    const sameOrigin = `${proto}://${window.location.host}/ws`;
    const host = window.location.hostname;
    // Production safeguard: if we are not on the Render backend host and no env URL is set,
    // prefer the known Render service as a fallback instead of Netlify same-origin.
    const renderWS = `wss://ninedartnation.onrender.com/ws`;
    const url =
      normalizedEnv || (host.endsWith("onrender.com") ? sameOrigin : renderWS);
    console.log("[Calibrator] ensureWS: Creating new WebSocket to:", url);
    const socket: WebSocket = new WebSocket(url);

    // Set up handlers BEFORE storing the socket to avoid race conditions
    socket.onerror = (error) => {
      console.error("[Calibrator] WebSocket connection error:", error);
      alert(
        "Failed to connect to camera pairing service. Please check your internet connection and try again.",
      );
    };
    socket.onclose = (event) => {
      console.log("[Calibrator] WebSocket closed:", event.code, event.reason);
      if (pcRef.current) {
        try {
          pcRef.current.close();
        } catch {}
        pcRef.current = null;
      }
      updatePairCode(null);
      setExpiresAt(null);
      setPaired(false);
      // Only show alert if it wasn't a clean close
      if (event.code !== 1000) {
        alert("Camera pairing connection lost. Please try pairing again.");
        // Also revert to local mode on disconnect so user can restart camera
        if (mode === "phone") setMode("local");
      }
    };

    // Store socket BEFORE setting message handler to ensure it's available for message sending
    setWs(socket);
    return socket;
  }

  async function startPhonePairing() {
    // Do not reset paired/streaming/phase state here to keep UI static
    // Switch UI into phone pairing mode so the calibrator shows phone-specific hints
    setMode("phone");
    // Stop any existing camera streams before switching to phone mode
    // This ensures clean transition and no resource conflicts
    // Use true for autoRevert since we're explicitly switching modes, but we already set mode above
    stopCamera(false);
    // Lock selection and ensure camera UI is enabled while pairing is active
    lockSelectionForPairing();
    try {
      setCameraEnabled(true);
  } catch (e) {}
    const socket = ensureWS();
    // Send cam-create when socket is ready
    if (socket.readyState === WebSocket.OPEN) {
      console.log("[Calibrator] WebSocket open, sending cam-create");
      socket.send(JSON.stringify({ type: "cam-create" }));
    } else {
      console.log(
        "[Calibrator] WebSocket connecting, will send cam-create on open",
      );
      socket.onopen = () => {
        console.log("[Calibrator] WebSocket now open, sending cam-create");
        socket.send(JSON.stringify({ type: "cam-create" }));
      };
    }
    socket.onmessage = async (ev) => {
      const data = JSON.parse(ev.data);
      if (data.type === "cam-code") {
        updatePairCode(data.code);
        if (data.expiresAt) setExpiresAt(data.expiresAt);
      } else if (data.type === "cam-peer-joined") {
        // Ensure we have the latest pairing code even if messages arrive out of order
        if (!pairCodeRef.current && data.code) updatePairCode(data.code);
        setPaired(true);
        // When a phone peer joins, proactively send current calibration (if locked)
        const codeForSession = pairCodeRef.current || data.code || null;
        if (codeForSession) pairCodeRef.current = codeForSession;
        try {
          if (locked && codeForSession) {
            const imgSize = canvasRef.current
              ? { w: canvasRef.current.width, h: canvasRef.current.height }
              : null;
            const payload = {
              H,
              imageSize: imgSize,
              errorPx: errorPx ?? null,
              createdAt: Date.now(),
            };
            socket.send(
              JSON.stringify({
                type: "cam-calibration",
                code: codeForSession,
                payload,
              }),
            );
            console.log(
              "[Calibrator] Sent calibration to joined phone for code",
              codeForSession,
            );
          }
        } catch (e) {
          console.warn(
            "[Calibrator] Failed to send calibration on peer join",
            e,
          );
        }
        const peer = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
          iceCandidatePoolSize: 10,
        });
        pcRef.current = peer;

        // Add connection state monitoring
        peer.onconnectionstatechange = () => {
          console.log("WebRTC connection state:", peer.connectionState);
          if (
            peer.connectionState === "failed" ||
            peer.connectionState === "disconnected"
          ) {
            console.error("WebRTC connection failed");
            alert("Camera connection lost. Please try pairing again.");
            stopCamera(false);
          } else if (peer.connectionState === "connected") {
            console.log("WebRTC connection established");
          }
        };

        peer.onicecandidate = (e) => {
          if (e.candidate && codeForSession) {
            socket.send(
              JSON.stringify({
                type: "cam-ice",
                code: codeForSession,
                payload: e.candidate,
              }),
            );
          }
        };

        peer.ontrack = (ev) => {
          console.log(
            "[Calibrator] WebRTC ontrack received:",
            ev.streams?.length,
            "streams, track kind:",
            ev.track?.kind,
          );
          if (videoRef.current) {
            const inbound = ev.streams?.[0];
            if (inbound) {
              console.log(
                "[Calibrator] Assigning video stream (tracks:",
                inbound.getTracks().length,
                ") to video element",
              );
              // Ensure video element is visible
              setHasSnapshot(false);
              // Use setTimeout to ensure DOM updates before assigning stream
              setTimeout(() => {
                if (videoRef.current) {
                  console.log(
                    "[Calibrator] Setting srcObject and attempting play",
                  );
                  // Clean up any existing stream before assigning new one
                  if (videoRef.current.srcObject) {
                    const existingTracks = (
                      videoRef.current.srcObject as MediaStream
                    ).getTracks();
                    existingTracks.forEach((t) => t.stop());
                  }
                  videoRef.current.srcObject = inbound;
                  videoRef.current.muted = true; // Ensure muted for autoplay policy
                  videoRef.current.playsInline = true; // Mobile/iOS support
                  videoRef.current
                    .play()
                    .then(() => {
                      console.log(
                        "[Calibrator] Video playback started successfully",
                      );
                      // Mark that we're streaming from the phone and transition to capture
                      setStreaming(true);
                      setPhase("capture");
                      // Update camera session so other components can see the stream
                      cameraSession.setStreaming(true);
                      cameraSession.setMode("phone");
                      cameraSession.setMediaStream(inbound);
                      // Set user settings to reflect that the active camera is the phone
                      try {
                        setPreferredCamera(undefined, "Phone Camera", true);
                      } catch {}
                      if (!preferredCameraLocked) {
                        try {
                          setPreferredCameraLocked(true);
                        } catch {}
                      }
                      try {
                        setCameraEnabled(true);
                      } catch {}
                      // If an overlay prompt was shown earlier, hide it now
                      setVideoPlayBlocked(false);
                    })
                    .catch((err) => {
                      console.error("[Calibrator] Video play failed:", err);
                      // Show a friendly tap-to-play overlay so user can enable playback
                      setVideoPlayBlocked(true);
                      console.warn(
                        "[Calibrator] video play blocked â€” prompting user interaction",
                      );
                    });
                }
              }, 100);
            } else {
              console.error(
                "[Calibrator] No inbound stream received in ontrack",
              );
            }
          } else {
            console.error("[Calibrator] Video element not available");
          }
        };

        try {
          const offer = await peer.createOffer({
            offerToReceiveAudio: false,
            offerToReceiveVideo: true,
          });
          await peer.setLocalDescription(offer);
          console.log(
            "[Calibrator] Sending cam-offer for code:",
            codeForSession,
          );
          if (codeForSession)
            socket.send(
              JSON.stringify({
                type: "cam-offer",
                code: codeForSession,
                payload: offer,
              }),
            );
          else
            console.warn(
              "[Calibrator] Missing pairing code when sending offer",
            );
        } catch (err) {
          console.error("Failed to create WebRTC offer:", err);
          alert("Failed to establish camera connection. Please try again.");
          stopCamera(false);
        }
      } else if (data.type === "cam-answer") {
        console.log("[Calibrator] Received cam-answer");
        const peer = pcRef.current;
        if (peer) {
          try {
            await peer.setRemoteDescription(
              new RTCSessionDescription(data.payload),
            );
            console.log("[Calibrator] Remote description set (answer)");

            // Process any pending ICE candidates that arrived before the answer
            const pending = pendingIceCandidatesRef.current;
            console.log(
              `[Calibrator] Processing ${pending.length} pending ICE candidates`,
            );
            for (const candidate of pending) {
              try {
                await peer.addIceCandidate(candidate);
                console.log("[Calibrator] Queued ICE candidate added");
              } catch (err) {
                console.error("Failed to add queued ICE candidate:", err);
              }
            }
            pendingIceCandidatesRef.current = [];
          } catch (err) {
            console.error("Failed to set remote description:", err);
            alert("Camera pairing failed. Please try again.");
            stopCamera(false);
          }
        } else {
          console.warn(
            "[Calibrator] Received cam-answer but no peer connection exists",
          );
        }
      } else if (data.type === "cam-ice") {
        console.log("[Calibrator] Received cam-ice");
        const peer = pcRef.current;
        if (peer) {
          // Only add ICE candidate if remote description is already set
          // Otherwise, queue it for later processing
          if (peer.remoteDescription) {
            try {
              await peer.addIceCandidate(data.payload);
              console.log("[Calibrator] ICE candidate added");
            } catch (err) {
              console.error("Failed to add ICE candidate:", err);
            }
          } else {
            console.log(
              "[Calibrator] Remote description not set yet, queuing ICE candidate",
            );
            pendingIceCandidatesRef.current.push(data.payload);
          }
        } else {
          console.warn(
            "[Calibrator] Received ICE candidate but no peer connection exists",
          );
        }
      } else if (data.type === "cam-error") {
        console.error("Camera pairing error:", data.code);
        alert(
          data.code === "EXPIRED"
            ? "Code expired. Generate a new code."
            : `Camera error: ${data.code || "Unknown error"}`,
        );
        stopCamera(false);
      } else if (data.type === "cam-calibration") {
        // Desktop receives calibration from phone (via server) or phone receives from desktop
        console.log(
          "[Calibrator] Received calibration from peer:",
          data.payload,
        );
        try {
            if (data.payload) {
              // If payload has a homography, use it. Otherwise if we have 4 calibration points, attempt to compute H.
              let Hpayload = Array.isArray(data.payload.H) ? (data.payload.H as Homography) : null;
              if (!Hpayload && Array.isArray(data.payload.calibrationPoints) && data.payload.calibrationPoints.length >= 4) {
                try {
                  const canonicalSrc = [
                    { x: 0, y: -BoardRadii.doubleOuter },
                    { x: BoardRadii.doubleOuter, y: 0 },
                    { x: 0, y: BoardRadii.doubleOuter },
                    { x: -BoardRadii.doubleOuter, y: 0 },
                  ];
                  Hpayload = computeHomographyDLT(canonicalSrc, data.payload.calibrationPoints.slice(0, 4));
                } catch (err) {
                  console.warn("[Calibrator] Failed to compute homography from received calibration points", err);
                }
              }
              if (Hpayload) {
                // Apply the received calibration
                // Use overlay size from current preview (video or overlay/canvas) if available so visual scale stays consistent
                const overlaySize = overlayRef?.current
                  ? { w: overlayRef.current.width, h: overlayRef.current.height }
                  : videoRef?.current
                  ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
                  : data.payload.imageSize ?? null;
                setCalibration({
                  H: Hpayload as Homography,
                  createdAt: data.payload.createdAt || Date.now(),
                  errorPx: data.payload.errorPx,
                  imageSize: data.payload.imageSize,
                  overlaySize,
                  locked: true, // Assume locked since peer sent it
                });
                console.log("[Calibrator] Applied received calibration");
              }
            }
        } catch (e) {
          console.error("[Calibrator] Failed to apply received calibration", e);
        }
      }
    };
  }

  async function startWifiConnection() {
    setDiscoveringWifi(true);
    try {
      const devices = await discoverNetworkDevices();
      setWifiDevices(devices);
      if (devices.length === 0) {
        alert(
          "No wifi scoring devices found on your network. Make sure devices are powered on and connected to the same network.",
        );
      }
    } catch (error) {
      console.error("Wifi device discovery failed:", error);
      alert(
        "Failed to discover wifi devices. Please check your network connection.",
      );
    } finally {
      setDiscoveringWifi(false);
    }
    setPhase("camera");
  }

  async function connectToWifiDevice(device: NetworkDevice) {
    try {
      setWifiDevices((devices) =>
        devices.map((d) =>
          d.id === device.id ? { ...d, status: "connecting" as const } : d,
        ),
      );

      const stream = await connectToNetworkDevice(device);
      if (stream && videoRef.current) {
        // Clean up any existing stream before assigning new one
        if (videoRef.current.srcObject) {
          const existingTracks = (
            videoRef.current.srcObject as MediaStream
          ).getTracks();
          existingTracks.forEach((t) => t.stop());
        }
        videoRef.current.srcObject = stream;
        await videoRef.current.play();
        setStreaming(true);
        setPhase("capture");
        setWifiDevices((devices) =>
          devices.map((d) =>
            d.id === device.id ? { ...d, status: "online" as const } : d,
          ),
        );
      } else {
        throw new Error("Failed to get video stream");
      }
    } catch (error) {
      console.error("Failed to connect to wifi device:", error);
      alert(
        `Failed to connect to ${device.name}. Please check the device and try again.`,
      );
      setWifiDevices((devices) =>
        devices.map((d) =>
          d.id === device.id ? { ...d, status: "offline" as const } : d,
        ),
      );
    }
  }

  async function startCamera() {
    if (mode === "phone") return startPhonePairing();
    if (mode === "wifi") return startWifiConnection();
    console.log(
      "[Calibrator] ðŸŽ¬ START_CAMERA: mode=",
      mode,
      "preferredCameraId=",
      preferredCameraId,
    );
    try {
      let stream: MediaStream | null = null;

      // Step 1: Try with preferred camera ID if available
      if (preferredCameraId) {
        try {
          console.log(
            "[Calibrator] ðŸ“¹ Attempt 1: Using preferred camera ID:",
            preferredCameraId,
          );
          stream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: preferredCameraId } },
            audio: false,
          });
          console.log(
            "[Calibrator] âœ… SUCCESS with preferred camera:",
            stream.getTracks().length,
            "tracks",
          );
        } catch (err: any) {
          console.warn(
            "[Calibrator] âš ï¸ Preferred camera failed:",
            err?.name,
            err?.message,
          );
        }
      }

      // Step 2: If preferred didn't work, try any camera
      if (!stream) {
        try {
          console.log("[Calibrator] ðŸ“¹ Attempt 2: Using ANY available camera");
          stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
          console.log(
            "[Calibrator] âœ… SUCCESS with fallback camera:",
            stream.getTracks().length,
            "tracks",
          );
        } catch (err: any) {
          console.error(
            "[Calibrator] âŒ BOTH attempts failed:",
            err?.name,
            err?.message,
          );
          throw err;
        }
      }

      // Step 3: Assign to video element
      if (!stream) {
        throw new Error("No stream obtained");
      }

      if (!videoRef.current) {
        throw new Error("Video element ref is null");
      }

      console.log("[Calibrator] ðŸ“º Assigning stream to video element");
      videoRef.current.srcObject = stream;

      console.log("[Calibrator] â–¶ï¸ Calling play()");
      try {
        await videoRef.current.play();
        console.log("[Calibrator] âœ… Play succeeded");
      } catch (playErr: any) {
        console.warn(
          "[Calibrator] âš ï¸ Play failed, retrying in 100ms:",
          playErr?.message,
        );
        await new Promise((r) => setTimeout(r, 100));
        await videoRef.current.play();
        console.log("[Calibrator] âœ… Play succeeded on retry");
      }

      console.log("[Calibrator] ðŸŸ¢ Setting streaming = true");
      setStreaming(true);
      setPhase("capture");
      console.log("[Calibrator] ðŸŸ¢ State updated");
    } catch (e: any) {
      console.error("[Calibrator] ðŸ”´ FATAL:", e?.message || e);
      alert(`Camera failed: ${e?.message || "Unknown error"}`);
      // Clean up any partial stream
      if (videoRef.current?.srcObject) {
        (videoRef.current.srcObject as MediaStream)
          .getTracks()
          .forEach((t) => t.stop());
        videoRef.current.srcObject = null;
      }
    }
  }

  function stopCamera(autoRevert: boolean = false) {
    if (videoRef.current && videoRef.current.srcObject) {
      const tracks = (videoRef.current.srcObject as MediaStream).getTracks();
      tracks.forEach((t) => t.stop());
      videoRef.current.srcObject = null;
      setStreaming(false);
    }
    if (pcRef.current) {
      try {
        pcRef.current.close();
      } catch {}
      pcRef.current = null;
    }
    pendingIceCandidatesRef.current = [];
    updatePairCode(null);
    setExpiresAt(null);
    setPaired(false);
    setMarkerResult(null);
    // Clear camera session when stopping camera
    cameraSession.setStreaming(false);
    cameraSession.setMediaStream(null);
    // Only revert to local mode if EXPLICITLY requested (user clicked Stop button)
    // Otherwise preserve the selected mode so user can go to OfflinePlay and come back
    if (autoRevert && (mode === "phone" || mode === "wifi")) {
      setMode("local");
    }
  }

  function regenerateCode() {
    // Only regenerate code, do not reset UI or camera state
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "cam-create" }));
    } else {
      startPhonePairing();
    }
    // Lock the preferred camera selection while pairing is active so it doesn't
    // flip automatically during the pairing flow.
    lockSelectionForPairing();
  }

  // When user regenerates a pairing code we lock the preferred camera selection so
  // it won't be changed accidentally by other parts of the UI while pairing is active.
  // This implements the user's request that the camera selection 'stay static' after
  // generating a code. The lock can be toggled by the user in the DevicePicker UI.
  function lockSelectionForPairing() {
    try {
      if (!preferredCameraLocked) {
        setPreferredCameraLocked(true);
      }
    } catch {}
  }

  // Allow uploading a photo instead of using a live camera
  function triggerUpload() {
    try {
      fileInputRef.current?.click();
    } catch {}
  }

  function openMarkerSheet() {
    // Open the marker sheet page in a new tab for printing
    const markerSheetUrl = `${window.location.origin}/marker-sheet.html`;
    window.open(markerSheetUrl, "_blank");
  }

  function onUploadPhotoChange(e: React.ChangeEvent<HTMLInputElement>) {
    const f = e.target.files?.[0];
    if (!f) return;
    const img = new Image();
    img.onload = () => {
      try {
        if (!canvasRef.current) return;
        const c = canvasRef.current;
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const ctx = c.getContext("2d")!;
        ctx.drawImage(img, 0, 0, c.width, c.height);
        setHasSnapshot(true);
        setFrameSize({ w: c.width, h: c.height });
        setPhase("select");
        setDstPoints([]);
        setMarkerResult(null);
        // Clear any previous video stream
        stopCamera(false);
      } catch {}
    };
    img.onerror = () => {
      alert("Could not load image. Please try a different photo.");
    };
    img.src = URL.createObjectURL(f);
    // reset input value so the same file can be reselected
    try {
      e.target.value = "";
    } catch {}
  }

  function captureFrame() {
    if (!videoRef.current || !canvasRef.current) return;
    const v = videoRef.current;
    const c = canvasRef.current;
    c.width = v.videoWidth;
    c.height = v.videoHeight;
    const ctx = c.getContext("2d")!;
    ctx.drawImage(v, 0, 0, c.width, c.height);
    setHasSnapshot(true);
    setFrameSize({ w: c.width, h: c.height });
    setPhase("select");
    // Ensure we start fresh with 0 points - log for debugging
    console.log('[Calibrator] captureFrame: resetting dstPoints to []');
    setDstPoints([]);
  setDetected(null); // Also clear auto-detected rings
  setForceDetectedOnly(false);
    setMarkerResult(null);
    // Clear the overlay canvas to remove any leftover drawings (dart axis lines, etc.)
    if (overlayRef.current) {
      const o = overlayRef.current;
      o.width = c.width;
      o.height = c.height;
      const octx = o.getContext("2d");
      if (octx) octx.clearRect(0, 0, o.width, o.height);
    }
    // If liveDetect is on, kick a detect on this captured frame
    if (liveDetect)
      setTimeout(() => {
        autoDetectRings();
      }, 0);
  }

  function drawOverlay(
    currentPoints = dstPoints,
    HH: Homography | null = null,
  ) {
  if (!canvasRef.current || !overlayRef.current) return;
    const img = canvasRef.current;
    const o = overlayRef.current;
    o.width = img.width;
    o.height = img.height;
    const ctx = o.getContext("2d")!;
    ctx.clearRect(0, 0, o.width, o.height);

    // Ensure overlay is interactive: attach click handler for align operation
    if (overlayRef.current) {
      overlayRef.current.onclick = (e: MouseEvent) => onOverlayClick(e);
    }

  // Only use stored H for drawing rings if we have enough points OR if explicitly passed HH
    // During calibration point collection (phase="select" with < REQUIRED points), don't use old H
    // as it may be from a previous frame and draw incorrectly
    const Huse = HH || (currentPoints.length >= REQUIRED_POINT_COUNT ? H : null);
  // Apply the correction to the stored calibration H so both overlay and scoring match
    // Add translation after scaling for pixel-perfect alignment
    const CORRECTION_SX = correctionSx; // <1 compresses horizontally
    const CORRECTION_TX = correctionTx; // pixels right (+) or left (-)
    const CORRECTION_TY = correctionTy; // pixels down (+) or up (-)
    let Hcorrected = Huse;
    if (Hcorrected && CORRECTION_SX !== 1) Hcorrected = scaleHomography(Hcorrected, CORRECTION_SX, 1);
    if (Hcorrected && (CORRECTION_TX !== 0 || CORRECTION_TY !== 0)) Hcorrected = translateHomography(Hcorrected, CORRECTION_TX, CORRECTION_TY);
    
    // Apply translation corrections to center coordinates (when detected exists)
    const adjustedCenterX = detected ? detected.cx + correctionTx : 0;
    const adjustedCenterY = detected ? detected.cy + correctionTy : 0;

    // Precompute detected radii map (useful even if we later bypass homography)
  const WIDEN_FACTOR = 1.0; // use raw detected radii for exact alignment
    const detectedRingMap: { [key: number]: number } = {};
  if (detected) {
      // Store raw scaled radii (before applying correctionSx for display as ellipses)
      detectedRingMap[BoardRadii.bullInner] = detected.bullInner * WIDEN_FACTOR;
      detectedRingMap[BoardRadii.bullOuter] = detected.bullOuter * WIDEN_FACTOR;
      detectedRingMap[BoardRadii.trebleInner] = detected.trebleInner * WIDEN_FACTOR;
      detectedRingMap[BoardRadii.trebleOuter] = detected.trebleOuter * WIDEN_FACTOR;
      detectedRingMap[BoardRadii.doubleInner] = detected.doubleInner * WIDEN_FACTOR;
      detectedRingMap[BoardRadii.doubleOuter] = detected.doubleOuter * WIDEN_FACTOR;
    }

    // Per-ring adjustments if needed (quick fix for non-standard boards)
  const perRingAdjust: { [key: number]: number } = {};
  // Apply per-ring adjustments using UI-controlled state
  perRingAdjust[BoardRadii.doubleOuter] = doubleOuterAdjust;
  perRingAdjust[BoardRadii.trebleOuter] = trebleOuterAdjust;

    // Helper to draw the detected rings directly (bypass homography)
    function drawDetectedRings(): number {
      if (!detected) return 0;
      let drawn = 0;
      try {
        // Colors using pass/fail heuristics are available below; use default colors here
        const bullFill = 'rgba(52,211,153,0.08)';
        const trebleFill = 'rgba(253,224,71,0.06)';
        const doubleFill = 'rgba(34,211,238,0.06)';

        const drawBand = (rInner: number, rOuter: number, fillStyle: string, strokeStyle?: string) => {
          const inner = detectedRingMap[rInner];
          const outer = detectedRingMap[rOuter];
          if (!inner || !outer) return false;
          ctx.save();
          ctx.shadowColor = 'rgba(0,0,0,0.45)';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          const outerAdj = outer * (perRingAdjust[rOuter] || 1);
          const innerAdj = inner * (perRingAdjust[rInner] || 1);
          // Draw as circles based on adjusted radii; no ellipse distortions
          ctx.arc(adjustedCenterX, adjustedCenterY, outerAdj, 0, Math.PI * 2);
          ctx.arc(adjustedCenterX, adjustedCenterY, innerAdj, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fillStyle = fillStyle;
          ctx.fill();
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          ctx.restore();
          return true;
        };

        drawBand(BoardRadii.bullInner, BoardRadii.bullOuter, bullFill);
        drawn++;
        drawBand(BoardRadii.trebleInner, BoardRadii.trebleOuter, trebleFill);
        drawn++;
        drawBand(BoardRadii.doubleInner, BoardRadii.doubleOuter, doubleFill);
        drawn++;

        // Outlines for clarity
        const OUTLINE_STEPS = 360;
        const outlines = [
          { r: BoardRadii.bullInner, color: '#00ff66' },
          { r: BoardRadii.bullOuter, color: '#ffffff' },
          { r: BoardRadii.trebleInner, color: '#fde047' },
          { r: BoardRadii.trebleOuter, color: '#fde047' },
          { r: BoardRadii.doubleInner, color: '#22d3ee' },
          { r: BoardRadii.doubleOuter, color: '#22d3ee' },
        ];
        for (const oline of outlines) {
          const radius = detectedRingMap[oline.r];
          if (!radius) continue;
          const poly: Point[] = [];
          for (let i = 0; i < OUTLINE_STEPS; i++) {
            const angle = (i / OUTLINE_STEPS) * Math.PI * 2;
            const rAdj = radius * correctionSx * (perRingAdjust[oline.r] || 1);
            poly.push({
              x: adjustedCenterX + rAdj * Math.cos(angle),
              y: adjustedCenterY + rAdj * Math.sin(angle),
            });
          }
          drawPolyline(ctx, poly, 'rgba(0,0,0,0.45)', 3);
          drawPolyline(ctx, poly, oline.color, 1.5);
        }
      } catch (err) {
        return 0;
      }
      return 3;
    }
  
    // Click handler for overlay to support 'align ring by click'
    function onOverlayClick(evt: MouseEvent) {
      if (!aligningRing || !overlayRef.current || !detected) return;
      const rect = overlayRef.current.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (overlayRef.current.width / rect.width);
      const y = (evt.clientY - rect.top) * (overlayRef.current.height / rect.height);
      const dx = x - adjustedCenterX;
      const dy = y - adjustedCenterY;
      const clickedRadius = Math.hypot(dx, dy);
      let key: number;
      if (aligningRing === 'double') key = BoardRadii.doubleOuter;
      else if (aligningRing === 'treble') key = BoardRadii.trebleOuter;
      else key = BoardRadii.bullOuter;
      const currentRadius = detectedRingMap[key];
      if (!currentRadius || currentRadius <= 0) return;
      const newAdjust = clickedRadius / (currentRadius * correctionSx);
      if (aligningRing === 'double') setDoubleOuterAdjust(newAdjust);
      if (aligningRing === 'treble') setTrebleOuterAdjust(newAdjust);
      if (aligningRing === 'bull') {
        // Update bull adjustments via Sx temporarily (only for display) - more complex per-ring state could be added
        setCorrectionSx((prev) => prev * (newAdjust / prev));
      }
      setAligningRing(null);
      console.log('[Calibrator] Aligned ', aligningRing, ' adjust=', newAdjust.toFixed(4));
    }
  // Use Hcorrected everywhere below (for overlay and for scoring)
  // If you want to make this user-tunable, expose CORRECTION_SX as a setting
  // (for now, hardcoded for millimetre alignment)
  // Note: this means the correction is always applied, including when saving calibration
  // and when mapping points for scoring.
  const Hdraw = Hcorrected;
    if (HH) {
      console.log('[drawOverlay] Using passed homography:', {
        HH: HH.slice(0, 6),
        currentPointsCount: currentPoints.length,
        canvasSize: { w: o.width, h: o.height },
      });
    }
    if (forceDetectedOnly && detected) {
      // Force-only: draw detected rings directly and skip homography-based overlay
      const drawn = drawDetectedRings();
      console.log('[drawOverlay] Forced detected-only drawing, rings drawn:', drawn);
      // Draw sector labels around the double center using detected theta
      try {
        const ctx2 = overlayRef.current?.getContext("2d");
        const hasCtx = !!ctx2 && overlayRef.current;
        if (hasCtx && detected) {
          ctx2!.save();
          ctx2!.font = "12px Sans-Serif";
          ctx2!.fillStyle = "#ffffff";
          ctx2!.strokeStyle = "#000000";
          ctx2!.lineWidth = 3;
          const labels = SectorOrder; // canonical order
          const centerX = adjustedCenterX;
          const centerY = adjustedCenterY;
          const rLabel = (detected.doubleInner + detected.doubleOuter) / 2 + 14; // just outside double center
          const thetaVal = typeof theta === "number" ? theta : 0;
          for (let i = 0; i < labels.length; i++) {
            const ang = (i / labels.length) * Math.PI * 2 - Math.PI / 2 - thetaVal;
            const lx = centerX + rLabel * Math.cos(ang);
            const ly = centerY + rLabel * Math.sin(ang);
            const text = String(labels[i]);
            const tw = ctx2!.measureText(text).width;
            ctx2!.strokeText(text, lx - tw / 2, ly + 4);
            ctx2!.fillText(text, lx - tw / 2, ly + 4);
          }
          ctx2!.restore();
        }
      } catch {}
      return; // don't draw homography overlay
    }

    if (Huse) {
      // Decide overlay color scheme based on verification and error
  // Use errorPx from calibration store
  const errPx = typeof errorPx === 'number' ? errorPx : null;
      const hasVerification = verificationResults && verificationResults.length > 0;
      const allPass = hasVerification ? verificationResults.every(r => r.match) : null;
      const passByError = typeof errPx === 'number' ? errPx <= 1.5 : null; // strict pass threshold
      const pass = (allPass === true) || (passByError === true);
      const fail = hasVerification ? verificationResults.some(r => !r.match) : (passByError === false);

  console.log('[drawOverlay] Drawing via homography transform');
      const rings = [
        BoardRadii.bullInner,
        BoardRadii.bullOuter,
        BoardRadii.trebleInner,
        BoardRadii.trebleOuter,
        BoardRadii.doubleInner,
        BoardRadii.doubleOuter,
      ];
      let drawnCount = 0;
      
      // Use precomputed detectedRingMap above (if present) - no need to recompute here
      
      // Helper to draw a filled band between inner and outer radii
      // Use detected radii when available for perfect alignment
      function drawRingBand(Hmat: Homography, rInner: number, rOuter: number, fillStyle: string, strokeStyle?: string) {
        try {
          const STEPS = 720; // high resolution for smoothness
          
          // If we have detected radii for both inner and outer, use direct circles
          const detectedInner = detectedRingMap[rInner];
          const detectedOuter = detectedRingMap[rOuter];
          if (detected && detectedInner && detectedOuter) {
            ctx.save();
            // subtle shadow to improve contrast over busy backgrounds
            ctx.shadowColor = 'rgba(0,0,0,0.45)';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            // Draw ellipses to support horizontal scaling correction
            if (ctx.ellipse) {
              ctx.ellipse(adjustedCenterX, adjustedCenterY, detectedOuter * correctionSx, detectedOuter, 0, 0, Math.PI * 2);
              ctx.ellipse(adjustedCenterX, adjustedCenterY, detectedInner * correctionSx, detectedInner, 0, 0, Math.PI * 2, true);
            } else {
              ctx.arc(adjustedCenterX, adjustedCenterY, detectedOuter, 0, Math.PI * 2);
              ctx.arc(adjustedCenterX, adjustedCenterY, detectedInner, 0, Math.PI * 2, true);
            }
            ctx.closePath();
            ctx.fillStyle = fillStyle;
            ctx.fill();
            if (strokeStyle) {
              ctx.strokeStyle = strokeStyle;
              ctx.lineWidth = 2;
              ctx.stroke();
            }
            ctx.restore();
            return true;
          }
          
          // Otherwise use homography-based drawing
          const outer = sampleRing(Hmat, rOuter, STEPS);
          const inner = sampleRing(Hmat, rInner, STEPS).reverse();
          if (!outer.length || !inner.length) return false;
          ctx.save();
          // subtle shadow to improve contrast over busy backgrounds
          ctx.shadowColor = 'rgba(0,0,0,0.45)';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.moveTo(outer[0].x, outer[0].y);
          for (let i = 1; i < outer.length; i++) ctx.lineTo(outer[i].x, outer[i].y);
          for (let i = 0; i < inner.length; i++) ctx.lineTo(inner[i].x, inner[i].y);
          ctx.closePath();
          ctx.fillStyle = fillStyle;
          ctx.fill();
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          ctx.restore();
          return true;
        } catch (e) {
          return false;
        }
      }
      // Draw bands for ONLY bull, treble and double (playable zones)
      // Do NOT draw any ring outside the double outer rim
      if (Hdraw) {
        // Colors: use green when pass, red when fail, else default
        const bullFill = pass ? "rgba(0,255,102,0.12)" : fail ? "rgba(255,45,45,0.12)" : "rgba(52,211,153,0.08)";
        const trebleFill = pass ? "rgba(0,255,102,0.08)" : fail ? "rgba(255,45,45,0.08)" : "rgba(253,224,71,0.06)";
        const doubleFill = pass ? "rgba(0,255,102,0.06)" : fail ? "rgba(255,45,45,0.06)" : "rgba(34,211,238,0.06)";

        // Bull (fill inner and outer ring area) - use real board radii
        drawRingBand(Hdraw as any, BoardRadii.bullInner, BoardRadii.bullOuter, bullFill, "rgba(255,255,255,0.06)");
        drawnCount++;

        // Treble band - use DETECTED radii if available, otherwise use calibration guide
        const trebleInnerToUse = detected?.trebleInner || CalibrationGuideRadii.trebleInner;
        const trebleOuterToUse = detected?.trebleOuter || CalibrationGuideRadii.trebleOuter;
        drawRingBand(Hdraw as any, trebleInnerToUse, trebleOuterToUse, trebleFill, "rgba(255,255,255,0.06)");
        drawnCount++;

        // Double band - use DETECTED radii if available, otherwise use calibration guide
        const doubleInnerToUse = detected?.doubleInner || CalibrationGuideRadii.doubleInner;
        const doubleOuterToUse = detected?.doubleOuter || CalibrationGuideRadii.doubleOuter;
        drawRingBand(Hdraw as any, doubleInnerToUse, doubleOuterToUse, doubleFill, "rgba(255,255,255,0.06)");
        drawnCount++;

        // Draw ONLY cyan outlines for the playable rings: bullInner, bullOuter, trebleInner, trebleOuter, doubleInner, doubleOuter
        // Do NOT draw any outer board edge
        try {
          const OUTLINE_STEPS = 720;
          const outlines = [
            { r: BoardRadii.bullInner, color: pass ? '#00ff66' : fail ? '#ff2d2d' : '#ffffff', key: 'bullInner' },
            { r: BoardRadii.bullOuter, color: '#ffffff', key: 'bullOuter' },
            { r: trebleInnerToUse, color: pass ? '#00ff66' : fail ? '#ff2d2d' : '#fde047', key: 'trebleInner' },
            { r: trebleOuterToUse, color: '#fde047', key: 'trebleOuter' },
            { r: doubleInnerToUse, color: pass ? '#00ff66' : fail ? '#ff2d2d' : '#22d3ee', key: 'doubleInner' },
            { r: doubleOuterToUse, color: '#22d3ee', key: 'doubleOuter' }, // <-- Last cyan ring; nothing beyond this
          ];
          for (const oline of outlines) {
            const detectedRadius = detectedRingMap[oline.r];
            let poly: Point[];
            if (detected && detectedRadius) {
              // Use detected radius for direct circle
              poly = [];
              for (let i = 0; i < OUTLINE_STEPS; i++) {
                const angle = (i / OUTLINE_STEPS) * Math.PI * 2;
                poly.push({
                  x: adjustedCenterX + detectedRadius * Math.cos(angle),
                  y: adjustedCenterY + detectedRadius * Math.sin(angle)
                });
              }
            } else {
              poly = sampleRing(Hdraw as any, oline.r, OUTLINE_STEPS);
            }
            // Draw a thin darker stroke then a brighter stroke on top for contrast
            drawPolyline(ctx, poly, 'rgba(0,0,0,0.45)', 3);
            drawPolyline(ctx, poly, oline.color, 1.5);
          }
        } catch (err) {
          // ignore outline errors
        }
      }
    console.log('[drawOverlay] Drew', drawnCount, 'rings via homography');
    // Draw sector labels when using homography too (align using theta if present)
    try {
      const ctx2 = overlayRef.current?.getContext("2d");
      const hasCtx = !!ctx2 && overlayRef.current;
      if (hasCtx) {
        // Compute board center in image via homography
        const cImg = applyHomography(Hdraw || HH!, { x: 0, y: 0 });
        const rCenter = (BoardRadii.doubleInner + BoardRadii.doubleOuter) / 2 + 14;
        const labels = SectorOrder;
        ctx2!.save();
        ctx2!.font = "12px Sans-Serif";
        ctx2!.fillStyle = "#ffffff";
        ctx2!.strokeStyle = "#000000";
        ctx2!.lineWidth = 3;
        const thetaVal = typeof theta === "number" ? theta : 0;
        for (let i = 0; i < labels.length; i++) {
          const ang = (i / labels.length) * Math.PI * 2 - Math.PI / 2 - thetaVal;
          const p = applyHomography(Hdraw || HH!, { x: (rCenter-14) * Math.cos(ang), y: (rCenter-14) * Math.sin(ang) });
          const text = String(labels[i]);
          const tw = ctx2!.measureText(text).width;
          ctx2!.strokeText(text, p.x - tw / 2, p.y + 4);
          ctx2!.fillText(text, p.x - tw / 2, p.y + 4);
        }
        ctx2!.restore();
      }
    } catch {}

      // PASS/FAIL flash badge (top-right) for ~1.5s after verification
      if (flashStatus.type && Date.now() < flashStatus.until) {
        const isPass = flashStatus.type === 'pass';
        const bg = isPass ? 'rgba(0,255,102,0.9)' : 'rgba(255,45,45,0.9)';
        const text = isPass ? 'CALIBRATION PASS' : 'CALIBRATION FAIL';
        ctx.save();
        const pad = 12;
        const x = o.width - 240 - pad;
        const y = pad;
        ctx.fillStyle = bg;
        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(x, y, 240, 34, 8);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#00110a';
        ctx.font = 'bold 14px system-ui, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x + 12, y + 17);
        ctx.restore();
      }
    }
    // Always draw detected circles if enabled (for debugging detection accuracy)
  if (detected && showDetectedOverlay) {
      console.log('[drawOverlay] Drawing detected circles overlay:', {
        adjustedCx: Math.round(adjustedCenterX),
        adjustedCy: Math.round(adjustedCenterY),
        doubleOuter: Math.round(detected.doubleOuter),
        trebleOuter: Math.round(detected.trebleOuter),
        bullOuter: Math.round(detected.bullOuter),
      });
      const drawCircle = (r: number, color: string, w = 2) => {
        if (!Number.isFinite(r) || r <= 0) return;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = w;
        ctx.setLineDash([5, 5]); // Dashed to distinguish from overlay
  ctx.beginPath();
  const radScale = correctionSx; // use uniform scale for debug circles
  const rx = r * radScale;
  const ry = r * radScale;
  if (ctx.ellipse) ctx.ellipse(adjustedCenterX, adjustedCenterY, rx, ry, 0, 0, Math.PI * 2);
  else ctx.arc(adjustedCenterX, adjustedCenterY, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      };
  // Draw detected rings with dashed lines
      drawCircle(detected.doubleOuter, "#ff6b6b", 3); // Red for detected double
      drawCircle(detected.doubleInner, "#ff6b6b", 2);
      drawCircle(detected.trebleOuter, "#ffd93d", 2); // Yellow for detected treble
      drawCircle(detected.trebleInner, "#ffd93d", 2);
      drawCircle(detected.bullOuter, "#6bcf7f", 2); // Green for detected bull
      drawCircle(detected.bullInner, "#6bcf7f", 3);

  // Also draw homography-sampled rings (if Hdraw present) for comparison
  if (Hdraw && !forceDetectedOnly) {
        const sampleAndDraw = (rMm: number, color: string) => {
          const poly = sampleRing(Hdraw as any, rMm, 180);
          if (!poly.length) return;
          ctx.save();
          ctx.setLineDash([6, 4]);
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(poly[0].x, poly[0].y);
          for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i].x, poly[i].y);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        };
        sampleAndDraw(BoardRadii.doubleOuter, '#00ffff');
        sampleAndDraw(BoardRadii.trebleOuter, '#ffff00');
      }
    }
    // Display detected metadata for debugging
    if (detected) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(8, 8, 260, 72);
      ctx.fillStyle = '#fff';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(`Detected cx:${Math.round(detected.cx)} cy:${Math.round(detected.cy)}`, 16, 28);
      ctx.fillText(`Double: ${Math.round(detected.doubleOuter)} Treble: ${Math.round(detected.trebleOuter)}`, 16, 48);
      ctx.fillText(`Adjusts: Sx:${correctionSx.toFixed(3)} Tx:${correctionTx} Ty:${correctionTy}`, 16, 68);
      ctx.restore();
    }

    // Show calibration guide circles ONLY when we have a freshly computed homography (HH)
    // from at least 4 clicked points in this session - don't use old stored H for guides
    // as it may be incorrect and mislead the user
  const targetPoints = canonicalRimTargets("outer");
    const showGuides = currentPoints.length >= 4 && currentPoints.length < targetPoints.length && HH;
    if (showGuides) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,193,7,0.4)";
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      // Show the remaining expected click positions (e.g., BULL after D20, D6, D3, D11)
      for (let i = currentPoints.length; i < targetPoints.length; i++) {
          try {
          // Use the same visual correction for guide circles so they align with the rings
          const p = applyHomography(Hdraw || HH, targetPoints[i]);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.save();
          ctx.fillStyle = "rgba(255,255,255,0.65)";
          ctx.font = "12px sans-serif";
          ctx.fillText(
            CALIBRATION_POINT_LABELS[i] ?? String(i + 1),
            p.x + 10,
            p.y - 10,
          );
          ctx.restore();
        } catch {}
      }
      ctx.restore();
    }

    // Show "Click on X" instruction prominently on the overlay
    if (currentPoints.length < REQUIRED_POINT_COUNT) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(10, 10, 200, 40);
      ctx.fillStyle = "#fbbf24";
      ctx.font = "bold 16px sans-serif";
      ctx.fillText(
        `Click on ${CALIBRATION_POINT_LABELS[currentPoints.length]}`,
        20,
        36
      );
      ctx.restore();
    }

    // Draw clicked points with sector labels so users know which doubles have been mapped
    currentPoints.forEach((p, i) => {
      drawCross(ctx, p, "#f472b6");
      ctx.save();
      ctx.fillStyle = "#f472b6";
      ctx.font = "14px sans-serif";
      ctx.fillText(
        CALIBRATION_POINT_LABELS[i] ?? String(i + 1),
        p.x + 6,
        p.y - 6,
      );
      ctx.restore();
    });

    // Preferred-view framing guide (if enabled and not yet calibrated)
    if (calibrationGuide && !locked) {
      ctx.save();
      // Semi-transparent vignette to encourage centered, face-on framing
      ctx.fillStyle = "rgba(59,130,246,0.10)";
      const pad = Math.round(Math.min(o.width, o.height) * 0.08);
      const w = o.width - pad * 2;
      const h = o.height - pad * 2;
      ctx.fillRect(pad, pad, w, h);
      // Horizon/tilt line and vertical center line
      ctx.strokeStyle = "rgba(34,197,94,0.9)";
      ctx.lineWidth = 2;
      // Horizontal line roughly through bull height
      ctx.beginPath();
      ctx.moveTo(pad, o.height / 2);
      ctx.lineTo(o.width - pad, o.height / 2);
      ctx.stroke();
      // Vertical center
      ctx.beginPath();
      ctx.moveTo(o.width / 2, pad);
      ctx.lineTo(o.width / 2, o.height - pad);
      ctx.stroke();
      // Angle brackets to suggest slight top-down 10â€“15Â°
      ctx.strokeStyle = "rgba(234,179,8,0.9)";
      ctx.setLineDash([6, 4]);
      const ax = pad + 30,
        ay = pad + 30;
      ctx.beginPath();
      ctx.moveTo(ax, ay + 30);
      ctx.lineTo(ax + 60, ay);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(o.width - ax, ay + 30);
      ctx.lineTo(o.width - ax - 60, ay);
      ctx.stroke();
      ctx.restore();
      // Legend - draw at fixed size regardless of zoom
      ctx.save();
      ctx.scale(1 / zoom, 1 / zoom); // Inverse scale to keep text static
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px sans-serif";
      ctx.fillText(
        "Tip: Frame board centered, edges parallel; slight top-down is okay. Keep bull near center.",
        pad * zoom,
        (pad + 18) * zoom,
      );
      ctx.restore();
    }
  }

    const applyTestAutoDetectResult = (result: TestAutoDetectResult) => {
      if (!result) return;
      setAutoCalibrating(false);
  setDetected(null);
  setForceDetectedOnly(false);
      if (result.anchors?.dst && result.anchors.dst.length > 0) {
        setDstPoints(result.anchors.dst);
        drawOverlay(result.anchors.dst, result.H);
      }
      // Save the corrected H so scoring and overlay match
      // Save the corrected H (with scale and translation) so scoring and overlay match
      let Hcal = result.H;
      if (correctionSx !== 1) Hcal = scaleHomography(Hcal, correctionSx, 1);
      if (correctionTx !== 0 || correctionTy !== 0) Hcal = translateHomography(Hcal, correctionTx, correctionTy);
      setCalibration({
        H: Hcal,
        createdAt: Date.now(),
        errorPx: result.errorPx,
        imageSize: result.imageSize,
        overlaySize: result.overlaySize,
        anchors: result.anchors,
        locked: result.locked,
      });
      setPhase(result.phase ?? "computed");
      setConfidence(result.confidence ?? 100);
      setDetectionMessage("Test auto-detect applied");
      delete (globalThis as any).__TEST_AUTO_DETECT_RESULT;
    };

  function onClickOverlay(e: React.PointerEvent<HTMLCanvasElement>) {
    console.debug('[Calibrator] onClickOverlay entry', phase, e.type);
    e.stopPropagation();
    e.preventDefault();
    // For selection mode allow adding anchor points, but for computed mode we interpret as a test click
    // Also allow camera mode when autocommit test mode is enabled so tests can simulate a click-to-detect
    const allowCameraClick = (phase === "camera" || phase === "capture") && autoCommitTestMode;
    if (phase !== "select" && phase !== "computed" && !allowCameraClick) return;
    const el = e.target as HTMLCanvasElement;
    const rect = el.getBoundingClientRect();
    const cssX = e.clientX - rect.left;
    const cssY = e.clientY - rect.top;
    // Map CSS coordinates back to the overlay canvas pixel coordinates, accounting for CSS scaling and zoom
    const scaleX = el.width > 0 ? el.width / (rect.width || (canvasRef.current?.clientWidth || rect.width)) : 1;
    const scaleY = el.height > 0 ? el.height / (rect.height || (canvasRef.current?.clientHeight || rect.height)) : 1;
    const x = cssX * scaleX;
    const y = cssY * scaleY;
    console.debug('[Calibrator] onClickOverlay css/x/y', { cssX, cssY, scaleX, scaleY, x, y });
    if (phase === "select") {
      console.log('[Calibrator] Adding point. Current dstPoints.length:', dstPoints.length, 'New point:', { x, y });
      const pts = [...dstPoints, { x, y }];
      console.log('[Calibrator] After add, pts.length:', pts.length, 'REQUIRED:', REQUIRED_POINT_COUNT);
      if (pts.length <= REQUIRED_POINT_COUNT) {
        setDstPoints(pts);
        // If we have 4+ points, compute a temporary homography to show guide for remaining points
        if (pts.length >= 4) {
          const src = canonicalRimTargets("outer");
          const tempH = computeHomographyDLT(src.slice(0, 4), pts.slice(0, 4));
          drawOverlay(pts, tempH);
        } else {
          drawOverlay(pts);
        }
      }
      return;
    }
    const testClickValue = (globalThis as any).__TEST_CALIBRATION_CLICK_VALUE;
    let val: number | null = null;
    let label = "";
    let detectionMeta:
      | {
          pBoard: ReturnType<typeof imageToBoard>;
          scoreObj: ReturnType<typeof scoreAtBoardPoint>;
        }
      | null = null;
    try {
      if (typeof testClickValue === "number") {
        val = testClickValue;
        label = `TEST ${val}`;
        const fallbackScoreObj = {
          base: val,
          mult: 1,
          ring: "SINGLE",
          sector: null,
        } as ReturnType<typeof scoreAtBoardPoint>;
        detectionMeta = {
          scoreObj: fallbackScoreObj,
          pBoard: { x: 0, y: 0 } as ReturnType<typeof imageToBoard>,
        };
        delete (globalThis as any).__TEST_CALIBRATION_CLICK_VALUE;
      } else {
        const calibState = (useCalibration as any).getState
          ? (useCalibration as any).getState()
          : undefined;
        const Hcur = calibState?.H ?? H;
        const imgSize = calibState?.imageSize ?? imageSize;
        console.debug('[Calibrator] onClickOverlay state', { Hcur, imgSize });
        if (!Hcur || !overlayRef.current || !imgSize) return;
        const o = overlayRef.current;
        // Some test environments may not set canvas width/height; fall back to CSS bounding rect
  const rect2 = o.getBoundingClientRect();
        const fallbackWidth =
          (canvasRef.current && canvasRef.current.width)
            ? canvasRef.current.width
            : rect2.width;
        const fallbackHeight =
          (canvasRef.current && canvasRef.current.height)
            ? canvasRef.current.height
            : rect2.height;
        const sx =
          o.width && imgSize.w
            ? o.width / imgSize.w
            : fallbackWidth / imgSize.w;
        const sy =
          o.height && imgSize.h
            ? o.height / imgSize.h
            : fallbackHeight / imgSize.h;
        console.debug('[Calibrator] onClickOverlay dims', {
          oWidth: o.width,
          oHeight: o.height,
          rectWidth: rect2.width,
          rectHeight: rect2.height,
          fallbackWidth,
          fallbackHeight,
          sx,
          sy,
        });
        const clientWidth = rect2.width || fallbackWidth;
        const clientHeight = rect2.height || fallbackHeight;
        const fracX = clientWidth ? cssX / clientWidth : 0;
        const fracY = clientHeight ? cssY / clientHeight : 0;
  const pCal = { x: fracX * imgSize.w, y: fracY * imgSize.h };
        const pBoard = imageToBoard(Hcur as any, pCal);
        console.debug('[Calibrator] onClickOverlay pCal/pBoard', pCal, pBoard);
        if (!pBoard) {
          console.warn('[Calibrator] Failed to map point to board - homography inversion failed');
          return;
        }
  const scoreObj = scoreAtBoardPointTheta(pBoard, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0);
        detectionMeta = { scoreObj, pBoard };
        val = scoreObj.base;
        // If user/test click is on bull or inner bull, capture an image-space center hint for auto-calibrate
        if (scoreObj.ring === "BULL" || scoreObj.ring === "INNER_BULL") {
          setBullHint(pCal);
        }
        console.debug('[Calibrator] autoCommitTestMode', autoCommitTestMode);
        if (autoCommitTestMode && val === 0) {
          val = 25;
        }
        label = `${scoreObj.ring} ${val}`.trim();
      }
      if (val == null) return;
      setLastDetectedValue(val);
      console.debug('[Calibrator] onClickOverlay detected', val, label);
      setLastDetectedLabel(label);
      try {
        const calibSt = (useCalibration as any).getState
          ? (useCalibration as any).getState()
          : undefined;
        const calibrationValidSt = !!calibSt?.H && !!calibSt?.imageSize && (calibSt.locked || (typeof calibSt.errorPx === 'number' && calibSt.errorPx <= ERROR_PX_MAX));
        if (autoCommitTestMode && !autoCommitImmediate && calibrationValidSt && useMatch.getState().inProgress) {
          doCommit(val);
        }
      } catch {}
      if (autoCommitTestMode && autoCommitImmediate && useMatch.getState().inProgress) {
        const calibSt2 = (useCalibration as any).getState
          ? (useCalibration as any).getState()
          : undefined as any;
        const calibrationValidSt2 = !!calibSt2?.H && !!calibSt2?.imageSize && (calibSt2.locked || (typeof calibSt2.errorPx === 'number' && calibSt2.errorPx <= ERROR_PX_MAX));
        if (!calibrationValidSt2) {
          console.debug('[Calibrator] immediate autocommit skipped due to invalid calibration', { calibrationValidSt2 });
        } else {
          const isOnline = useMatch.getState().roomId !== "";
          console.debug('[Calibrator] immediate-branch conditions', { autoCommitTestMode, autoCommitImmediate, inProgress: useMatch.getState().inProgress, isOnline });
          if (!isOnline) {
            const sig = `${val}|3`;
            const now = performance.now();
            if (!inFlightAutoCommitRef.current && !(sig === lastAutoSigRef.current && now - lastAutoSigAtRef.current < AUTO_COMMIT_COOLDOWN_MS)) {
              lastAutoSigRef.current = sig;
              lastAutoSigAtRef.current = now;
              inFlightAutoCommitRef.current = true;
              useMatch.getState().addVisit(val, 3, { visitTotal: val });
              try { window.setTimeout(() => { inFlightAutoCommitRef.current = false; }, Math.max(120, AUTO_COMMIT_COOLDOWN_MS)); } catch (e) {}
            }
          } else if (allowAutocommitInOnline) {
            if (!detectionMeta) {
              console.debug('[Calibrator] immediate autocommit skipped, detection metadata missing');
            } else {
              const { pBoard, scoreObj } = detectionMeta;
              try {
                console.debug('[Calibrator] sending auto-visit', { roomId: useMatch.getState().roomId, allowAutocommitInOnline });
                useWS().send({
                  type: 'auto-visit',
                  roomId: useMatch.getState().roomId,
                  value: val,
                  darts: 3,
                  ring: scoreObj.ring,
                  sector: scoreObj.sector,
                  pBoard,
                  calibrationValid: true,
                });
              } catch (e) {
                console.debug('[Calibrator] immediate autocommit remote send failed', e);
              }
            }
          }
        }
      }
    } catch (err) {
      /* ignore */
    }
  }

  function doCommit(val?: number) {
    try {
      const v = typeof val === 'number' ? val : lastDetectedValue;
      console.debug('[Calibrator] doCommit invoked', { v, inProgress: useMatch.getState().inProgress });
      // Only commit when calibration is (still) valid; re-evaluate store state at call-time
      const calState = (useCalibration as any).getState ? (useCalibration as any).getState() : undefined as any;
      const curCalValid = !!calState?.H && !!calState?.imageSize && (calState.locked || (typeof calState.errorPx === 'number' && calState.errorPx <= ERROR_PX_MAX));
      if (v != null && useMatch.getState().inProgress && curCalValid) {
        // prevent double commits by checking cooldown signature
        const sig = `${v}|3`;
        const now = performance.now();
        if (!inFlightAutoCommitRef.current && !(sig === lastAutoSigRef.current && now - lastAutoSigAtRef.current < AUTO_COMMIT_COOLDOWN_MS)) {
          lastAutoSigRef.current = sig;
          lastAutoSigAtRef.current = now;
          inFlightAutoCommitRef.current = true;
          console.debug('[Calibrator] doCommit: committing visit', v, { calState, curCalValid });
          try { useMatch.getState().addVisit(v, 3, { visitTotal: v }); } catch (e) {}
          try { window.setTimeout(() => { inFlightAutoCommitRef.current = false; }, Math.max(120, AUTO_COMMIT_COOLDOWN_MS)); } catch (e) {}
        } else {
          console.debug('[Calibrator] doCommit: deduped commit skipped', { v, curCalValid, sig });
        }
      } else {
  console.debug('[Calibrator] doCommit: NOT committing (invalid cal or no match)', { v, inProgress: useMatch.getState().inProgress, curCalValid, calState });
      }
    } catch (e) {}
  }

  function undoPoint() {
    const pts = dstPoints.slice(0, -1);
    setDstPoints(pts);
    drawOverlay(pts);
  }

  function refinePoints() {
    if (!canvasRef.current || dstPoints.length === 0) return;
    const refined = refinePointsSobel(canvasRef.current, dstPoints, 8);
    setDstPoints(refined);
    drawOverlay(refined);
  }

  function compute() {
    if (!canvasRef.current) return false;
    if (dstPoints.length < REQUIRED_POINT_COUNT) {
      alert(
        "Please click all 5 calibration points: D20, D6, D3, D11, and Bullseye (center).",
      );
      return false;
    }
    try {
  const src = canonicalRimTargets("outer"); // board space mm
      // Use all 5 points (including bullseye) for better accuracy
      // Ensure we have exactly 5 points for the homography calculation to match src
      const dst = dstPoints.slice(0, 5);
      
      const Hcalc = computeHomographyDLT(src, dst);
      drawOverlay(dstPoints, Hcalc);
      const err = rmsError(Hcalc, src, dst);
      const overlaySize = overlayRef?.current
        ? { w: overlayRef.current.width, h: overlayRef.current.height }
        : videoRef?.current
        ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
        : { w: canvasRef.current.width, h: canvasRef.current.height };
      
      // Use actual video frame dimensions for imageSize, not canvas display dimensions
      // This ensures correct scaling when CameraView draws the video to its own canvas
      const actualImageSize = videoRef.current
        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }
        : { w: canvasRef.current.width, h: canvasRef.current.height };

      setCalibration({
        H: Hcalc as Homography,
        createdAt: Date.now(),
        errorPx: err,
        imageSize: actualImageSize,
        overlaySize,
        anchors: { src, dst: dstPoints }, // Save all points including any extras
      });
      setConfidence(100);
      setPhase("computed");
      return true;
    } catch (e) {
      console.error("[Calibrator] Compute failed:", e);
      alert("Calibration computation failed. Please try resetting points.");
      return false;
    }
  }

  function runVerification() {
    if (!H || !overlayRef.current) {
      alert("Please compute calibration first (lock) before running verification.");
      return;
    }
    // Prefer using the locked anchors from calibration store if available, to ensure we verify what was actually computed
    const pointsToVerify = (anchors?.dst && anchors.dst.length >= 4) ? anchors.dst : dstPoints;

    if (pointsToVerify.length < 4) {
      alert("Select at least the four double-ring anchors before running verification.");
      return;
    }
    const overlayCanvas = overlayRef.current;
    const ctx = overlayCanvas.getContext("2d");
    if (!ctx) {
      console.warn("[Calibrator] Overlay context missing for verification");
      return;
    }
    drawOverlay(pointsToVerify, H);
  const canonicalTargets = canonicalRimTargets("outer");
    const results: VerificationResult[] = VERIFICATION_ANCHORS.map((anchor) => {
      const actualPoint = pointsToVerify[anchor.idx];
      const expectedBoard = canonicalTargets[anchor.idx];
      if (!actualPoint || !expectedBoard) {
        return {
          label: anchor.label,
          expected: { ring: anchor.ring, sector: anchor.sector },
          detected: null,
          deltaMm: null,
          deltaPx: null,
          match: false,
          note: "Point missing â€” click this anchor to verify",
        };
      }
      const projectedImage = applyHomography(H as any, expectedBoard);
      const boardFromActual = imageToBoard(H as any, actualPoint);
      if (!boardFromActual) {
        // If homography inversion failed, treat as mismatch
        return {
          label: anchor.label,
          expected: { ring: anchor.ring, sector: anchor.sector },
          detected: null,
          deltaMm: null,
          deltaPx: null,
          match: false,
          note: "Homography inversion failed - recalibrate",
        };
      }
  const detectedScore = scoreAtBoardPointTheta(boardFromActual, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0);
      const deltaMm = Math.hypot(
        boardFromActual.x - expectedBoard.x,
        boardFromActual.y - expectedBoard.y,
      );
      const deltaPx = Math.hypot(
        actualPoint.x - projectedImage.x,
        actualPoint.y - projectedImage.y,
      );
      const ringMatch =
        anchor.ring === "INNER_BULL"
          ? detectedScore.ring === "INNER_BULL" || detectedScore.ring === "BULL"
          : detectedScore.ring === anchor.ring;
      const sectorMatch =
        anchor.sector == null || detectedScore.sector === anchor.sector;
      const withinTolerance = deltaMm <= anchor.toleranceMm;
      const match = ringMatch && sectorMatch && withinTolerance;
      
      // Detailed logging for debugging tolerance mismatch
      console.log(`[Verification] ${anchor.label}:`, {
        anchor: anchor,
        actualPoint: { x: actualPoint.x.toFixed(1), y: actualPoint.y.toFixed(1) },
        expectedBoard: { x: expectedBoard.x.toFixed(2), y: expectedBoard.y.toFixed(2) },
        projectedImage: { x: projectedImage.x.toFixed(1), y: projectedImage.y.toFixed(1) },
        boardFromActual: { x: boardFromActual.x.toFixed(2), y: boardFromActual.y.toFixed(2) },
        detectedScore: detectedScore,
        deltaMm: deltaMm.toFixed(2),
        deltaPx: deltaPx.toFixed(1),
        toleranceMm: anchor.toleranceMm,
        ringMatch,
        sectorMatch,
        withinTolerance,
        match,
      });
      
      drawCross(ctx, actualPoint, match ? "#10b981" : "#ef4444");
      ctx.save();
      ctx.fillStyle = match ? "#10b981" : "#ef4444";
      ctx.font = "12px sans-serif";
      ctx.fillText(
        `${anchor.label} Â· ${deltaMm.toFixed(1)}mm`,
        actualPoint.x + 6,
        actualPoint.y - 6,
      );
      ctx.restore();
      let note: string | undefined;
      if (!ringMatch || !sectorMatch) {
        note = "Sector/ring mismatch";
      } else if (!withinTolerance) {
        note = `Off by ${deltaMm.toFixed(1)}mm (limit Â±${anchor.toleranceMm}mm)`;
      }
      return {
        label: anchor.label,
        expected: { ring: anchor.ring, sector: anchor.sector },
        detected: detectedScore,
        deltaMm,
        deltaPx,
        match,
        note,
      };
    });
    setVerificationResults(results);
    console.log(`[Calibrator] Verification complete:`, results);
    // Trigger PASS/FAIL flash for user feedback
    const allPass = results.every(r => r.match);
    triggerFlash(allPass, 1500);
  }

  // Auto-resize the board - AGGRESSIVE: Recompute homography directly from all 5 points
  async function autoResizeBoard() {
    if (!H) {
      alert("Please save the calibration first (click Save).");
      return;
    }
    
    if (verificationResults.length === 0) {
      console.log("[Calibrator] Verification not run yet, running now before resize...");
      runVerification();
      await new Promise(resolve => setTimeout(resolve, 100));
    }

  const canonicalTargets = canonicalRimTargets("outer");
    const pointsToVerify = (anchors?.dst && anchors.dst.length >= 4) ? anchors.dst : dstPoints;

    if (pointsToVerify.length < 5) {
      alert("Need at least 5 calibration points to resize.");
      return;
    }

    console.log(`[Calibrator] Starting AGGRESSIVE resize: Recomputing homography from all 5 points`);
    
    // NUCLEAR OPTION: Recompute homography using all 5 points directly
    // This forces the homography to map the clicked points to the expected board positions
    const src = canonicalTargets.slice(0, 5); // Expected board positions (in mm)
    const dst = pointsToVerify.slice(0, 5);   // Actual clicked image positions
    
    try {
      // Recompute homography using DLT (Direct Linear Transform)
      // This will find the H that best fits all 5 points
      const newH = computeHomographyDLT(src, dst);
      
      console.log(`[Calibrator] Recomputed homography from 5 points`);
      
      // Verify the new homography
      const verifyResults = VERIFICATION_ANCHORS.map((anchor) => {
        const actualPoint = pointsToVerify[anchor.idx];
        const expectedBoard = canonicalTargets[anchor.idx];
        if (!actualPoint || !expectedBoard) {
          return { match: false, deltaMm: null, ringMatch: false, sectorMatch: false };
        }
        const boardFromActual = imageToBoard(newH as any, actualPoint);
        if (!boardFromActual) {
          return { match: false, deltaMm: null, ringMatch: false, sectorMatch: false };
        }
  const detectedScore = scoreAtBoardPointTheta(boardFromActual, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0);
        const deltaMm = Math.hypot(
          boardFromActual.x - expectedBoard.x,
          boardFromActual.y - expectedBoard.y,
        );
        const ringMatch =
          anchor.ring === "INNER_BULL"
            ? detectedScore.ring === "INNER_BULL" || detectedScore.ring === "BULL"
            : detectedScore.ring === anchor.ring;
        const sectorMatch =
          anchor.sector == null || detectedScore.sector === anchor.sector;
        const withinTolerance = deltaMm <= anchor.toleranceMm;
        const match = ringMatch && sectorMatch && withinTolerance;
        
        console.log(`  Anchor ${anchor.label}: ring=${ringMatch}, sector=${sectorMatch}, deltaMm=${deltaMm.toFixed(2)}`);
        return { match, deltaMm, ringMatch, sectorMatch, detectedScore, expectedBoard };
      });

      const passCount = verifyResults.filter(r => r.match).length;
      const totalCount = verifyResults.length;

      console.log(`[Calibrator] Result: ${passCount}/${totalCount} anchors pass`);

      // Save the recalibrated homography
      const overlaySize = overlayRef?.current
        ? { w: overlayRef.current.width, h: overlayRef.current.height }
        : videoRef?.current
        ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
        : { w: canvasRef.current!.width, h: canvasRef.current!.height };
      
      const actualImageSize = videoRef.current
        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }
        : { w: canvasRef.current!.width, h: canvasRef.current!.height };

      const err = rmsError(newH, src, dst);
      setCalibration({
        H: newH,
        createdAt: Date.now(),
        errorPx: err,
        imageSize: actualImageSize,
        overlaySize,
        anchors: { src, dst },
      });

      drawOverlay(pointsToVerify, newH);
      runVerificationWithH(newH);
      
      if (passCount === totalCount) {
        console.log(`[Calibrator] âœ… PERFECT! All 5 anchors pass!`);
        alert(`âœ… PERFECT CALIBRATION!\n\nAll 5 anchors pass! Your dartboard is perfectly calibrated.`);
      } else {
        console.warn(`[Calibrator] Only ${passCount}/5 anchors pass. Anchors may be clicked incorrectly.`);
        alert(`âš ï¸ Resize Result: ${passCount}/5 anchors pass.\n\nThe anchors showing red "Adjust" may have been clicked on the wrong ring.\n\nPlease re-click those anchors more carefully, then try Resize again.`);
      }

    } catch (e) {
      console.error(`[Calibrator] Error recomputing homography:`, e);
      alert(`âŒ Error: Could not recompute calibration.\n\nYour anchor clicks may be invalid.\n\nPlease recalibrate from scratch.`);
    }
  }

  // Helper function to run verification with a specific homography
  function runVerificationWithH(verifyH: Homography) {
  const canonicalTargets = canonicalRimTargets("outer");
    const pointsToVerify = (anchors?.dst && anchors.dst.length >= 4) ? anchors.dst : dstPoints;

    if (pointsToVerify.length < 4) return;

    const results: VerificationResult[] = VERIFICATION_ANCHORS.map((anchor) => {
      const actualPoint = pointsToVerify[anchor.idx];
      const expectedBoard = canonicalTargets[anchor.idx];
      if (!actualPoint || !expectedBoard) {
        return {
          label: anchor.label,
          expected: { ring: anchor.ring, sector: anchor.sector },
          detected: null,
          deltaMm: null,
          deltaPx: null,
          match: false,
          note: "Point missing â€” click this anchor to verify",
        };
      }
      const projectedImage = applyHomography(verifyH, expectedBoard);
      const boardFromActual = imageToBoard(verifyH as any, actualPoint);
      if (!boardFromActual) {
        // If homography inversion failed, treat as mismatch
        return {
          label: anchor.label,
          expected: { ring: anchor.ring, sector: anchor.sector },
          detected: null,
          deltaMm: null,
          deltaPx: null,
          match: false,
          note: "Homography inversion failed - recalibrate",
        };
      }
  const detectedScore = scoreAtBoardPointTheta(boardFromActual, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0);
      const deltaMm = Math.hypot(
        boardFromActual.x - expectedBoard.x,
        boardFromActual.y - expectedBoard.y,
      );
      const deltaPx = Math.hypot(
        actualPoint.x - projectedImage.x,
        actualPoint.y - projectedImage.y,
      );
      const ringMatch =
        anchor.ring === "INNER_BULL"
          ? detectedScore.ring === "INNER_BULL" || detectedScore.ring === "BULL"
          : detectedScore.ring === anchor.ring;
      const sectorMatch =
        anchor.sector == null || detectedScore.sector === anchor.sector;
      const withinTolerance = deltaMm <= anchor.toleranceMm;
      const match = ringMatch && sectorMatch && withinTolerance;

      let note: string | undefined;
      if (!ringMatch || !sectorMatch) {
        note = "Sector/ring mismatch";
      } else if (!withinTolerance) {
        note = `Off by ${deltaMm.toFixed(1)}mm (limit Â±${anchor.toleranceMm}mm)`;
      }

      const result = {
        label: anchor.label,
        expected: { ring: anchor.ring, sector: anchor.sector },
        detected: detectedScore,
        deltaMm,
        deltaPx,
        match,
        note,
      } as VerificationResult;
      return result;
    });

    // Auto-estimate sectorOffset if there is a consistent whole-sector mismatch
    try {
      const diffs: number[] = [];
      for (const r of results) {
        if (r.expected.ring === "DOUBLE" && r.expected.sector != null && r.detected?.sector != null) {
          const expected = r.expected.sector as number;
          const detected = r.detected.sector as number;
          const expIdx = SectorOrder.indexOf(expected);
          const detIdx = SectorOrder.indexOf(detected);
          if (expIdx >= 0 && detIdx >= 0) {
            let diff = detIdx - expIdx;
            if (diff > 10) diff -= 20;
            if (diff < -10) diff += 20;
            diffs.push(diff);
          }
        }
      }
      if (diffs.length >= 3) {
        const counts = new Map<number, number>();
        for (const d of diffs) counts.set(d, (counts.get(d) ?? 0) + 1);
        let best = 0, bestN = 0;
        for (const [d, n] of counts.entries()) {
          if (n > bestN) { bestN = n; best = d; }
        }
        const current = sectorOffset ?? 0;
        if (bestN >= 2 && best !== current) {
          setCalibration({ sectorOffset: best });
        }
      }
    } catch {}

    setVerificationResults(results);
  }

  function resetAll() {
    setDstPoints([]);
    setHasSnapshot(false);
    setPhase("camera");
    drawOverlay([]);
    setMarkerResult(null);
    reset();
  }

  // --- Auto-detect the double rim from the current snapshot and compute homography ---
  async function autoDetectRings() {
    try {
      console.debug('[Calibrator] autoDetectRings invoked');
      if (!canvasRef.current) {
        alert("Load a photo or capture a frame first.");
        setAutoCalibrating(false);
        return;
      }
      const testAutoDetectResult = (globalThis as any).__TEST_AUTO_DETECT_RESULT as
        | TestAutoDetectResult
        | undefined;
      if (testAutoDetectResult) {
        console.debug('[Calibrator] testAutoDetectResult detected (legacy)');
        applyTestAutoDetectResult(testAutoDetectResult);
        return;
      }
      setAutoCalibrating(true);
      setDetectionMessage("Using advanced detection algorithm...");
      setMarkerResult(null);
      
      // Use the advanced detectBoard algorithm instead of the legacy circle search
      // The legacy algorithm is not robust enough for various lighting conditions
  const refined = detectBoard(canvasRef.current!, bullHint ? { centerHint: bullHint, colorAssist: true } : { colorAssist: true });
      
      console.log(
        "[Calibrator] detectBoard returned:",
        {
          success: refined.success,
          confidence: refined.confidence,
          hasHomography: !!refined.homography,
          numPoints: refined.calibrationPoints.length,
        },
        refined.message,
      );
      
      if (!refined.success || !refined.homography || refined.confidence < 40) {
        console.warn("[Calibrator] Auto-detect failed, result:", {
          success: refined.success,
          confidence: refined.confidence,
          hasHomography: !!refined.homography,
        });
        setDetectionMessage(
          refined.message ||
          "âŒ Detection failed. Try better lighting or different angle.",
        );
        setAutoCalibrating(false);
        return;
      }
      
      // Apply detection results
  setDetected({
        cx: refined.cx,
        cy: refined.cy,
        bullInner: refined.bullInner,
        bullOuter: refined.bullOuter,
        trebleInner: refined.trebleInner,
        trebleOuter: refined.trebleOuter,
        doubleInner: refined.doubleInner,
        doubleOuter: refined.doubleOuter,
      });
  // Auto-enable forced detected-only overlay to let the user see the detected circles immediately
  setForceDetectedOnly(true);
      setDstPoints(refined.calibrationPoints);
      drawOverlay(refined.calibrationPoints, refined.homography);
      
      // Store calibration
      const overlaySize = overlayRef?.current
        ? { w: overlayRef.current.width, h: overlayRef.current.height }
        : videoRef?.current
        ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
        : { w: canvasRef.current.width, h: canvasRef.current.height };
      const actualImageSize = videoRef.current
        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }
        : { w: canvasRef.current.width, h: canvasRef.current.height };
      
      // Auto-estimate sector offset from homography so 20 aligns to top
      const autoOffset = estimateSectorOffsetFromHomography(refined.homography, "outer");
      
      setCalibration({
        H: refined.homography as Homography,
        createdAt: Date.now(),
        errorPx: refined.errorPx ?? null,
        imageSize: actualImageSize,
        overlaySize,
        anchors: {
          src: canonicalRimTargets("outer").slice(0, 4),
          dst: refined.calibrationPoints,
        },
        theta: typeof refined.theta === "number" ? refined.theta : null,
        sectorOffset: autoOffset,
      });
      
      // Verify that detected rings match the actual board
      const verificationResults = verifyCalibration(refined.homography as Homography, refined.calibrationPoints);
      setVerificationResults(verificationResults);
      
      setPhase("verify");
      setConfidence(forceConfidence ? 100 : Math.round(refined.confidence));
      setDetectionMessage(`âœ… Detected rings â€” Please verify alignment by looking at the overlay`);
      setAutoCalibrating(false);
      
      // Validate stability
      try {
        const runs = 3;
        let stableCount = 1;
        for (let i = 1; i < runs; i++) {
          const tmp = document.createElement("canvas");
          tmp.width = Math.max(1, Math.round(canvasRef.current!.width * 0.9));
          tmp.height = Math.max(1, Math.round(canvasRef.current!.height * 0.9));
          const tctx = tmp.getContext("2d")!;
          tctx.drawImage(canvasRef.current!, 0, 0, tmp.width, tmp.height);
          const hintScaledA = bullHint ? { centerHint: { x: bullHint.x * 0.9, y: bullHint.y * 0.9 }, colorAssist: true } : { colorAssist: true };
          const bd = detectBoard(tmp as any as HTMLCanvasElement, hintScaledA);
          if (isSimilarDetection(refined as any, bd as any)) stableCount++;
        }
        const stable = stableCount >= Math.ceil(runs * 0.66);
        if (stable) {
          // Don't auto-lock yet - let user verify first
          console.log("[Calibrator] Detection is stable");
        }
      } catch (err) {
        console.warn("[Calibrator] Legacy stability check failed:", err);
      }
    } catch (err) {
      console.error("[Calibrator] autoDetectRings failed:", err);
      setDetectionMessage(`âŒ Auto-detect failed: ${err instanceof Error ? err.message : String(err)}`);
      setAutoCalibrating(false);
    }
  }

  // Verify that auto-detected calibration matches the actual dartboard
  function verifyCalibration(H: Homography, calibrationPoints: Point[]): VerificationResult[] {
    const results: VerificationResult[] = [];
    
    if (!H || !calibrationPoints || calibrationPoints.length === 0) {
      return results;
    }

    // Check each verification anchor point
    for (const anchor of VERIFICATION_ANCHORS) {
      if (anchor.idx >= calibrationPoints.length) continue;
      
      const imgPoint = calibrationPoints[anchor.idx];
      let boardPoint: Point | null = null;
      
      try {
        boardPoint = imageToBoard(H, imgPoint);
      } catch (err) {
        console.warn("[Calibrator] Failed to convert image point to board space:", err);
      }
      
      let detectedScore: ScoreInfo | null = null;
      let deltaMm = null;
      let deltaPx = null;
      let match = false;
      
      if (boardPoint) {
        try {
          detectedScore = scoreAtBoardPointTheta(boardPoint, (typeof theta === "number" ? theta : 0), sectorOffset ?? 0);
          
          // Calculate distance from expected ring
          if (detectedScore.ring === anchor.ring && detectedScore.sector === anchor.sector) {
            match = true;
            deltaMm = 0;
          } else {
            // Calculate Euclidean distance in mm from detected point to expected ring
            const expectedRadius = BoardRadii[anchor.ring === "DOUBLE" ? "doubleOuter" : 
                                                anchor.ring === "INNER_BULL" ? "bullInner" : 
                                                anchor.ring === "BULL" ? "bullOuter" : "doubleOuter"];
            const actualRadius = Math.hypot(boardPoint.x, boardPoint.y);
            deltaMm = Math.abs(actualRadius - expectedRadius);
            deltaPx = Math.hypot(imgPoint.x - (detected?.cx ?? 0), imgPoint.y - (detected?.cy ?? 0));
            match = deltaMm <= anchor.toleranceMm;
          }
        } catch (err) {
          console.warn("[Calibrator] Failed to score detected point:", err);
        }
      }
      
      results.push({
        label: anchor.label,
        expected: { ring: anchor.ring, sector: anchor.sector },
        detected: detectedScore,
        deltaMm,
        deltaPx,
        match,
        note: match ? "âœ… OK" : `âŒ Off by ${deltaMm?.toFixed(1)}mm`,
      });
    }
    
    return results;
  }

  // Helper: refine detection stability by running the same ring detection a few times and ensure values are close
  function isSimilarDetection(a: any, b: any, tol = 0.03) {
    if (!a || !b) return false;
    const dx = Math.abs((a.cx - b.cx) / (a.cx || 1));
    const dy = Math.abs((a.cy - b.cy) / (a.cy || 1));
    const dr = Math.abs((a.doubleOuter - b.doubleOuter) / (a.doubleOuter || 1));
    return dx <= tol && dy <= tol && dr <= tol;
  }

  const workerRef = useRef<Worker | null>(null);
  useEffect(() => {
    if (isTestEnv) {
      workerRef.current = null;
      return;
    }
    let w: Worker | null = null;
    try {
      w = new Worker(
        new URL("../workers/boardDetection.worker.ts", import.meta.url),
        { type: "module" } as any,
      );
      workerRef.current = w;
      console.log("[Calibrator] Board detection worker created");
    } catch (err) {
      console.warn(
        "[Calibrator] Failed to create board detection worker, will fallback to main thread: ",
        err,
      );
      workerRef.current = null;
    }
    return () => {
      try {
        w?.terminate();
      } catch {}
    };
  }, []);

  // Advanced auto-calibration: detect board features without markers or manual clicking
  async function autoCalibrate() {
    if (!canvasRef.current) {
      alert("Capture a frame or upload a photo first.");
      return;
    }
    const testAutoDetectResult = (globalThis as any).__TEST_AUTO_DETECT_RESULT as
      | TestAutoDetectResult
      | undefined;
    if (testAutoDetectResult) {
      applyTestAutoDetectResult(testAutoDetectResult);
      return;
    }
    // If worker is available, use it; otherwise fall back to synchronous detection
    if (workerRef.current) {
      setAutoCalibrating(true);
      let bitmap: ImageBitmap | null = null;
      try {
        bitmap = await createImageBitmap(canvasRef.current);
      } catch (err) {
        console.warn(
          "[Calibrator] createImageBitmap failed; falling back to main thread detection",
          err,
        );
        bitmap = null;
      }
      if (!bitmap) {
        setAutoCalibrating(false);
        // fallback: run sync detection
        return autoCalibrateSync();
      }
      try {
        const worker = workerRef.current;
        if (!worker) return autoCalibrateSync();
        return new Promise<void>((resolve) => {
          // eslint-disable-next-line prefer-const
          let timeoutId: ReturnType<typeof setTimeout> | undefined;
          const onMessage = async (ev: MessageEvent) => {
            try {
              if (ev.data && ev.data.error) {
                const errMsg = ev.data.error || "Auto-calibration failed";
                alert(`Auto-calibration failed: ${errMsg}`);
                setDetectionMessage(errMsg);
                setAutoCalibrating(false);
                if (timeoutId) clearTimeout(timeoutId);
                worker.removeEventListener("message", onMessage);
                resolve();
                return;
              }
              if (ev.data && ev.data.type === "result") {
                const boardDetection = ev.data
                  .detection as BoardDetectionResult;
                // Respect forceConfidence
                if (forceConfidence) boardDetection.confidence = 100;
                // If we have missing homography, try to compute a homography from detected points
                if (
                    (!boardDetection.homography ||
                      !Array.isArray(boardDetection.calibrationPoints) ||
                      boardDetection.calibrationPoints.length < 4)
                  ) {
                  const points = boardDetection.calibrationPoints || [];
                    if (points.length >= 4) {
                    const canonicalSrc = [
                      { x: 0, y: -BoardRadii.doubleOuter },
                      { x: BoardRadii.doubleOuter, y: 0 },
                      { x: 0, y: BoardRadii.doubleOuter },
                      { x: -BoardRadii.doubleOuter, y: 0 },
                    ];
                    try {
                      const H = computeHomographyDLT(
                        canonicalSrc,
                        points.slice(0, 4),
                      );
                      boardDetection.homography = H;
                      boardDetection.errorPx = rmsError(
                        H,
                        canonicalSrc,
                        points.slice(0, 4),
                      );
                    } catch (err) {
                      console.warn(
                          "[Calibrator] Worker homography compute failed",
                        err,
                      );
                    }
                  }
                }
                if (
                  !boardDetection.success ||
                  !boardDetection.homography ||
                  (!forceConfidence && boardDetection.confidence < 40)
                ) {
                  alert(
                    `âŒ Board Detection Failed\n\nConfidence: ${Math.round(boardDetection.confidence)}%\n\n${boardDetection.message}\n\nTry:\nâ€¢ Better lighting\nâ€¢ Closer camera angle\nâ€¢ Make sure entire board is visible\nâ€¢ Use manual calibration instead (click the 4 double-ring points: D20, D6, D3, D11)`,
                  );
                  setAutoCalibrating(false);
                  if (timeoutId) clearTimeout(timeoutId);
                  worker.removeEventListener("message", onMessage);
                  resolve();
                  return;
                }
                // Apply the calibration
                setDetected({
                  cx: boardDetection.cx,
                  cy: boardDetection.cy,
                  bullInner: boardDetection.bullInner,
                  bullOuter: boardDetection.bullOuter,
                  trebleInner: boardDetection.trebleInner,
                  trebleOuter: boardDetection.trebleOuter,
                  doubleInner: boardDetection.doubleInner,
                  doubleOuter: boardDetection.doubleOuter,
                });
                setDstPoints(boardDetection.calibrationPoints);
                console.log('[Calibrator] Auto-detect: Drawing overlay at detected center (', 
                  Math.round(boardDetection.cx), ',', Math.round(boardDetection.cy), 
                  ') with calibration points:', 
                  boardDetection.calibrationPoints.map(p => `(${Math.round(p.x)},${Math.round(p.y)})`).join(' ')
                );
                drawOverlay(
                  boardDetection.calibrationPoints,
                  boardDetection.homography,
                );
                let shouldLock =
                  (boardDetection.errorPx ?? Number.POSITIVE_INFINITY) <= 2.0;
                // Validate detection stability by rerunning local detection a couple times
                // WITH YIELDS to prevent UI freeze
                try {
                  let stableCount2 = 1;
                  const runs2 = 3;
                  for (let i = 1; i < runs2; i++) {
                    // Yield before each stability check
                    await new Promise(resolveYield => setTimeout(resolveYield, 0));
                    
                    const small = document.createElement("canvas");
                    small.width = Math.max(1, Math.round(canvasRef.current!.width * 0.8));
                    small.height = Math.max(1, Math.round(canvasRef.current!.height * 0.8));
                    const sctx = small.getContext("2d")!;
                    sctx.drawImage(canvasRef.current!, 0, 0, small.width, small.height);
                    const scaleSmall = small.width / canvasRef.current!.width;
                    const hintScaledSmall = bullHint ? { centerHint: { x: bullHint.x * scaleSmall, y: bullHint.y * scaleSmall } } : undefined;
                    const bd2 = detectBoard(small as any as HTMLCanvasElement, hintScaledSmall);
                    if (isSimilarDetection(boardDetection as any, bd2 as any)) stableCount2++;
                  }
                  const stable2 = stableCount2 >= Math.ceil(runs2 * 0.66);
                  shouldLock = shouldLock && stable2;
                } catch (err) {
                  // ignore stability failures
                }
                const overlaySize = overlayRef?.current
                  ? { w: overlayRef.current.width, h: overlayRef.current.height }
                  : videoRef?.current
                  ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
                  : { w: canvasRef.current?.width ?? 0, h: canvasRef.current?.height ?? 0 };
                setCalibration({
                  H: boardDetection.homography as Homography,
                  createdAt: Date.now(),
                  errorPx: boardDetection.errorPx ?? null,
                  imageSize: {
                    w: canvasRef.current?.width ?? 0,
                    h: canvasRef.current?.height ?? 0,
                  },
                  overlaySize,
                  anchors: {
                    src: canonicalRimTargets("outer").slice(0, 4),
                    dst: boardDetection.calibrationPoints,
                  },
                  locked: shouldLock ? true : locked,
                });
                setDetectionMessage(boardDetection.message ?? `Auto-calibration success (confidence ${Math.round(boardDetection.confidence)}%)`);
                setPhase("computed");
                setConfidence(
                  forceConfidence ? 100 : Math.round(boardDetection.confidence),
                );
                setCalibration({ errorPx: boardDetection.errorPx ?? null });
                setAutoCalibrating(false);
                worker.removeEventListener("message", onMessage);
                resolve();
                return;
              }
            } catch (err) {
              console.warn(
                "[Calibrator] Worker message processing failed",
                err,
              );
              setAutoCalibrating(false);
              worker.removeEventListener("message", onMessage);
              resolve();
              return;
            }
          };
          worker.addEventListener("message", onMessage);
          worker.postMessage({ type: "detect", bitmap }, [bitmap]);
          // safety timeout - fallback to sync after 8s
          timeoutId = setTimeout(() => {
            if (autoCalibrating) {
              console.warn(
                "[Calibrator] Worker timed out, attempting sync fallback",
              );
              setAutoCalibrating(false);
              if (timeoutId) clearTimeout(timeoutId);
              worker.removeEventListener("message", onMessage);
              autoCalibrateSync().catch(err => console.error("[Calibrator] Fallback sync detection failed:", err));
            }
          }, 8000);
        });
      } catch (err) {
        console.warn("[Calibrator] AutoCalibrate worker payload failed", err);
        setAutoCalibrating(false);
        return await autoCalibrateSync();
      }
    } else {
      return await autoCalibrateSync();
    }
  }

  // Asynchronous non-blocking fallback for autoCalibrate
  async function autoCalibrateSync() {
    try {
      setAutoCalibrating(true);
      
      // Yield to browser to show "Auto-calibrating..." state before heavy work
      await new Promise(resolve => setTimeout(resolve, 0));
      
  let boardDetection = detectBoard(canvasRef.current!, bullHint ? { centerHint: bullHint, colorAssist: true } : { colorAssist: true });
      boardDetection = refineRingDetection(boardDetection);
      if (forceConfidence) boardDetection.confidence = 100;
      
      // Yield again to keep UI responsive between detections
      await new Promise(resolve => setTimeout(resolve, 0));
      
      if (
        (!boardDetection.homography ||
          !Array.isArray(boardDetection.calibrationPoints) ||
          boardDetection.calibrationPoints.length < 4)
      ) {
        try {
          const points = boardDetection.calibrationPoints || [];
          if (points.length >= 4) {
            const canonicalSrc = [
              { x: 0, y: -BoardRadii.doubleOuter },
              { x: BoardRadii.doubleOuter, y: 0 },
              { x: 0, y: BoardRadii.doubleOuter },
              { x: -BoardRadii.doubleOuter, y: 0 },
            ];
            const H = computeHomographyDLT(canonicalSrc, points.slice(0, 4));
            boardDetection.homography = H;
            boardDetection.errorPx = rmsError(
              H,
              canonicalSrc,
              points.slice(0, 4),
            );
          }
        } catch (err) {
          console.warn("[Calibrator] sync forced homography compute failed", err);
        }
      }
      
      // Try multi-scale detection attempts - with yields to prevent freezing
      if (
        !boardDetection.success ||
        !boardDetection.homography ||
        (!forceConfidence && boardDetection.confidence < 50)
      ) {
        const scales = [0.9, 0.8, 1.1, 1.2];
        for (const scale of scales) {
          try {
            // Yield before each scale attempt
            await new Promise(resolve => setTimeout(resolve, 0));
            
            const srcCanvas = canvasRef.current!;
            const tmp = document.createElement('canvas');
            tmp.width = Math.max(1, Math.round(srcCanvas.width * scale));
            tmp.height = Math.max(1, Math.round(srcCanvas.height * scale));
            const tctx = tmp.getContext('2d');
            if (!tctx) continue;
            tctx.drawImage(srcCanvas, 0, 0, tmp.width, tmp.height);
            // Scale bull hint into the resized tmp space if available
            const hintScaled = bullHint ? { centerHint: { x: bullHint.x * scale, y: bullHint.y * scale }, colorAssist: true } : { colorAssist: true };
            let bd = detectBoard(tmp as any as HTMLCanvasElement, hintScaled);
            bd = refineRingDetection(bd);
            if (bd.success && bd.homography) {
              // Scale found points back to original coordinate space
              const invScale = 1 / scale;
              bd.cx *= invScale;
              bd.cy *= invScale;
              bd.bullInner *= invScale;
              bd.bullOuter *= invScale;
              bd.trebleInner *= invScale;
              bd.trebleOuter *= invScale;
              bd.doubleInner *= invScale;
              bd.doubleOuter *= invScale;
              bd.calibrationPoints = bd.calibrationPoints.map((p) => ({ x: p.x * invScale, y: p.y * invScale }));
              boardDetection = bd;
              break;
            }
          } catch (err) {
            // continue on error
          }
        }
      }
      
      // Re-run the post-success checks after potential multi-scale detection
      if (
        !boardDetection.success ||
        !boardDetection.homography ||
        (!forceConfidence && boardDetection.confidence < 50)
      ) {
        alert(
          `âŒ Board Detection Failed\n\nConfidence: ${Math.round(boardDetection.confidence)}%\n\n${boardDetection.message}\n\nTry:\nâ€¢ Better lighting\nâ€¢ Closer camera angle\nâ€¢ Make sure entire board is visible\nâ€¢ Use manual calibration instead (click the 4 double-ring points: D20, D6, D3, D11)`,
        );
        setDetectionMessage(boardDetection.message ?? null);
        setAutoCalibrating(false);
        return;
      }
      
      // Yield before applying detection to UI
      await new Promise(resolve => setTimeout(resolve, 0));
      
      // Apply detection (same as worker result processing)
      setDetected({
        cx: boardDetection.cx,
        cy: boardDetection.cy,
        bullInner: boardDetection.bullInner,
        bullOuter: boardDetection.bullOuter,
        trebleInner: boardDetection.trebleInner,
        trebleOuter: boardDetection.trebleOuter,
        doubleInner: boardDetection.doubleInner,
        doubleOuter: boardDetection.doubleOuter,
      });
      setDstPoints(boardDetection.calibrationPoints);
      drawOverlay(boardDetection.calibrationPoints, boardDetection.homography);
      
      // Check stability of the detection across quick re-runs - with yields
      const baseCheck = (boardDetection.errorPx ?? Number.POSITIVE_INFINITY) <= 2.0;
      let stabilityCount = 1;
      const stabilityRuns = 3;
      for (let i = 1; i < stabilityRuns; i++) {
        try {
          // Yield before stability check
          await new Promise(resolve => setTimeout(resolve, 0));
          
          const tmp = document.createElement("canvas");
          tmp.width = Math.max(1, Math.round(canvasRef.current!.width * 0.9));
          tmp.height = Math.max(1, Math.round(canvasRef.current!.height * 0.9));
          const tctx = tmp.getContext("2d")!;
          tctx.drawImage(canvasRef.current!, 0, 0, tmp.width, tmp.height);
          const hintScaled2 = bullHint ? { centerHint: { x: bullHint.x * 0.9, y: bullHint.y * 0.9 }, colorAssist: true } : { colorAssist: true };
          const bd2 = detectBoard(tmp as any as HTMLCanvasElement, hintScaled2);
          if (isSimilarDetection(boardDetection as any, bd2 as any)) stabilityCount++;
        } catch (err) {
          // ignore
        }
      }
      const stable = stabilityCount >= Math.ceil(stabilityRuns * 0.66);
      const shouldLock = baseCheck && stable;
      const overlaySize = overlayRef?.current
        ? { w: overlayRef.current.width, h: overlayRef.current.height }
        : videoRef?.current
        ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
        : { w: canvasRef.current!.width, h: canvasRef.current!.height };
      // Use actual video frame dimensions for imageSize, not canvas display dimensions
      const actualImageSize = videoRef.current
        ? { w: videoRef.current.videoWidth, h: videoRef.current.videoHeight }
        : { w: canvasRef.current!.width, h: canvasRef.current!.height };
      
      // Auto-estimate sector offset from homography so 20 aligns to top
      const autoOffset = estimateSectorOffsetFromHomography(boardDetection.homography as Homography, "outer");
      
      setCalibration({
        H: boardDetection.homography as Homography,
        createdAt: Date.now(),
        errorPx: boardDetection.errorPx ?? null,
        imageSize: actualImageSize,
        overlaySize,
        anchors: {
          // Match black outline guide: calibrate using the double OUTER rim
          src: canonicalRimTargets("outer").slice(0, 4),
          dst: boardDetection.calibrationPoints,
        },
        locked: shouldLock ? true : locked,
        theta: boardDetection.theta,
        sectorOffset: autoOffset,
      });
      setPhase("computed");
      setConfidence(
        forceConfidence ? 100 : Math.round(boardDetection.confidence),
      );
      setCalibration({ errorPx: boardDetection.errorPx ?? null });
      setDetectionMessage(boardDetection.message ?? null);
      setAutoCalibrating(false);
    } catch (err) {
      console.error("[Calibrator] autoCalibrateSync failed:", err);
      const errorMsg = err instanceof Error ? err.message : String(err);
      setDetectionMessage(`âŒ Auto-calibration failed: ${errorMsg}`);
      setAutoCalibrating(false);
    }
  }

  function detectMarkers() {
    if (!canvasRef.current)
      return alert("Capture a frame or upload a photo first.");
    const result = detectMarkersFromCanvas(canvasRef.current);
    setMarkerResult(result);
    if (!result.success || !result.homography) {
      const missingMsg = result.missing.length
        ? ` Missing markers: ${result.missing.map((k) => `${k.toUpperCase()} (ID ${MARKER_TARGETS[k]})`).join(", ")}`
        : "";
      const foundMsg =
        result.markersFound.length > 0
          ? `\n\nDetected ${result.markersFound.length} markers with IDs: ${result.markersFound.map((m) => m.id).join(", ")}`
          : "\n\nNo markers detected. Make sure markers are on white paper, fully visible, and well-lit.";
      const fullMsg = `${result.message}${missingMsg}${foundMsg}\n\nYou can still use manual calibration: click the 4 double-ring points (D20, D6, D3, D11).`;
      alert(fullMsg);
      return;
    }
    setDetected(null);
    setDstPoints(result.points);
    drawOverlay(result.points, result.homography);
  const src = canonicalRimTargets("outer");
    const imageSize = {
      w: canvasRef.current.width,
      h: canvasRef.current.height,
    };
    const overlaySize = overlayRef?.current
      ? { w: overlayRef.current.width, h: overlayRef.current.height }
      : videoRef?.current
      ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
      : { w: canvasRef.current.width, h: canvasRef.current.height };
    const shouldLock = (result.errorPx ?? Number.POSITIVE_INFINITY) <= 1.2;
    setCalibration({
      H: result.homography as Homography,
      createdAt: Date.now(),
      errorPx: result.errorPx ?? null,
      imageSize,
      overlaySize,
      anchors: { src, dst: result.points },
      locked: shouldLock ? true : locked,
    });
    setPhase("computed");
  }

  useEffect(() => {
    drawOverlay();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hasSnapshot, H, correctionSx, correctionTx, correctionTy]);

  // Live detection loop (runs only when streaming and liveDetect is on)
  useEffect(() => {
    if (!liveDetect || !streaming) return;
    let raf = 0;
    const tick = () => {
      try {
        captureFrame();
      } catch {}
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [liveDetect, streaming]);

  // When calibration is locked and we have a pairing code, publish calibration to server
  useEffect(() => {
    (async () => {
      try {
        if (!locked || !pairCode) return;
        // Build a compact calibration payload including current canvas size if available
        const imgSize = canvasRef.current
          ? { w: canvasRef.current.width, h: canvasRef.current.height }
          : null;
        const bodyStr = JSON.stringify({
          H,
          anchors: null,
          imageSize: imgSize,
          errorPx: errorPx ?? null,
        });
        try {
          await apiFetch(`/cam/calibration/${pairCode}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: bodyStr,
          });
          console.log("[Calibrator] Posted calibration for code", pairCode);
        } catch (err) {
          console.warn("[Calibrator] Upload calibration failed", err);
        }
        // If user is authenticated, persist calibration to their account (Supabase-backed)
        try {
          const token = localStorage.getItem("authToken");
          if (token) {
            await apiFetch("/api/user/calibration", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: bodyStr,
            });
            console.log("[Calibrator] Synced calibration to user account");
          }
        } catch (err) {
          console.warn("[Calibrator] User calibration sync failed", err);
        }
      } catch (e) {
        /* ignore */
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [locked, pairCode]);

  const showMobileLanding = isMobileDevice && !mobileLandingOverride;

  if (showMobileLanding) {
    const linkForMobile =
      mobileLandingLink ??
      (typeof window !== "undefined"
        ? `${window.location.origin.replace(/\/$/, "")}/mobile-cam.html`
        : "/mobile-cam.html");
    return (
      <div className="mx-auto flex min-h-[calc(100vh-140px)] w-full max-w-xl flex-col justify-center gap-6 p-6">
        <div className="space-y-5 rounded-3xl border border-indigo-400/30 bg-slate-900/70 p-6 text-slate-100 shadow-xl">
          <div className="space-y-2">
            <p className="text-xs font-semibold uppercase tracking-wide text-indigo-300">
              Mobile camera
            </p>
            <h2 className="text-2xl font-semibold leading-tight text-white">
              This device is ready to stream as your dartboard camera
            </h2>
            <p className="text-sm text-slate-200/80">
              Open the lightweight mobile camera page to stream video to your
              desktop calibrator. You can still come back here if you need the
              full desktop tools.
            </p>
          </div>
          <div className="space-y-2">
            <a
              href={linkForMobile}
              className="btn w-full justify-center px-4 py-2 text-base"
            >
              Open mobile camera
            </a>
            <button
              type="button"
              className="btn btn--ghost w-full justify-center px-4 py-2 text-sm"
              onClick={() => copyValue(linkForMobile, "link")}
            >
              {copyFeedback === "link" ? "Link copied!" : "Copy link"}
            </button>
          </div>
          <p className="text-xs text-slate-300/70">
            On a desktop, open Calibrator and generate a pairing code. Then tap{" "}
            <span className="font-semibold">Pair with Desktop</span> from the
            mobile camera page to connect this device.
          </p>
        </div>
        <button
          type="button"
          className="self-center text-xs font-medium text-indigo-200 underline decoration-dotted decoration-indigo-300/70 transition hover:text-indigo-100"
          onClick={() => setMobileLandingOverride(true)}
        >
          Continue to desktop calibrator
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {isMobileDevice && mobileLandingOverride && (
        <div className="rounded-2xl border border-indigo-400/30 bg-indigo-500/10 p-4 text-sm text-indigo-100">
          <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            <p className="leading-relaxed">
              Using a phone? Switch back to the streamlined mobile camera
              interface for an easier pairing flow.
            </p>
            <button
              type="button"
              className="btn btn--ghost px-3 py-1 text-xs"
              onClick={() => setMobileLandingOverride(false)}
            >
              Open mobile camera mode
            </button>
          </div>
        </div>
      )}
      <div className="card space-y-6 p-6">
        <header className="flex flex-wrap items-start justify-between gap-4">
          <div className="space-y-2">
            <p className="text-xs font-semibold uppercase tracking-wide text-indigo-300">
              Marker calibration
            </p>
            <h2 className="text-2xl font-semibold leading-tight text-white">
              Align your board with the autoscoring overlay
            </h2>
            <p className="max-w-2xl text-sm opacity-80">
              Place the printable fiducial markers around the double ring,
              capture a clear frame, and let the calibrator compute a precise
              homography.
            </p>
          </div>
          <div className="flex flex-col items-end gap-2 text-xs font-medium">
            <span className="inline-flex items-center gap-2 rounded-full border border-indigo-400/50 bg-indigo-500/10 px-3 py-1">
              <span className="opacity-60">Mode</span>
              <span>
                {mode === "local"
                  ? "Desktop camera"
                  : mode === "phone"
                    ? "Phone camera"
                    : "Wifi device"}
              </span>
            </span>
            <span
              className={`inline-flex items-center gap-2 rounded-full border px-3 py-1 ${streaming ? "border-emerald-400/60 bg-emerald-500/10 text-emerald-100" : "border-white/20 bg-white/5 text-slate-200"}`}
            >
              <span
                className={`h-2 w-2 rounded-full ${streaming ? "bg-emerald-400" : "bg-slate-400"}`}
              />
              {streaming ? "Live stream active" : "Stream idle"}
            </span>
            {locked ? (
              <div className="space-y-3 rounded-2xl border border-emerald-400/40 bg-emerald-500/10 p-4 text-sm">
                <div className="flex items-center justify-between gap-2">
                  <div className="flex items-center gap-3">
                    <div className="flex h-10 w-10 items-center justify-center rounded-full bg-emerald-500/20">
                      <span className="text-lg">âœ“</span>
                    </div>
                    <div>
                      <h4 className="font-semibold text-emerald-100">
                        Calibration active
                      </h4>
                      <p className="text-xs opacity-80">
                        Your calibration is saved and active across all game
                        modes. It will be used in Online, Offline, and
                        Tournaments.
                      </p>
                    </div>
                  </div>
                  <button
                    className="btn btn--ghost px-2 py-1 text-xs whitespace-nowrap"
                    onClick={() => setCalibration({ locked: false })}
                    title="Unlock to recalibrate"
                  >
                    Unlock
                  </button>
                </div>
                {errorPx != null && (
                  <div className="text-xs opacity-75">
                    Precision: {errorPx.toFixed(2)} px RMS error
                  </div>
                )}
              </div>
            ) : null}
          </div>
        </header>

        <div className="grid gap-6 xl:grid-cols-[minmax(0,2fr)_minmax(320px,1fr)]">
          <section className="space-y-4">
            <div className="space-y-4 rounded-2xl border border-white/10 bg-black/40 p-4">
              <div className="flex flex-wrap items-center justify-between gap-4 text-xs">
                <div className="flex flex-wrap items-center gap-3">
                  <span className="uppercase tracking-wide opacity-60">
                    Video source
                  </span>
                  <div className="flex items-center gap-1">
                    <button
                      className={`btn px-3 py-1 ${mode === "local" ? "bg-emerald-600 hover:bg-emerald-700" : "bg-slate-700 hover:bg-slate-600"}`}
                      data-testid="mode-local"
                      onClick={() => {
                        setMode("local");
                        if (typeof DROPDOWN_DEBUG !== 'undefined' && DROPDOWN_DEBUG) console.debug('[Calibrator] setMode(local)', Date.now());
                        stopCamera(false);
                      }}
                      title="Use local camera"
                    >
                      Local
                    </button>
                    <button
                      className={`btn px-3 py-1 ${mode === "phone" ? "bg-emerald-600 hover:bg-emerald-700" : "bg-slate-700 hover:bg-slate-600"}`}
                      data-testid="mode-phone"
                      onClick={() => {
                        setMode("phone");
                        if (typeof DROPDOWN_DEBUG !== 'undefined' && DROPDOWN_DEBUG) console.debug('[Calibrator] setMode(phone)', Date.now());
                        stopCamera(false);
                      }}
                      title="Enable camera on this device"
                    >
                      Phone
                    </button>
                    <button
                      className={`btn px-3 py-1 ${mode === "wifi" ? "bg-emerald-600 hover:bg-emerald-700" : "bg-slate-700 hover:bg-slate-600"}`}
                      data-testid="mode-wifi"
                      onClick={() => {
                        setMode("wifi");
                        if (typeof DROPDOWN_DEBUG !== 'undefined' && DROPDOWN_DEBUG) console.debug('[Calibrator] setMode(wifi)', Date.now());
                        stopCamera(false);
                        try { startWifiConnection(); } catch (e) { console.debug('[Calibrator] startWifiConnection failed', e); }
                      }}
                      title="Discover wifi/USB autoscoring devices"
                    >
                      Wifi
                    </button>
                  </div>
                </div>
                <div className="flex flex-wrap items-center gap-3">
                  <div className="flex items-center gap-2">
                    <span className="opacity-70">Zoom</span>
                    <input
                      type="range"
                      min={50}
                      max={200}
                      step={5}
                      value={Math.round((zoom || 1) * 100)}
                      onChange={(e) =>
                        setZoom(
                          Math.max(
                            0.5,
                            Math.min(2, Number(e.target.value) / 100),
                          ),
                        )
                      }
                    />
                    <span className="w-12 text-right">
                      {Math.round((zoom || 1) * 100)}%
                    </span>
                  </div>
                  <button className="btn px-3 py-1" onClick={() => setZoom(1)}>
                    Actual
                  </button>
                </div>
              </div>
              {/* Tools pill (always visible) */}
              <div className="ml-3 relative">
                <button
                  className="inline-flex items-center gap-2 rounded-full border border-indigo-400/30 bg-indigo-400/10 px-3 py-1 text-sm"
                  onClick={() => setToolsPopoverOpen(!toolsPopoverOpen)}
                  data-testid="cal-tools-popper-button"
                >
                  <span className="font-semibold">Cal. Tools</span>
                  {preserveCalibrationOverlay && (
                    <span className="ml-2 text-xs opacity-70">(overlay preserved)</span>
                  )}
                </button>
                {toolsPopoverOpen && (
                  <div
                    className="absolute right-0 mt-2 w-64 rounded-lg border bg-gray-900/80 p-3 shadow-lg z-50"
                    data-testid="cal-tools-popover"
                    role="dialog"
                  >
                    <div className="text-xs mb-2">Calibrator quick tools</div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-show-darts"
                        type="checkbox"
                        checked={showDartPreview}
                        onChange={(e) => setShowDartPreview(e.target.checked)}
                      />
                      <label htmlFor="hdr-show-darts" className="text-sm">
                        Show darts overlay
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <button className="btn btn--ghost btn-sm" onClick={() => resetVisualAdjustments()}>
                        Reset visual adjustments
                      </button>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-autocommit"
                        type="checkbox"
                        checked={autoCommitTestMode}
                        onChange={(e) => setAutoCommitTestMode(e.target.checked)}
                      />
                      <label htmlFor="hdr-autocommit" className="text-sm">
                        Enable autocommit test
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-autocommit-online"
                        type="checkbox"
                        checked={allowAutocommitInOnline}
                        onChange={(e) => setAllowAutocommitInOnline(e.target.checked)}
                        disabled={!autoCommitTestMode}
                      />
                      <label htmlFor="hdr-autocommit-online" className="text-sm">
                        Allow autocommit in Online/Tournament matches (dangerous)
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-autocommit-immediate"
                        type="checkbox"
                        checked={autoCommitImmediate}
                        onChange={(e) => setAutoCommitImmediate(e.target.checked)}
                      />
                      <label
                        htmlFor="hdr-autocommit-immediate"
                        className="text-sm"
                      >
                        Autocommit immediate when detected
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-show-detected"
                        type="checkbox"
                        checked={showDetectedOverlay}
                        onChange={(e) => setShowDetectedOverlay(e.target.checked)}
                      />
                      <label htmlFor="hdr-show-detected" className="text-sm">
                        Show detected rings overlay
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <input
                        id="hdr-force-detected"
                        type="checkbox"
                        checked={forceDetectedOnly}
                        onChange={(e) => setForceDetectedOnly(e.target.checked)}
                      />
                      <label htmlFor="hdr-force-detected" className="text-sm">
                        Force detected-only overlay (bypass homography)
                      </label>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <label htmlFor="hdr-double-adjust" className="text-sm mr-2">Double adj</label>
                      <input
                        id="hdr-double-adjust"
                        type="range"
                        min={0.95}
                        max={1.10}
                        step={0.005}
                        value={doubleOuterAdjust}
                        onChange={(e) => setDoubleOuterAdjust(parseFloat(e.target.value))}
                      />
                      <span className="text-xs ml-2">{(doubleOuterAdjust * 100).toFixed(1)}%</span>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <label htmlFor="hdr-treble-adjust" className="text-sm mr-2">Treble adj</label>
                      <input
                        id="hdr-treble-adjust"
                        type="range"
                        min={0.95}
                        max={1.10}
                        step={0.005}
                        value={trebleOuterAdjust}
                        onChange={(e) => setTrebleOuterAdjust(parseFloat(e.target.value))}
                      />
                      <span className="text-xs ml-2">{(trebleOuterAdjust * 100).toFixed(1)}%</span>
                    </div>
                    <div className="flex items-center gap-2 mb-2">
                      <select
                        id="hdr-align-select"
                        className="input"
                        value={aligningRing || ''}
                        onChange={(e) => setAligningRing(e.target.value ? (e.target.value as any) : null)}
                      >
                        <option value="">-- Align ring --</option>
                        <option value="double">Double Outer</option>
                        <option value="treble">Treble Outer</option>
                        <option value="bull">Bull Outer</option>
                      </select>
                      <div className="text-xs opacity-70 ml-2">Click on the physical ring to align</div>
                    </div>
                    <div className="flex items-center justify-between mt-2">
                      <div className="text-xs opacity-70">
                        {lastDetectedLabel || "No recent detection"}
                      </div>
                      <div>
                        <button
                          className="btn btn--small"
                          onClick={() => {
                            console.debug('[Calibrator] popover Commit click (onClick)');// eslint-disable-line no-console
                            doCommit();
                          }}
                          onPointerDown={() => {
                            console.debug('[Calibrator] popover Commit click (onPointerDown)');// eslint-disable-line no-console
                            doCommit();
                          }}
                        >
                          Commit
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div
                className="relative w-full overflow-hidden rounded-2xl border border-indigo-400/30 bg-black"
                style={{
                  aspectRatio: frameSize
                    ? `${frameSize.w} / ${frameSize.h}`
                    : "16 / 9",
                }}
              >
                {(mode === "phone" ? !streaming || !paired : !streaming) && (
                  <div className="absolute inset-0 z-20 flex items-center justify-center bg-gradient-to-br from-black/40 to-black/10">
                    <DartLoader calibrationComplete={phase === "computed"} />
                  </div>
                )}
                <div
                  className="absolute inset-0"
                  style={{
                    transform: `scale(${zoom || 1})`,
                    transformOrigin: "center center",
                  }}
                >
                  <video
                    ref={videoRef}
                    onLoadedMetadata={(ev) => {
                      try {
                        const v = ev.currentTarget as HTMLVideoElement;
                        if (v.videoWidth && v.videoHeight)
                          setFrameSize({ w: v.videoWidth, h: v.videoHeight });
                      } catch {}
                    }}
                    className={`absolute inset-0 h-full w-full object-cover transition-opacity duration-300 ${hasSnapshot ? "opacity-0 -z-10" : "opacity-100 z-10"}`}
                    autoPlay
                    playsInline
                    muted
                    controls={false}
                  />
                  {videoPlayBlocked && (
                    <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur">
                      <button
                        className="rounded-lg bg-white px-4 py-2 font-semibold text-slate-900 shadow-lg"
                        onClick={async () => {
                          try {
                            await videoRef.current?.play();
                            setVideoPlayBlocked(false);
                            setStreaming(true);
                            setPhase("capture");
                          } catch (e) {
                            console.warn("Tap-to-play retry failed", e);
                            alert(
                              "Tap to enable video failed. Please check browser settings or reload the page.",
                            );
                          }
                        }}
                      >
                        Tap to allow video
                      </button>
                    </div>
                  )}
                  <canvas
                    ref={canvasRef}
                    className={`absolute inset-0 h-full w-full transition-opacity duration-300 ${hasSnapshot ? "opacity-100 z-10" : "opacity-0 -z-10"}`}
                  />
                  <canvas
                    ref={overlayRef}
                    data-testid="calibrator-overlay"
                    onPointerDown={onClickOverlay}
                    className="absolute inset-0 z-30 h-full w-full cursor-crosshair"
                  />
                </div>
              </div>

              <label className="flex items-center gap-2 text-xs">
                <input
                  type="checkbox"
                  className="accent-indigo-600"
                  checked={calibrationGuide}
                  onChange={(e) => setCalibrationGuide(e.target.checked)}
                />
                Show preferred-view guide overlay
              </label>

              {/* Stage cards in the main free space â€” quick access to the three calibration stages */}
              <div className="mt-4 grid grid-cols-1 gap-3 sm:grid-cols-3 overflow-visible">
                <div className="rounded-2xl border border-white/10 bg-white/5 p-4 overflow-visible">
                  <h3 className="text-sm font-semibold">Stage 1 Â· Capture</h3>
                  <p className="text-xs opacity-70">
                    Start your camera or upload a photo to capture the board.
                  </p>
                  <div className="mt-3 flex flex-col gap-2">
                    {mode === "local" && (
                      <button className="btn" onClick={startCamera}>
                        Enable camera
                      </button>
                    )}
                    {mode === "phone" && (
                      <button
                        className="btn"
                        title="Enable camera on this device"
                        onClick={() => {
                          try {
                            window.dispatchEvent(
                              new CustomEvent("ndn:start-camera", {
                                detail: { mode: "phone" },
                              }),
                            );
                          } catch {
                            startPhonePairing();
                          }
                        }}
                      >
                        Enable camera
                      </button>
                    )}
                    {mode === "wifi" && (
                      <button className="btn" onClick={startWifiConnection}>
                        Connect wifi camera
                      </button>
                    )}
                    <button
                      className="btn"
                      onClick={captureFrame}
                      disabled={!streaming}
                    >
                      Capture frame
                    </button>
                    <button className="btn" onClick={triggerUpload}>
                      Upload photo
                    </button>
                  </div>
                </div>

                <div className="rounded-2xl border border-white/10 bg-white/5 p-4">
                  <h3 className="text-sm font-semibold">
                    Stage 2 Â· Calibration Methods
                  </h3>
                  
                  {/* MARKER CALIBRATION - PRIMARY METHOD */}
                  <div className="mt-4">
                    <h4 className="text-xs font-semibold text-blue-300 mb-2">Method 1: Marker Calibration (Recommended)</h4>
                    <p className="text-xs opacity-70 mb-2">
                      Print ArUco markers and position around your double ring
                    </p>
                    <div className="flex flex-col gap-2">
                      <button
                        className="btn bg-blue-600 hover:bg-blue-700 font-semibold text-sm"
                        onClick={openMarkerSheet}
                        data-testid="open-marker-sheet"
                      >
                        ðŸ“‹ Download Markers
                      </button>
                      <button
                        className="btn bg-indigo-600 hover:bg-indigo-700 font-semibold text-sm"
                        disabled={!hasSnapshot}
                        onClick={detectMarkers}
                        data-testid="detect-markers"
                      >
                        ðŸ” Detect Markers
                      </button>
                    </div>
                    {markerResult && (
                      <div className={`mt-2 p-2 rounded text-xs ${markerResult.success ? 'bg-green-500/20 border border-green-500/30' : 'bg-red-500/20 border border-red-500/30'}`}>
                        {markerResult.success ? (
                          <>
                            <strong className="text-green-300">âœ… Markers detected!</strong>
                            <div className="mt-1">Error: {markerResult.errorPx?.toFixed(2)} px</div>
                          </>
                        ) : (
                          <>
                            <strong className="text-red-300">âŒ {markerResult.message || 'No markers detected'}</strong>
                            {markerResult.missing?.length > 0 && (
                              <div className="mt-1">Missing: {markerResult.missing.join(', ').toUpperCase()}</div>
                            )}
                          </>
                        )}
                      </div>
                    )}
                  </div>
                  
                  {/* AUTO-CALIBRATE - FALLBACK METHOD */}
                  <div className="mt-4 border-t border-white/10 pt-4">
                    <h4 className="text-xs font-semibold text-emerald-300 mb-2">Method 2: Auto-Calibrate (Fallback)</h4>
                    <p className="text-xs opacity-70 mb-2">
                      Automatically detect dartboard rings (no markers needed)
                    </p>
                    <div className="flex flex-col gap-2">
                      <button
                        className="btn bg-emerald-600 hover:bg-emerald-700 font-semibold text-sm"
                        disabled={!hasSnapshot || autoCalibrating}
                        onClick={autoCalibrate}
                        data-testid="autocalibrate-advanced"
                      >
                        {autoCalibrating
                          ? "Auto-calibratingâ€¦"
                          : "ðŸŽ¯ Auto-Calibrate"}
                      </button>
                    </div>
                  </div>
                  
                  <div className="mt-4 border-t border-white/10 pt-4">
                    <div className="text-xs opacity-70">
                      Confidence: {forceConfidence ? 100 : confidence}%
                    </div>
                    <div className="mt-2 text-xs opacity-70">
                      Scoring image size: {imageSize ? `${imageSize.w} x ${imageSize.h}` : "â€”"}
                    </div>
                    <div className="mt-2 text-xs opacity-70">
                      Overlay display size: {overlaySize ? `${overlaySize.w} x ${overlaySize.h}` : "â€”"}
                    </div>
                    {detected && (
                      <div className="mt-2 text-xs opacity-70 bg-black/30 rounded p-2">
                        <div className="font-semibold mb-1">Detected Ring Sizes:</div>
                        <div>Double: {Math.round(detected.doubleInner)} - {Math.round(detected.doubleOuter)} px</div>
                        <div>Treble: {Math.round(detected.trebleInner)} - {Math.round(detected.trebleOuter)} px</div>
                        <div>Bull: {Math.round(detected.bullInner)} - {Math.round(detected.bullOuter)} px</div>
                        <div>Center: ({Math.round(detected.cx + correctionTx)}, {Math.round(detected.cy + correctionTy)})</div>
                      </div>
                    )}
                    <div className="mt-2">
                      <button
                        className="btn btn-secondary text-xs"
                        onClick={() => {
                          if (autoCalibrating) return;
                          autoCalibrate();
                        }}
                        disabled={!hasSnapshot || autoCalibrating}
                      >
                        Re-run Auto-Calibrate
                      </button>
                    </div>
                    {detectionMessage && (
                      <div className="mt-2 text-xs text-yellow-300">
                        {detectionMessage}
                      </div>
                    )}
                  </div>
                  
                  {/* Verification stage - appears after auto-detect */}
                  {phase === "verify" && (
                    <div className="mt-4 rounded-lg border-2 border-yellow-500/50 bg-yellow-500/10 p-3">
                      <div className="text-sm font-bold text-yellow-300 mb-2">
                        âš ï¸ VERIFY RING ALIGNMENT
                      </div>
                      <div className="text-xs text-yellow-200 mb-3">
                        Look at the overlay on your dartboard. Do the colored rings match exactly with the treble and double rings?
                      </div>
                      
                      {/* Show verification results table */}
                      {verificationResults.length > 0 && (
                        <div className="mb-3 text-xs bg-black/30 rounded p-2">
                          <div className="grid grid-cols-2 gap-1 mb-2 font-semibold border-b border-white/10 pb-1">
                            <div>Location</div>
                            <div>Status</div>
                          </div>
                          {verificationResults.map((vr, i) => (
                            <div key={i} className="grid grid-cols-2 gap-1 py-1 border-b border-white/10 last:border-0">
                              <div className="text-[10px]">{vr.label}</div>
                              <div className={`text-[10px] font-bold ${vr.match ? "text-emerald-400" : "text-rose-400"}`}>
                                {vr.note}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                      
                      <div className="flex gap-2">
                        <button
                          className="btn bg-emerald-600 hover:bg-emerald-700 text-sm flex-1"
                          onClick={() => {
                            setPhase("computed");
                            setCalibration({ locked: true });
                            setDetectionMessage("âœ… Calibration accepted and locked!");
                          }}
                        >
                          âœ… Accept & Lock
                        </button>
                        <button
                          className="btn bg-orange-600 hover:bg-orange-700 text-sm flex-1"
                          onClick={() => {
                            setPhase("capture");
                            setDetectionMessage(null);
                            setVerificationResults([]);
                            setAutoCalibrating(false);
                          }}
                        >
                          ðŸ”„ Retry
                        </button>
                      </div>
                    </div>
                  )}
                  
                  <div className="mt-2 text-xs opacity-70 flex items-center gap-2">
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        className="accent-indigo-600"
                        checked={forceConfidence}
                        onChange={(e) => setForceConfidence(e.target.checked)}
                      />
                      <span className="text-xs">Force 100% Confidence</span>
                    </label>
                    {forceConfidence && (
                      <span className="text-xs text-yellow-300">
                        âš ï¸ For testing only â€” may produce mis-registrations
                      </span>
                    )}
                  </div>
                </div>

                <div className="rounded-2xl border border-white/10 bg-white/5 p-4">
                  <h3 className="text-sm font-semibold">
                    Stage 3 Â· Align & lock
                  </h3>
                  <p className="text-xs opacity-70">
                    Click the board points, refine edges and lock calibration
                    when satisfied.
                  </p>
                  <div className="mt-3 flex flex-col gap-2">
                    <button
                      className="btn"
                      disabled={dstPoints.length < REQUIRED_POINT_COUNT}
                      onClick={compute}
                    >
                      Compute
                    </button>
                    <button
                      className={`btn ${locked ? "bg-emerald-600 hover:bg-emerald-700" : ""}`}
                      onClick={() => {
                        const newLocked = !locked;
                        if (!newLocked) {
                          setCalibration({ locked: false });
                        } else {
                          // If not yet computed (phase != computed), try to compute first
                          if (phase !== "computed") {
                             const success = compute();
                             if (!success) return; // Don't lock if compute failed
                          }
                          const overlaySize = overlayRef?.current
                            ? { w: overlayRef.current.width, h: overlayRef.current.height }
                            : videoRef?.current
                            ? { w: videoRef.current.clientWidth, h: videoRef.current.clientHeight }
                            : canvasRef?.current
                            ? { w: canvasRef.current.width, h: canvasRef.current.height }
                            : null;
                          // Apply corrections to stored H for scoring consistency
                          let correctedH = H;
                          if (correctedH && correctionSx !== 1) correctedH = scaleHomography(correctedH, correctionSx, 1);
                          if (correctedH && (correctionTx !== 0 || correctionTy !== 0)) correctedH = translateHomography(correctedH, correctionTx, correctionTy);
                          setCalibration({ H: correctedH, locked: true, overlaySize });
                        }
                      }}
                    >
                      {locked ? "Unlock" : "Lock in"}
                    </button>
                    {preserveCalibrationOverlay ? (
                      <div className="text-xs opacity-70 mt-1">
                        Overlay preservation <span className="font-semibold">enabled</span> â€” locked calibration will preserve display size
                      </div>
                    ) : (
                      <div className="text-xs opacity-70 mt-1">
                        Overlay preservation <span className="font-semibold">disabled</span> â€” locked calibration uses current canvas size
                      </div>
                    )}
                    {locked && preserveCalibrationOverlay && overlaySize && (
                      <div className="text-xs opacity-60 mt-1">
                        Overlay display size preserved: {overlaySize.w} x {overlaySize.h}
                      </div>
                    )}
                    <div className="mt-4 border-t border-white/10 pt-3">
                      <div className="flex items-center justify-between mb-2">
                        <h4 className="text-xs font-semibold">Fine-tune Corrections</h4>
                        <div className="text-xs opacity-70">
                          Applied: Sx:{correctionSx.toFixed(3)} Tx:{correctionTx.toFixed(1)} Ty:{correctionTy.toFixed(1)}
                        </div>
                      </div>
                      <div className="flex items-center justify-between mb-2">
                        <button
                          className="btn btn--ghost btn-sm text-xs"
                          onClick={() => {
                            setCorrectionSx(1.0);
                            setCorrectionTx(0);
                            setCorrectionTy(0);
                          }}
                        >
                          Reset to 1.0, 0, 0
                        </button>
                      </div>
                      <div className="space-y-2">
                        <div>
                          <label className="text-xs">Scale X: {correctionSx.toFixed(3)}</label>
                          <input
                            type="range"
                            min="0.9"
                            max="1.1"
                            step="0.001"
                            value={correctionSx}
                            onChange={(e) => setCorrectionSx(Number(e.target.value))}
                            className="w-full"
                          />
                        </div>
                        <div>
                          <label className="text-xs">Translate X: {correctionTx.toFixed(1)}</label>
                          <input
                            type="range"
                            min="-200"
                            max="200"
                            step="0.1"
                            value={correctionTx}
                            onChange={(e) => setCorrectionTx(Number(e.target.value))}
                            className="w-full"
                          />
                        </div>
                        <div>
                          <label className="text-xs">Translate Y: {correctionTy.toFixed(1)}</label>
                          <input
                            type="range"
                            min="-200"
                            max="200"
                            step="0.1"
                            value={correctionTy}
                            onChange={(e) => setCorrectionTy(Number(e.target.value))}
                            className="w-full"
                          />
                        </div>
                      </div>
                    </div>
                    <button className="btn" onClick={() => runVerification()}>
                      Verify
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {verificationResults.length > 0 && (
              <div className="mt-4 rounded-2xl border border-emerald-400/30 bg-emerald-500/5 p-4">
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div>
                    <h4 className="text-sm font-semibold text-emerald-100">
                      Verification measurements
                    </h4>
                    <p className="text-xs text-emerald-100/70">
                      Anchors must land within a few millimeters of the canonical board targets.
                      Anything highlighted in red should be adjusted before relying on autoscoring.
                    </p>
                  </div>
                  <div className="flex gap-2">
                    {verificationResults.some((r) => !r.match) && (
                      <button
                        className="btn btn-sm bg-orange-500/20 text-orange-200 hover:bg-orange-500/30 border border-orange-500/50"
                        onClick={() => autoResizeBoard()}
                      >
                        ðŸ”§ Resize
                      </button>
                    )}
                    <button
                      className="btn btn--ghost btn-sm"
                      onClick={() => setVerificationResults([])}
                    >
                      Clear
                    </button>
                  </div>
                </div>
                <div className="mt-3 overflow-x-auto">
                  <table className="w-full text-xs">
                    <thead>
                      <tr className="text-left text-emerald-100/70">
                        <th className="py-2 pr-3 font-semibold">Anchor</th>
                        <th className="py-2 pr-3 font-semibold">Expected</th>
                        <th className="py-2 pr-3 font-semibold">Detected</th>
                        <th className="py-2 pr-3 font-semibold">Î” mm</th>
                        <th className="py-2 pr-3 font-semibold">Î” px</th>
                        <th className="py-2 pr-3 font-semibold">Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      {verificationResults.map((res) => (
                        <tr key={res.label} className="border-t border-white/10">
                          <td className="py-2 pr-3 font-medium text-white">{res.label}</td>
                          <td className="py-2 pr-3 text-emerald-100/80">
                            {describeScoreTarget(res.expected.ring, res.expected.sector)}
                          </td>
                          <td className="py-2 pr-3">
                            {formatScoreLabel(res.detected)}
                          </td>
                          <td className="py-2 pr-3">
                            {typeof res.deltaMm === "number"
                              ? `${res.deltaMm.toFixed(1)} mm`
                              : "â€”"}
                          </td>
                          <td className="py-2 pr-3">
                            {typeof res.deltaPx === "number"
                              ? `${res.deltaPx.toFixed(1)} px`
                              : "â€”"}
                          </td>
                          <td className="py-2 pr-3">
                            <span
                              className={`inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-semibold ${res.match ? "bg-emerald-500/20 text-emerald-200" : "bg-rose-500/30 text-rose-100"}`}
                            >
                              {res.match ? "Pass" : "Adjust"}
                            </span>
                            {res.note && (
                              <div className="mt-1 text-[11px] text-white/70">
                                {res.note}
                              </div>
                            )}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}

            {/* Pro tip section */}
            <div className="mt-4 rounded-lg border border-blue-500/30 bg-blue-500/10 p-3">
              <div className="text-xs font-semibold text-blue-300 mb-1">
                ðŸ’¡ Pro Tip for Perfect Calibration
              </div>
              <div className="text-xs opacity-80">
                Click the 4 corners of the double ring at{" "}
                <span className="font-semibold">D20, D6, D3, and D11</span>.
                These evenly-spaced doubles lock the board orientation and yield
                a perfect (100%) confidence score.
              </div>
            </div>

            <div className="grid grid-cols-1 gap-3 text-xs sm:grid-cols-3">
              <div className="rounded-xl border border-white/10 bg-white/5 px-3 py-2">
                <div className="uppercase tracking-wide opacity-60">Phase</div>
                <div className="text-sm font-semibold capitalize">{phase}</div>
              </div>
              <div className="rounded-xl border border-white/10 bg-white/5 px-3 py-2">
                <div className="uppercase tracking-wide opacity-60">
                  Points selected
                </div>
                <div className="text-sm font-semibold">
                  {dstPoints.length} / {REQUIRED_POINT_COUNT}
                </div>
                {phase === "select" && dstPoints.length < REQUIRED_POINT_COUNT && (
                  <div className="mt-1 text-yellow-400 font-bold">
                    â†’ Click on {CALIBRATION_POINT_LABELS[dstPoints.length]} next
                  </div>
                )}
              </div>
              <div className="rounded-xl border border-white/10 bg-white/5 px-3 py-2">
                <div className="uppercase tracking-wide opacity-60">
                  Fit error
                </div>
                <div className="text-sm font-semibold">
                  {errorPx != null ? `${errorPx.toFixed(2)} px` : "â€”"}
                </div>
                {!calibrationValid && (
                  <div className="mt-2 flex items-center justify-between gap-2 text-xs">
                    <span className="opacity-70">Calibration not valid (max {ERROR_PX_MAX}px). You can still force-lock to proceed.</span>
                    <button
                      className="btn btn--ghost btn-sm"
                      onClick={() => setCalibration({ locked: true })}
                      title="Force accept calibration"
                    >
                      Force lock
                    </button>
                  </div>
                )}
              </div>
            </div>
          </section>

          <aside className="space-y-4">
            <DevicePicker
              videoDevices={videoDevices}
              streaming={streaming}
              refreshVideoDevices={refreshVideoDevices}
              testCamera={testCamera}
              onSelectPhoneCamera={handleSelectPhoneCamera}
              lastDetectedLabel={lastDetectedLabel}
              autoCommitTestMode={autoCommitTestMode}
              doCommit={doCommit}
              lastDetectedValue={lastDetectedValue}
              calibrationValid={calibrationValid}
              sectorOffset={sectorOffset ?? 0}
              onNudgeSectorOffset={(delta) => nudgeSectorOffset(delta)}
              onResetSectorOffset={() => setCalibration({ sectorOffset: 0 })}
            />

            {mode === "phone" && (
              <section className="space-y-3 rounded-2xl border border-indigo-400/30 bg-black/40 p-4 text-xs text-white">
                <div className="font-semibold">Phone pairing</div>
                <button
                  type="button"
                  className="w-full text-left px-3 py-2 rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 transition flex items-center gap-2"
                  onClick={() => copyValue(mobileUrl, "link")}
                  title="Copy mobile camera link"
                >
                  <span className="flex-1 min-w-0 font-mono break-all text-[11px]">
                    {mobileUrl}
                  </span>
                  <span className="text-[10px] uppercase tracking-wide whitespace-nowrap text-emerald-200">
                    {copyFeedback === "link" ? "Copied!" : "Copy link"}
                  </span>
                </button>
                <div className="flex items-center gap-2 text-[11px]">
                  <a
                    href={mobileUrl}
                    target="_blank"
                    rel="noreferrer"
                    className="underline decoration-dotted text-indigo-200 hover:text-indigo-100 transition"
                  >
                    Open link in new tab
                  </a>
                </div>
                <div className="opacity-80">
                  WS:{" "}
                  {ws
                    ? ws.readyState === 1
                      ? "open"
                      : ws.readyState === 0
                        ? "connecting"
                        : ws.readyState === 2
                          ? "closing"
                          : "closed"
                    : "not started"}{" "}
                  Â· {httpsInfo?.https ? "HTTPS on" : "HTTP only"}
                </div>
                {pairCode && (
                  <button
                    type="button"
                    className="w-full text-left px-3 py-2 rounded-lg border border-white/10 bg-white/5 hover:bg-white/10 transition flex items-center justify-between gap-2"
                    onClick={() => copyValue(pairCode, "code")}
                    title="Copy pairing code"
                  >
                    <span className="font-mono tracking-[0.3em] text-sm">
                      {pairCode}
                    </span>
                    <span className="text-[10px] uppercase tracking-wide whitespace-nowrap text-emerald-200">
                      {copyFeedback === "code" ? "Copied!" : "Copy code"}
                    </span>
                  </button>
                )}
                <div className="flex items-center gap-2">
                  {ttl !== null && <span>Expires in {ttl}s</span>}
                  <button
                    className="btn px-2 py-1 text-xs"
                    onClick={regenerateCode}
                  >
                    Regenerate
                  </button>
                </div>
                {showTips && (
                  <div className="space-y-2 rounded-lg border border-slate-700/50 bg-slate-900/60 p-3 text-slate-200">
                    <div className="font-semibold">Troubleshooting</div>
                    <ul className="list-disc space-y-1 pl-4">
                      <li>
                        Phone and desktop must be on the same Wiâ€‘Fi network.
                      </li>
                      <li>
                        Allow the server through your firewall (ports 8787 and{" "}
                        {httpsInfo?.https ? httpsInfo.port : 8788}).
                      </li>
                      <li>
                        On iPhone, use HTTPS links (QR will prefer HTTPS when
                        enabled).
                      </li>
                    </ul>
                    <div className="text-right">
                      <button
                        className="btn btn--ghost px-2 py-1 text-xs"
                        onClick={() => setShowTips(false)}
                      >
                        Hide tips
                      </button>
                    </div>
                  </div>
                )}
              </section>
            )}

            {/* Sidebar Step cards intentionally removed â€” these controls remain available in the main stage cards above to avoid showing duplicate controls in the right-hand sidebar. */}
          </aside>
        </div>

        {mode === "wifi" && !streaming && (
          <div className="space-y-3 rounded-2xl border border-indigo-400/30 bg-black/40 p-4 text-xs text-white">
            <div className="font-semibold">Wifi scoring devices</div>
            {discoveringWifi ? (
              <div className="flex items-center gap-2">
                <div className="h-4 w-4 animate-spin rounded-full border-b-2 border-white" />
                <span>Scanning network for devicesâ€¦</span>
              </div>
            ) : wifiDevices.length > 0 ? (
              <div className="space-y-2">
                {wifiDevices.map((device) => (
                  <div
                    key={device.id}
                    className="flex items-center justify-between rounded border border-slate-700/50 bg-slate-900/60 p-2"
                  >
                    <div>
                      <div className="font-medium">{device.name}</div>
                      <div className="opacity-70">
                        {device.ip}:{device.port} Â· {device.type.toUpperCase()}
                      </div>
                      <div className="opacity-70 text-xs">
                        Capabilities: {device.capabilities.join(", ")}
                      </div>
                    </div>
                    <button
                      className={`btn px-2 py-1 text-xs ${device.status === "connecting" ? "bg-yellow-600" : device.status === "online" ? "bg-green-600" : "bg-blue-600"}`}
                      onClick={() => connectToWifiDevice(device)}
                      disabled={device.status === "connecting"}
                    >
                      {device.status === "connecting"
                        ? "Connectingâ€¦"
                        : "Connect"}
                    </button>
                  </div>
                ))}
                <div className="text-center">
                  <button
                    className="btn px-2 py-1 text-xs"
                    onClick={startWifiConnection}
                  >
                    Rescan network
                  </button>
                </div>
              </div>
            ) : (
              <div className="space-y-2 text-center">
                <div>No wifi scoring devices found.</div>
                <div className="opacity-70">
                  Ensure your wifi cameras are powered on and on the same
                  network.
                </div>
                <button
                  className="btn px-2 py-1 text-xs"
                  onClick={startWifiConnection}
                >
                  Scan again
                </button>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
