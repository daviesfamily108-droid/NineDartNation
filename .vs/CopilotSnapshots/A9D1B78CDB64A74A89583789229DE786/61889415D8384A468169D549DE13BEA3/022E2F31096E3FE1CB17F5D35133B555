import React, {
  useCallback,
  useEffect,
  useRef,
  useState,
  Suspense,
} from "react";
import { Sidebar, TabKey, buildTabList } from "./components/Sidebar";
import { useIsAdmin } from "./utils/admin";
const Home = React.lazy(() => import("./components/Home"));
import ScrollFade from "./components/ScrollFade";
import Calibrator from "./components/Calibrator";
// Lazy-load CameraView to avoid importing a large camera module at app
// bootstrap time. This prevents the component module from executing during
// initial module evaluation which can avoid TDZ issues when other modules
// import shared stores during startup.
const CameraView = React.lazy(() => import("./components/CameraView"));
const OfflinePlay = React.lazy(() => import("./components/OfflinePlay"));
const Friends = React.lazy(() => import("./components/Friends"));
import Toaster from "./components/Toaster";
import AdminDashboard from "./components/AdminDashboard";
import SettingsPanel from "./components/SettingsPanel";
import Auth from "./components/Auth";
import { ThemeProvider } from "./components/ThemeContext";
import {
  ArrowDownRight,
  ArrowUpRight,
  Bell,
  CalendarDays,
  Handshake,
  Menu,
  MessageCircle,
  Trophy,
  Users,
} from "lucide-react";
import { useWS } from "./components/WSProvider";
import {
  getMonthlyAvg3,
  getAllTimeAvg,
  syncStatsFromServer,
} from "./store/profileStats";
import { useMatch } from "./store/match";
import { useUserSettings } from "./store/userSettings";
import { useCalibration } from "./store/calibration";
import { apiFetch, getApiBaseUrl } from "./utils/api";
import { DISCORD_INVITE_URL } from "./utils/config";
import "./styles/premium.css";
import "./styles/themes.css";
const OnlinePlay = React.lazy(() => import("./components/OnlinePlay.clean"));
const StatsPanel = React.lazy(() => import("./components/StatsPanel"));
const Tournaments = React.lazy(() => import("./components/Tournaments"));
const AdminAccess = React.lazy(() => import("./components/AdminAccess"));
// AdminAccess already imported above
import Drawer from "./components/ui/Drawer";
const OpsDashboard = React.lazy(() => import("./components/OpsDashboard"));
import HelpAssistant from "./components/HelpAssistant";
import GlobalCameraLogger from "./components/GlobalCameraLogger";
import GlobalPhoneVideoSink from "./components/GlobalPhoneVideoSink";
import GlobalCameraWatchdog from "./components/GlobalCameraWatchdog";
import GlobalCameraRecoveryToasts from "./components/GlobalCameraRecoveryToasts";
import InstallPicker from "./components/InstallPicker";
import AddToHomeButton from "./components/AddToHomeButton";
import Footer from "./components/Footer";
import AutoPauseManager from "./components/AutoPauseManager";
import MatchPage from "./components/MatchPage";
import { useToast } from "./store/toast";
import { NDN_OPEN_NOTIFICATIONS_EVENT } from "./utils/events";
import WSConnectionDot from "./components/WSConnectionDot";

export default function App() {
  const appRef = useRef<HTMLDivElement | null>(null);
  const [avatar, setAvatar] = useState<string>("");
  const [isFullscreen, setIsFullscreen] = useState(false);
  const ws = (() => {
    try {
      return useWS();
    } catch {
      return null;
    }
  })();
  const [tab, setTab] = useState<TabKey>("score");
  const [isMobile, setIsMobile] = useState<boolean>(false);
  const [navOpen, setNavOpen] = useState<boolean>(false);
  const [user, setUser] = useState<any>(null);
  // Use this helper to set user without losing previously fetched subscription data
  // This avoids toggles/flicker in the UI during partial user refreshes
  function setUserWithMerge(next: any) {
    if (!next) {
      setUser(next);
      return;
    }
    setUser((prev: any) => {
      const merged = { ...prev, ...next };
      if (prev?.subscription && !next?.subscription)
        merged.subscription = prev.subscription;
      if (next?.subscription) merged.subscription = next.subscription;
      // Keep fullAccess aligned with subscription unless explicitly provided
      merged.fullAccess = !!(
        merged.subscription?.fullAccess ||
        next?.fullAccess ||
        merged.fullAccess
      );
      return merged;
    });
  }
  const MINIMAL_UI =
    ((import.meta as any).env?.VITE_MINIMAL_AFTER_LOGIN || "").toString() ===
    "1";
  const [minimalUI, setMinimalUI] = useState<boolean>(false);
  const [allTimeAvg, setAllTimeAvg] = useState<number>(0);
  const [avgDelta, setAvgDelta] = useState<number>(0);
  const { avgMode } = useUserSettings();
  const _cameraEnabled = useUserSettings((s) => s.cameraEnabled);
  const matchInProgress = useMatch((s) => s.inProgress);
  const isCompact = matchInProgress && tab !== "score";
  const toast = useToast();
  const normalizedDelta = Math.abs(avgDelta) >= 0.05 ? avgDelta : 0;
  const API_URL = getApiBaseUrl();
  const calibration = useCalibration();
  const userSettings = useUserSettings();

  // Sync locked state from userSettings to calibration store on app mount
  useEffect(() => {
    try {
      const persistedLocked = userSettings.preferredCameraLocked;
      if (persistedLocked && calibration.locked !== persistedLocked) {
        // If userSettings says it's locked but calibration store doesn't, sync it
        calibration.setCalibration({ locked: persistedLocked });
        console.info(
          "[APP] Synced camera locked state from userSettings:",
          persistedLocked,
        );
      }
    } catch (e) {
      console.warn("Failed to sync locked state from userSettings", e);
    }
  }, []); // Run only on mount

  // Globally catch unhandled promise rejections and surface as warnings so the
  // devtools console is less noisy. We still log the reason so developers can
  // inspect real issues, but avoid uncaught exceptions flooding the console.
  useEffect(() => {
    const onUnhandled = (ev: PromiseRejectionEvent) => {
      try {
        // Some rejections are expected (e.g., media play AbortError during
        // transient UI swaps). Log as a warn and prevent default reporting.
        // Keep the logged payload small to avoid huge dumps.
        // @ts-ignore - ev.reason exists on modern browsers
        console.warn("Unhandled promise rejection (suppressed):", ev.reason);
        ev.preventDefault?.();
      } catch (err) {
        console.error("Failed to refresh friend notifications:", err);
        return false;
      }
    };
    window.addEventListener("unhandledrejection", onUnhandled as any);
    return () =>
      window.removeEventListener("unhandledrejection", onUnhandled as any);
  }, []);

  // Restore user from token on mount (run once only)
  useEffect(() => {
    const token = localStorage.getItem("authToken");
    if (!token) return;

    // Validate token with server
    fetch(`${API_URL}/api/auth/me`, {
      headers: { Authorization: `Bearer ${token}` },
    })
      .then((res) => res.json())
      .then((data) => {
        if (data?.user) {
          setUserWithMerge(data.user);
          try {
            const cached = localStorage.getItem(
              `ndn:subscription:${data.user.email}`,
            );
            if (cached)
              setUserWithMerge({
                ...data.user,
                subscription: JSON.parse(cached),
              });
          } catch (e) {}
          fetchSubscription(data.user);
        } else {
          // Token invalid, remove it
          localStorage.removeItem("authToken");
        }
      })
      .catch(() => {
        // Network error, keep token for offline retry
      });
  }, []);

  // Handle minimal UI delay when user is present
  useEffect(() => {
    if (user && MINIMAL_UI) {
      setMinimalUI(true);
      const timer = setTimeout(() => setMinimalUI(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [MINIMAL_UI, user]);

  // If URL contains ?match=1 render a minimal match-only page (allows opening dedicated match windows)
  try {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("match") === "1") {
      return (
        <ThemeProvider>
          <AutoPauseManager />
          <MatchPage />
        </ThemeProvider>
      );
    }
  } catch {}

  useEffect(() => {
    const onLogout = () => {
      try {
        localStorage.removeItem("mockUser");
        localStorage.removeItem("authToken");
        if (user?.email)
          localStorage.removeItem(`ndn:subscription:${user.email}`);
      } catch (e) {}
      setUser(null);
      setTab("score");
    };
    window.addEventListener("ndn:logout" as any, onLogout as any);
    return () =>
      window.removeEventListener("ndn:logout" as any, onLogout as any);
  }, []);
  // Refresh all-time avg when user changes or stats update
  useEffect(() => {
    if (!user?.username) {
      setAvgDelta(0);
      return;
    }
    try {
      // Persist the active username so lower-level modules (e.g., stats/store) can
      // resolve aliases like "You" back to the signed-in user when persisting stats.
      localStorage.setItem("ndn:currentUser", user.username);
      (window as any).ndnCurrentUser = user.username;
    } catch {}
    try {
      syncStatsFromServer(user.username);
    } catch {}
    const refresh = () => {
      const nextAvg =
        avgMode === "24h"
          ? getMonthlyAvg3(user.username)
          : getAllTimeAvg(user.username);
      setAllTimeAvg(nextAvg);
      const key = `ndn:allTimeAvgSnapshot:${user.username}`;
      const now = Date.now();
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();

      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          localStorage.setItem(
            key,
            JSON.stringify({
              value: nextAvg,
              ts: now,
              month: currentMonth,
              year: currentYear,
            }),
          );
          setAvgDelta(0);
          return;
        }
        const parsed = JSON.parse(raw);
        const baseline = Number(parsed?.value) || 0;
        const snapshotMonth = Number(parsed?.month);
        const snapshotYear = Number(parsed?.year);

        // Check if we're in a new month - if so, reset the baseline
        if (snapshotYear !== currentYear || snapshotMonth !== currentMonth) {
          // New month - set baseline to current average and delta to 0
          localStorage.setItem(
            key,
            JSON.stringify({
              value: nextAvg,
              ts: now,
              month: currentMonth,
              year: currentYear,
            }),
          );
          setAvgDelta(0);
        } else {
          // Same month - calculate delta from baseline
          const delta = nextAvg - baseline;
          setAvgDelta(Number.isFinite(delta) ? delta : 0);
        }
      } catch {
        setAvgDelta(0);
      }
    };
    refresh();
    const onUpdate = () => refresh();
    const onStorage = (e: StorageEvent) => {
      const key = e.key || "";
      if (!key) return;
      // React to stats writes from other tabs/windows (e.g., match popouts)
      const prefixes = [
        `ndn_stats_${user.username}`,
        `ndn_stats_ts_${user.username}`,
        `ndn_stats_daily_${user.username}`,
        `ndn:allTimeAvgSnapshot:${user.username}`,
      ];
      if (prefixes.some((p) => key.startsWith(p))) refresh();
    };
    window.addEventListener("ndn:stats-updated", onUpdate as any);
    window.addEventListener("storage", onStorage);
    return () => {
      window.removeEventListener("ndn:stats-updated", onUpdate as any);
      window.removeEventListener("storage", onStorage);
    };
  }, [user?.username, avgMode]);

  // Load avatar from localStorage when user changes
  useEffect(() => {
    if (!user?.username) {
      setAvatar("");
      return;
    }
    const storedAvatar = localStorage.getItem(
      `ndn:bio:profilePhoto:${user.username}`,
    );
    setAvatar(storedAvatar || "");
  }, [user?.username]);

  // Listen for avatar updates from SettingsPanel
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (
        e.key?.startsWith("ndn:bio:profilePhoto:") &&
        user?.username &&
        e.key.endsWith(user.username)
      ) {
        setAvatar(e.newValue || "");
      }
    };
    const handleAvatarUpdate = (e: any) => {
      // Check if this update is for the current user
      if (e.detail?.username === user?.username) {
        setAvatar(e.detail?.avatar || "");
      }
      // Also check localStorage as backup for any avatar update
      if (user?.username) {
        const storedAvatar = localStorage.getItem(
          `ndn:bio:profilePhoto:${user.username}`,
        );
        setAvatar(storedAvatar || "");
      }
    };
    // Also check localStorage when window becomes visible (user switches tabs)
    const handleVisibilityChange = () => {
      if (!document.hidden && user?.username) {
        const storedAvatar = localStorage.getItem(
          `ndn:bio:profilePhoto:${user.username}`,
        );
        setAvatar(storedAvatar || "");
      }
    };

    // Check localStorage periodically as a fallback (less frequent to reduce work)
    const checkAvatarInterval = setInterval(() => {
      if (user?.username) {
        const storedAvatar = localStorage.getItem(
          `ndn:bio:profilePhoto:${user.username}`,
        );
        if (storedAvatar && storedAvatar !== avatar) {
          setAvatar(storedAvatar);
        }
      }
    }, 10000); // every 10s

    window.addEventListener("storage", handleStorageChange);
    window.addEventListener(
      "ndn:avatar-updated" as any,
      handleAvatarUpdate as any,
    );
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener(
        "ndn:avatar-updated" as any,
        handleAvatarUpdate as any,
      );
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      clearInterval(checkAvatarInterval);
    };
  }, [user?.username, avatar]);

  // Handle payment success for username change
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const paid = urlParams.get("paid");
    const usernameChange = urlParams.get("username-change");
    if (
      paid === "1" ||
      paid === "username-change" ||
      usernameChange === "free"
    ) {
      const pendingUsername = localStorage.getItem("pendingUsernameChange");
      if (pendingUsername && user?.email) {
        // Call the change username API
        fetch(`${API_URL}/api/change-username`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email: user.email,
            newUsername: pendingUsername,
          }),
        })
          .then((res) => res.json())
          .then((data) => {
            if (data.ok) {
              alert("Username changed successfully!");
              localStorage.removeItem("pendingUsernameChange");
              // Update user data and token
              if (data.token) {
                localStorage.setItem("authToken", data.token);
              }
              if (data.user) {
                setUserWithMerge(data.user);
              }
              // Clean up URL
              window.history.replaceState(
                {},
                document.title,
                window.location.pathname,
              );
            } else {
              alert(
                "Failed to change username: " + (data.error || "Unknown error"),
              );
            }
          })
          .catch(() => {
            alert("Network error while changing username");
          });
      }
    }
  }, [user?.email]);

  // Keep full-screen state in sync when the user enters/exits full screen mode.
  useEffect(() => {
    const onFullscreenChange = () =>
      setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener("fullscreenchange", onFullscreenChange);
    // initialize
    setIsFullscreen(!!document.fullscreenElement);
    return () =>
      document.removeEventListener("fullscreenchange", onFullscreenChange);
  }, []);

  // Handle payment success for premium subscription
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const subscription = urlParams.get("subscription");
    if (subscription === "success" && user?.email) {
      // Refresh user data to get updated subscription status
      fetch(`${API_URL}/api/auth/me`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("authToken")}`,
        },
      })
        .then((res) => res.json())
        .then((data) => {
          if (data?.user) {
            setUserWithMerge(data.user);
            alert("Premium subscription activated successfully!");
            // Clean up URL
            window.history.replaceState(
              {},
              document.title,
              window.location.pathname,
            );
          }
        })
        .catch(() => {
          alert(
            "Subscription activated, but failed to refresh user data. Please refresh the page.",
          );
        });
    }
  }, [user?.email]);

  // Universal responsive breakpoint: navigation mode is based on viewport width,
  // not device type/UA. This ensures consistent UI across all devices.
  useEffect(() => {
    const mq = window.matchMedia("(max-width: 768px)");
    const update = () => setIsMobile(mq.matches);
    update();

    try {
      mq.addEventListener("change", update);
    } catch {
      // Safari/older browsers
      mq.addListener(update);
    }

    window.addEventListener("resize", update);
    window.addEventListener("orientationchange", update);

    return () => {
      window.removeEventListener("resize", update);
      window.removeEventListener("orientationchange", update);
      try {
        mq.removeEventListener("change", update);
      } catch {
        mq.removeListener(update);
      }
    };
  }, []);

  // Keep the CSS header height token in sync with the actual header element so
  // mobile offsets (drawer / main scroll padding) are accurate.
  useEffect(() => {
    function updateHeaderHeight() {
      const el = document.getElementById("ndn-header");
      if (!el) return;
      const h = Math.ceil(el.getBoundingClientRect().height);
      document.documentElement.style.setProperty("--ndn-header-h", `${h}px`);
    }

    updateHeaderHeight();
    window.addEventListener("resize", updateHeaderHeight);
    window.addEventListener("orientationchange", updateHeaderHeight);
    // Also respond when the compact mode changes so header height updates
    // (isCompact is part of the dependency list)
    return () => {
      window.removeEventListener("resize", updateHeaderHeight);
      window.removeEventListener("orientationchange", updateHeaderHeight);
    };
  }, [isCompact]);

  // Global logout handler: return to sign-in screen and clear minimal local user context
  useEffect(() => {
    const onLogout = () => {
      try {
        // Clear any lightweight local flags (keep stats unless explicitly reset)
        localStorage.removeItem("ndn:avatar");
        if (user?.email)
          localStorage.removeItem(`ndn:subscription:${user.email}`);
      } catch (e) {}
      setUser(null);
      setTab("score");
    };
    window.addEventListener("ndn:logout" as any, onLogout as any);
    return () =>
      window.removeEventListener("ndn:logout" as any, onLogout as any);
  }, []);

  // Apply username changes from Settings globally and propagate via WS presence
  useEffect(() => {
    const onName = (e: any) => {
      try {
        const next = String(e?.detail?.username || "").trim();
        if (!next) return;
        setUser((prev: any) => {
          const u = prev ? { ...prev, username: next } : prev;
          return u;
        });
        // Recompute name color on next effect pass based on new username/avatar
        // Send presence update so friends/lobby reflect the new name
        try {
          const email = (user?.email || "").toLowerCase();
          if (ws && next && email)
            ws.send({ type: "presence", username: next, email });
        } catch (e) {}
      } catch (e) {}
    };
    window.addEventListener("ndn:username-changed" as any, onName as any);
    return () =>
      window.removeEventListener("ndn:username-changed" as any, onName as any);
  }, [ws, user?.email]);

  // Handle tab changes from Home component quick access pills
  useEffect(() => {
    const onTabChange = (e: any) => {
      try {
        const tab = String(e?.detail?.tab || "").trim();
        if (
          tab &&
          [
            "score",
            "offline",
            "online",
            "stats",
            "settings",
            "admin",
            "tournaments",
            "friends",
          ].includes(tab)
        ) {
          setTab(tab as TabKey);
          // Ensure the mobile hamburger sits in a visible "free" spot after
          // navigating to a new tab (the header layout can change per tab).
          // Compute the right edge of the left brand pill (if present) and
          // nudge the CSS var so the hamburger sits just to its right.
          try {
            const brand = document.querySelector(
              ".ndn-mobile-brand",
            ) as HTMLElement | null;
            if (
              brand &&
              typeof window !== "undefined" &&
              typeof window.getComputedStyle === "function"
            ) {
              const rect = brand.getBoundingClientRect();
              const leftPx = Math.max(8, Math.round(rect.right + 8));
              document.documentElement.style.setProperty(
                "--ndn-mobile-menu-left",
                `${leftPx}px`,
              );
            }
            // Also set a small per-tab section gap variable so specific pages
            // can have precise spacing below the header on mobile.
            const tabGapMap: Record<string, string> = {
              online: "8mm",
              tournaments: "10mm",
              calibrate: "12mm",
            };
            const gap = tabGapMap[tab] || "0px";
            document.documentElement.style.setProperty(
              "--ndn-section-gap",
              gap,
            );
          } catch (err) {
            // best-effort only
            // console.warn('Could not reposition mobile hamburger', err);
          }
        }
      } catch (e) {}
    };
    window.addEventListener("ndn:change-tab" as any, onTabChange as any);
    return () =>
      window.removeEventListener("ndn:change-tab" as any, onTabChange as any);
  }, []);
